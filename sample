import boto3
import pbcore.logger as logger
from datetime import datetime
import service.PropertyUtil as propertyutil
from boto3.dynamodb.conditions import Key
from botocore.exceptions import ClientError
import os
from pbcore.aws.parameterstore import get_lambda_ssm_param_value
import service.PropertyUtil as property_util
import json
from boto3.dynamodb.types import TypeDeserializer
from boto3.dynamodb.types import TypeSerializer

LAMBDA_FUNCTION = os.environ.get("AWS_LAMBDA_FUNCTION_NAME")


table_name = propertyutil.getValue("ENVIRONMENT") + "_push_notification_token"


dynamodb = boto3.client('dynamodb')

import boto3
import pbcore.logger as logger
from datetime import datetime
import service.PropertyUtil as propertyutil
from boto3.dynamodb.conditions import Key
from botocore.exceptions import ClientError
import os
from pbcore.aws.parameterstore import get_lambda_ssm_param_value
import service.PropertyUtil as property_util
import json
from boto3.dynamodb.types import TypeDeserializer
from boto3.dynamodb.types import TypeSerializer

LAMBDA_FUNCTION = os.environ.get("AWS_LAMBDA_FUNCTION_NAME")


table_name = propertyutil.getValue("ENVIRONMENT") + "_push_notification_token"


dynamodb = boto3.client('dynamodb')

"""
Fetches device details from DynamoDB based on the provided device ID.

Args:
- deviceId: The ID of the device to fetch details for.

Returns:
- dict: A dictionary containing the device details fetched from DynamoDB.
"""
def fetch_by_deviceId(deviceId):
    try:
        response = dynamodb.get_item(
            TableName=table_name,
            Key={"device_id": {"S": deviceId}}
        )
        item = response["Item"]
        print("Device Details")
        return dynamo_to_python(item)
    except ClientError as err:
        logger.error(f"fetch record error {err}")

"""
Deletes a database record based on the provided device ID.

Args:
- deviceId: The ID of the device whose record needs to be deleted.

Returns:
- dict: The response from the deletion operation.
"""
def delete_by_deviceId(deviceId):
    try:
        return dynamodb.delete_item(TableName=table_name, Key={"device_id": {"S": deviceId}})
        
    except ClientError as err:
        logger.error(f"delete record error {err}")

"""
Creates a new record in DynamoDB based on the provided record details.

Args:
- record: A dictionary containing the details of the record to be inserted.

Returns:
- dict: The response from the DynamoDB `put_item` operation.
"""
def insert_device_details(record):
    logger.info("Create the Record in DynamoDB")
    now = datetime.now()
    date_time = now.strftime("%y-%m-%d, %H:%M:%S")
    try:
        item = {key: {'S': str(value)} for key, value in record.items()} | {
            "created_at": {'S': date_time},
            "modified_at": {'S': date_time},
        }
        response = dynamodb.put_item(TableName=table_name, Item=item)
        print(f'Insert response: {response}')

    except Exception as e:
        logger.error(f'An unexpected error occurred :: create_or_update_record : {e}')

"""
Updates device details in DynamoDB based on the provided device details.

Args:
- device_details: A JSON string containing the device details to be updated.

Returns:
- dict: The response from the update operation in DynamoDB.
"""
def update_device_details(device_details):
    now = datetime.now()
    date_time = now.strftime("%y-%m-%d, %H:%M:%S")
    logger.info(f"Starting update process at {date_time}")

    record = python_to_dynamo(json.loads(device_details))
    attribute_updates = {key: {'Value': value} for key, value in record.items() if key != 'deviceId'}
    attribute_updates['modfied_at'] = {'Value': {'S': date_time}}

    try:
        response = dynamodb.update_item(
            TableName=table_name,
            Key={"device_id": record["deviceId"]},
            AttributeUpdates=attribute_updates
        )
        print(f'Record Updated:{response}')
    except ClientError as err:
        logger.error(f"Unable to update device details for deviceId: {record['deviceId']} - {err}")
        raise
    logger.info("Updated device details successfully")
    return response
 
"""
Converts a DynamoDB object to a Python dictionary.

Args:
- dynamo_object: A DynamoDB object to be converted to a Python dictionary.

Returns:
- dict: The Python dictionary after deserialization.
"""
def dynamo_to_python(dynamo_object: dict) -> dict:
    deserializer = TypeDeserializer()
    return {
        k: deserializer.deserialize(v)
        for k, v in dynamo_object.items()
    }

"""
Converts a Python dictionary to a DynamoDB object.

Args:
- python_object: A Python dictionary to be converted to a DynamoDB object.

Returns:
- dict: The DynamoDB object after serialization.
"""
def python_to_dynamo(python_object: dict) -> dict:
    serializer = TypeSerializer()
    return {
        k: serializer.serialize(v)
        for k, v in python_object.items()
    }

---------------
def insert_device_details(record):
    logger.info("Create the Record in DynamoDB")
    now = datetime.now()
    date_time = now.strftime("%y-%m-%d, %H:%M:%S")
    
    try:
        response=dynamodb.put_item(TableName = table_name, Item = {
                    "customer_Id": {'S' : record['customerId']},
                    "cif": {'S' : record['cif']},
                    "device_id": {'S' : record['deviceId']},
                    "device_type": {'S' : record['deviceType']},
                    "token": {'S' : record['token']},
                    "platform": {'S' : record['platform']},
                    "app_version": {'S' : record['appVersion']},
                    "os_version": {'S' : record['osVersion']},
                    "make": {'S' : record['make']},
                    "model": {'S' : record['model']},
                    "language": {'S' : record['language']},
                    "endpoint_arn": {'S' : record['endpoint_arn']},
                    "created_at": {'S' : date_time},
                    "modfied_at": {'S' : date_time}
                 })
        print(f'Insert response:{response}')

    except Exception as e:
       logger.error(f'An unexpected error occurred :: create_or_update_record : {e}')

"""
Method for update device details
"""


def update_device_details(device_details):
    print(f'Update information')
    now = datetime.now()
    date_time = now.strftime("%y-%m-%d, %H:%M:%S")
    logger.info(
        f"New record"
    )
    
    record = python_to_dynamo(json.loads(device_details))
    logger.info(
        f"Serialize"
    )
    logger.info(
        f"Updating fields"
    )
    try:
        response = dynamodb.update_item(TableName = table_name,
            Key={"device_id": record["deviceId"]},
            AttributeUpdates={"cif": {'Value' : record['cif']},
                    "customer_id": {'Value' : record['deviceId']},
                    "device_type": {'Value' : record['deviceType']},
                    "token": {'Value' : record['token']},
                    "platform": {'Value' : record['platform']},
                    "app_version": {'Value' : record['appVersion']},
                    "os_version": {'Value' : record['osVersion']},
                    "make": {'Value' : record['make']},
                    "model": {'Value' : record['model']},
                    "language": {'Value' : record['language']},
                    "endpoint_arn": {'Value' : record['endpointArn']},
                    "modfied_at": {'Value' : {'S' : date_time}}
            })
        print(f'Record Updated:{response}')
    except ClientError as err:
        logger.error(
            f"Unable to update device details for deviceId: {record["deviceId"]}"
        )
        raise
    logger.info(f"Updated device details")
    return response

import json

class DeviceTokenDetails:
    def __init__(self, customerId, cif, deviceId, deviceType, token, platform, appVersion, osVersion, make, model, language, endpointArn):
        
        self.customerId = customerId
        self.cif = cif
        self.deviceId = deviceId
        self.deviceType = deviceType
        self.token =  token
        self.platform = platform
        self.appVersion = appVersion
        self.osVersion = osVersion
        self.make = make
        self.model = model
        self.language = language
        self.endpointArn = endpointArn

    # Setters
    def setCustomerId(self, customerId):
        self.customerId = customerId

    def setCif(self, cif):
        self.cif = cif    

    def setDeviceId(self, deviceId):
        self.deviceId = deviceId    

    def setDeviceType(self, deviceType):
        self.DeviceType = deviceType

    def setToken(self, token):
        self.token = token

    def setPlatform(self, platform):
        self.platform = platform

    def setAppVersion(self, appVersion):
        self.appVersion = appVersion

    def setOsVersion(self, osVersion):
        self.osVersion = osVersion    

    def setMake(self, make):
        self.make = make

    def setModel(self, model):
        self.model = model

    def setLanguage(self, language):
        self.language = language    

    def setEndpointArn(self, endpointArn):
        self.endpointArn = endpointArn

    # Getter
    def getCustomerId(self):
        return self.customerId

    def getCif(self):
        return self.cif    

    def getDeviceId(self):
        return self.deviceId    

    def getDeviceType(self):
        return self.DeviceType

    def getToken(self):
        return self.token

    def getPlatform(self):
        return self.platform

    def getAppVersion(self):
        return self.appVersion

    def getOsVersion(self):
        return self.osVersion    

    def getMake(self):
        return self.make

    def getModel(self):
        return self.model

    def getLanguage(self):
        return self.language    

    def getEndpointArn(self):
        return self.endpointArn

    def to_json(self):
        print("I am here")
        return json.dumps(self, default=lambda o: o.__dict__, indent=4)

 response = DeviceTokenDetails(
         message_data['customerId'],message_data['cif'], message_data['deviceId'], message_data['deviceType'],message_data['token'],message_data['platform'],message_data['appVersion'],
         message_data['osVersion'],message_data['make'],message_data['model'],message_data['language'],endpoint).to_json()

{'queueName': 'push-notification-token-sync-q-sit', 'action': 'm', 'customerId': '6046097', 'cif': '1005507350', 'deviceId': '12a53c91-d558-440d-a3d1-c9fd869c7112', 'deviceType': 'i', 'token': 'test update token', 'platform': 'android', 'appVersion': 'Uat', 'osVersion': '', 'make': 'samsung', 'model': 'SM-T575', 'language': 'en', 'platformVersion': ''}


 """
    Orchestrates actions based on message data.
    
    Args:
        message_data (dict): A dictionary containing message data.
        message_headers (dict): A dictionary containing message headers.
        logger_data (dict): A dictionary containing logger data.
    
    Returns:
        None
 """

"""
    Prepares a device token details request based on message data and an endpoint.

    Args:
        message_data (dict): A dictionary containing message data.
        endpoint (str): The endpoint to include in the request.

    Returns:
        str: JSON representation of the DeviceTokenDetails object.
    """

verifyPayment
confirmPayment
deletePayment
sendRequestToPay
retrieveRequestsToPay
retrieveDetailRequestToPay
sendRequestToPayQrCode
retrieveDetailRequestToPayQrCode
verifyBusinessPayment
confirmBusinessPayment
retrievePaymentRequests
retrieveQrCodePayment
retrievePaymentDetails

Update 13 endpoints to pass device details and verify the changes - 2.5 days
Configuare and update setup/enquiry api to retrive list of Purpose of Payment and cache the list of purpose of payment - 1.5 days
Update 13 APIs to store Purpose of Payment and retrive Purpose of Payment from retrive APIs and pass to send and request money(outwards) 5 days
Update changes in notification service (Inward requests from Anni) - 3 days 
