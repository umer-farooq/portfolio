AE208091031001991861093
AE580210000002102733554


private void prepareAcctLoanDeposits(CustPositionResponse custPosition, CustomerProducts customerFavouriteProducts, CustomerProducts customerProducts, FeaturePromotion featurePromotion,
        Map<String, ProductPreference> userPreferences) {
    // sort accounts in customer position accounts by sorting order of Account types
    sortAccountsByAccountType(custPosition);
    List<AccountDetails> acctDetails = custPosition.getListOfAccounts();
    
    if (acctDetails != null && !acctDetails.isEmpty()) {
        for (AccountDetails acctDtl : acctDetails) {
            // Decide whether to show on dashboard
            if (isLoanAccountCode(acctDtl.getAccountType())) {
                if (!StringUtils.startsWithAny(acctDtl.getAccountNo(), SKIP_PD_LOANS)) {
                    Loan loan = getLoanData(acctDtl);
                    loan.setProduct(ProductTypes.LOAN.name());
                    
                    if (userPreferences.containsKey(loan.getLoanNumber())) {
                        ProductPreference prodPref = userPreferences.get(loan.getLoanNumber());
                        loan.setNickName(prodPref.getNickName());
                        loan.setDisplaySequence(prodPref.getDisplaySequence());
                        loan.setIsFavorite(prodPref.getIsFavorite());
                        loan.setIsHide(prodPref.getIsHide());
                        // Add all favorite products
                        if (prodPref.getIsFavorite()) {
                            customerFavouriteProducts.addLoan(loan);
                        }
                    } else {
                        loan.setDisplaySequence(0);
                    }
                    customerProducts.addLoan(loan);
                } else {
                    log.warn("#### Skipping PD loan from customer loan dashboard:{}", acctDtl.getAccountNo());
                }
            } else {
                // Skip deposit with HNI / ISL / NIF / ISB
                if (AccountType.TD.getCode().equals(acctDtl.getAccountType())) {
                    String accountId = acctDtl.getAccountNo();
                    if (StringUtils.startsWithAny(accountId, AppConstants.SKIP_PREFIX_DEPOSIT)) {
                        acctDtl.setAccountNo(accountId.substring(3));
                    }
                }
                Account acct = getAccountAndDepositData(acctDtl);
                
                if (userPreferences.containsKey(acct.getNumber())) {
                    ProductPreference prodPref = userPreferences.get(acct.getNumber());
                    acct.setNickName(prodPref.getNickName());
                    acct.setDisplaySequence(prodPref.getDisplaySequence());
                    acct.setIsFavorite(prodPref.getIsFavorite());
                    acct.setIsHide(prodPref.getIsHide());
                    acct.setIban(acctDtl.getIban());
                    // Add all favorite products
                    if (prodPref.getIsFavorite()) {
                        if (AccountType.TD.getCode().equals(acctDtl.getAccountType())) {
                            acct.setProduct(ProductTypes.DEPOSIT.name());
                            customerFavouriteProducts.addDeposit(acct);
                        } else {
                            acct.setProduct(ProductTypes.ACCOUNT.name());
                            customerFavouriteProducts.addAccount(acct);
                        }
                    }
                } else {
                    acct.setDisplaySequence(0);
                }
                
                // If iSave account to get the count to show on dashboard
                if (ProductCode.ISAVE.getCode().equals(acctDtl.getAccountCategoryCode())) {
                    acct.setAccountSubType("isave");
                    customerProducts.addIsave(acct);
                    customerProducts.addAccount(acct); // Adding Isave Account in account list after discussing with Pratik
                } else {
                    if (AccountType.TD.getCode().equals(acctDtl.getAccountType())) {
                        customerProducts.addDeposit(acct);
                    } else {
                        customerProducts.addAccount(acct);
                    }
                }
                
                if (Objects.nonNull(acctDtl.getDebitCards()) && !acctDtl.getDebitCards().isEmpty()) {
                    acctDtl.getDebitCards().stream().forEach(debitCard -> {
                        if (DateTimeHelper.INSTANCE.isFutureDate(debitCard.getExpirationDate(), DATE_DDMMYYYY)) {
                            if (DebitCardStatus.NEW_CARD.getCode().equals(debitCard.getCardStatus())) {
                                featurePromotion.addMaskedDcNumber(TextUtils.INSTANCE.maskCardNumber(debitCard.getDebitCardIdentifier(), AppConstants.MASK_CHARCTER));
                                if ("N".equalsIgnoreCase(debitCard.getCardDisplayIndicator())) {
                                    featurePromotion.incrementDebitCardCount();
                                }
                            }
                            if (AppConstants.DBT_CARD_ALLOWED_STATUS.contains(debitCard.getCardStatus())) {
                                Product product = new Product();
                                product.setLabel(TextUtils.INSTANCE.maskCardNumber(debitCard.getDebitCardIdentifier(), AppConstants.MASK_CHARCTER));
                                product.setProdRef(TextUtils.INSTANCE.getCardRef(debitCard.getDebitCardIdentifier()));
                                product.setStatus(DebitCardStatus.find(debitCard.getCardStatus()).getStatusDesc());
                                product.setProductType(ProductTypes.DEBIT);
                                product.setExpiryDate(DateTimeHelper.INSTANCE.formatDate(debitCard.getExpirationDate(), DATE_DDMMYYYY, DATE_MMYY));
                                if (Objects.nonNull(debitCard.getIssueDate()) && !debitCard.getIssueDate().isEmpty()) {
                                    product.setIssueDate(DateTimeHelper.INSTANCE.formatDate(debitCard.getIssueDate(), DATE_DDMMYYYY, DATE_MMYY));
                                } else {
                                    product.setIssueDate(debitCard.getIssueDate());
                                }
                                product.setDigitalCardIndicator(debitCard.getDigitalCardIndicator());
                                product.setVirtualCardIndicator(debitCard.getVirtualCardIndicator());
                                // product.setIssueDate(staticDataRepository.fetchStaticData_EN(VIRTUAL_DEBIT_CARD, ISSUE_DATE).getDescription());
                                // product.setDigitalCardIndicator(staticDataRepository.fetchStaticData_EN(VIRTUAL_DEBIT_CARD, DIGITAL_CARD_INDICATOR).getDescription());
                                // product.setVirtualCardIndicator(staticDataRepository.fetchStaticData_EN(VIRTUAL_DEBIT_CARD, VIRTUAL_CARD_INDICATOR).getDescription());
                                log.info("Virtual Debit card IssueDate, Digital", product.getIssueDate(), product.getVirtualCardIndicator(), product.getDigitalCardIndicator());
                                acct.addDebitCard(product);
                            }
                        }
                        
                        log.info("Debit Card Status " + DebitCardStatus.CARD_ACTIVE.getCode());
                        log.info("Debit Fetch Card Status " + debitCard.getCardStatus());
                        
                        if (DebitCardStatus.CARD_ACTIVE.getCode().equals(debitCard.getCardStatus())) {
                            if ("N".equalsIgnoreCase(debitCard.getCardDisplayIndicator())) {
                                featurePromotion.incrementActiveDebitCardCount();
                            }
                        }
                    });
                }
            }
        }
    } else {
        log.warn("Account:{} is not allowed on Dashboard View", acctDtl);
    }
}

kubectl cp <pod_name>:/var/kafka-ssl/abc.jks /local/path/abc.jks
kubectl exec -n <namespace> <pod_name> -- readlink -f /var/kafka-ssl/abc.jks

[root@g42uatlibmb1 npss]# kubectl exec -n npss npss-notifications-6467fb85db-4g5bq  -- readlink -f /var/ssl-store-kafka-ks/ibmb.keystore.uat.jks
/var/ssl-store-kafka-ks/..2024_06_24_07_46_23.547751902/ibmb.keystore.uat.jks
[root@g42uatlibmb1 npss]# kubectl cp npss-notifications-6467fb85db-4g5bq :..2024_06_24_07_46_23.547751902/ibmb.keystore.uat.jks /root/abc.jks
error: filespec must match the canonical format: [[namespace/]pod:]file/path
[root@g42uatlibmb1 npss]# kubectl cp npss-notifications-6467fb85db-4g5bq :/var/ssl-store-kafka-ks/..2024_06_24_07_46_23.547751902/ibmb.keystore.uat.jks  /root/abc.jks
error: filespec must match the canonical format: [[namespace/]pod:]file/path

kubectl cp npss/npss-notifications-6467fb85db-4g5bq:/var/ssl-store-kafka-ks/..2024_06_24_07_46_23.547751902/ibmb.keystore.uat.jks /root/abc.jks



String jsonString = "{"
    + "\"applicationArea\":{"
        + "\"countryOfOrigin\":\"AE\","
        + "\"senderId\":\"MOB\","
        + "\"transactionId\":\"A9f5243582a124a42bfa8fbe35e5db3e8\","
        + "\"transactionDateTime\":\"2024-XX-XXT04:01:04.004Z\","
        + "\"language\":\"EN\","
        + "\"creationDateTime\":\"22/Jun/2024 04:01:04\","
        + "\"requiredExecutionDate\":\"22/Jun/2024 04:01:04\""
    + "},"
    + "\"responseStatus\":{"
        + "\"status\":\"SUCCESS\","
        + "\"errorDetails\":[{"
            + "\"errorCode\":\"0\","
            + "\"errorDesc\":\"SUCCESS\""
        + "}]"
    + "},"
    + "\"common\":{"
        + "\"rateMode\":\"DBMODE\","
        + "\"rateReferenceNumber\":\"NA\""
    + "},"
    + "\"ratesResponse\":[{"
        + "\"buyCurrency\":\"USD\","
        + "\"sellCurrency\":\"AED\","
        + "\"buyingRate\":3.65779,"
        + "\"sellingRate\":3.68827,"
        + "\"dealtCurrency\":\"AED\","
        + "\"dealtAmount\":100.0,"
        + "\"status\":\"OK\","
        + "\"ccyPair\":\"USD.AED/S\","
        + "\"GMbuyingRate\":3.67248,"
        + "\"GMsellingRate\":3.67358,"
        + "\"GMbuyingMargin\":0,"
        + "\"GMsellingMargin\":0"
    + "}]"
+ "}";

22 Jun 2024 04:01:04,332 INFO (WebContainer : 31) (MOBILE-1000753765) [RequestInterceptor:]: Resource:/ft/mcsend/v1/fxrate/fetch, Request:{"amount":100.0,"fr
omCurrency":"AED","toCurrency":"PHP","transferCurrency":"AED","transferType":"P2P","txnRef":"f1db6b034aec4e44882ec1bbcf99d622"}

22 Jun 2024 04:01:04,332 INFO (WebContainer : 31) (MOBILE-1000753765) [RequestResolver:]: pathURL /ft/mcsend/v1/fxrate/fetch
22 Jun 2024 04:01:04,332 INFO (WebContainer : 31) (MOBILE-1000753765) [RequestResolver:]: rootPath:/ft
22 Jun 2024 04:01:04,332 INFO (WebContainer : 31) (MOBILE-1000753765) [RequestResolver:]: remainingPath:/mcsend/v1/fxrate/fetch
22 Jun 2024 04:01:04,341 INFO (WebContainer : 31) (MOBILE-1000753765) [FxRateSF:]: isNonUSDSettlement flag is :: false
22 Jun 2024 04:01:04,343 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: xref A9f5243582a124a42bfa8fbe35e5db3e8 | channelType "MOBILE"
22 Jun 2024 04:01:04,345 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: Connecting to URL:https://kproxy.risk-mw-pci-kong-prod.aeapps.bankfab
.com/ae/core/trapi/v1/exchange/rates, RequestType:POST, Headers:[{"name":"XXXX","value":"A9f5243582a124a42bfa8fbe35e5db3e8","elements":[{"name":"XXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXX","parameters":[],"parameterCount":0}]},{"name":"XXXXXXXX","value":"EN","elements":[{"name":"XX","parameters":[],"parameterCount":0}]},{
"name":"XXXXXXXXX","value":"MOB","elements":[{"name":"XXX","parameters":[],"parameterCount":0}]},{"name":"XXXXXXXXXXX","value":"87.200.21.97","elements":[{"n
ame":"XX.XXX.XX.XX","parameters":[],"parameterCount":0}]}]
22 Jun 2024 04:01:04,345 INFO (WebContainer : 31) (MOBILE-1000753765) [TextUtils:]: Masking special chars in log
22 Jun 2024 04:01:04,347 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: Http Request:{"rateObjectRequest":{"common":{"customerSegment":"IBMB.
MCSEND","valueDate":"2024-XX-XX","dealtCurrency":"AED","dealtAmount":100.0,"tenor":"SPOT","rateMode":"REALTIME","entity":"AE0XXXXX0001","daoCode":"1033X0100"
,"customerID":"1188110"},"rates":[{"buyCurrency":"USD","sellCurrency":"AED"}]},"applicationArea":{"countryOfOrigin":"AE","creationDateTime":"22/Jun/2024 04:0
1:04","requiredExecutionDate":"22/Jun/2024 04:01:04","senderId":"MOB","transactionDateTime":"2024-XX-XXT04:01:04.004Z","transactionId":"A9f5243582a124a42bfa8
fbe35e5db3e8","language":"EN"}}
22 Jun 2024 04:01:10,936 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: Status code 200
22 Jun 2024 04:01:10,936 INFO (WebContainer : 31) (MOBILE-1000753765) [TextUtils:]: Masking special chars in log
22 Jun 2024 04:01:10,938 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: Http Response:{"applicationArea":{"countryOfOrigin":"AE","senderId":"
MOB","transactionId":"A9f5243582a124a42bfa8fbe35e5db3e8","transactionDateTime":"2024-XX-XXT04:01:04.004Z","language":"EN","creationDateTime":"22/Jun/2024 04:
01:04","requiredExecutionDate":"22/Jun/2024 04:01:04"},"responseStatus":{"status":"SUCCESS","errorDetails":[{"errorCode":"0","errorDesc":"SUCCESS"}]},"common
":{"rateMode":"DBMODE","rateReferenceNumber":"NA"},"ratesResponse":[{"buyCurrency":"USD","sellCurrency":"AED","buyingRate":3.65779,"sellingRate":3.68827,"dea
ltCurrency":"AED","dealtAmount":100.0,"status":"OK","ccyPair":"USD.AED/S","GMbuyingRate":3.67248,"GMsellingRate":3.67358,"GMbuyingMargin":0,"GMsellingMargin"
:0}]}
22 Jun 2024 04:01:10,938 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: Http request processed in :6595 msec for URL:https://kproxy.risk-mw-p
ci-kong-prod.aeapps.bankfab.com/ae/core/trapi/v1/exchange/rates
22 Jun 2024 04:01:10,939 INFO (WebContainer : 31) (MOBILE-1000753765) [FxRateServiceInvoker:]: API URL is : https://kproxy.risk-mw-pci-kong-prod.aeapps.bankf
ab.com/ae/core/trapi/v1/exchange/rates
22 Jun 2024 04:01:10,939 INFO (WebContainer : 31) (MOBILE-1000753765) [FxRateServiceInvoker:]: Handle 4XX errors in sf class..
22 Jun 2024 04:01:10,939 ERROR (WebContainer : 31) (MOBILE-1000753765) [ExceptionHandler:]: Handle null pointer exception for:java.lang.NullPointerException
22 Jun 2024 04:01:10,940 INFO (WebContainer : 31) (MOBILE-1000753765) [LocaleHelper:]: locale:en, code:SYS_DEFAULT_ERROR, text translation:We are unable to p
rocess your request right now. Please try again later.
22 Jun 2024 04:01:10,943 INFO (WebContainer : 31) (MOBILE-1000753765) [RequestInterceptor:]: Resource:/ft/mcsend/v1/fxrate/fetch response:{"result":{"status"
:"error","errorInfo":{"code":"SYS_DEFAULT_ERROR","desc":"We are unable to process your request right now. Please try again later. "}}}
22 Jun 2024 04:01:10,943 INFO (WebContainer : 31) (MOBILE-1000753765) [UserStatisticsSF:]: CIF ID in PageViewReport userID 10007X3765, convid ba461cb4f8e3448
a81baf93f48a3e2f5, url point /ft/mcsend/v1/fxrate/fetch::
22 Jun 2024 04:01:10,944 INFO (WebContainer : 31) (MOBILE-1000753765) [UserStatisticsSF:]: Page View Report {"cif":"10007X3765","cin":"1188110","channelType"
:"MOBILE","viewedPage":"/ft/mcsend/v1/fxrate/fetch","httpStatus":"SUCCESS","httpErrorCode":"0","httpErrorDesc":"SUCCESS","apiStatus":"error","apiErrorCode":"
SYS_DEFAULT_ERROR","rc":"A9f5243582a124a42bfa8fbe35e5db3e8","creationTime":1719014464062,"completionTime":1719014470943,"remoteIp":"87.200.21.97"} ::
22 Jun 2024 04:01:10,980 INFO (WebContainer : 31) (MOBILE-1000753765) [UserStatisticsSF:]: exiting publish2UserStatisticsQ method
22 Jun 2024 04:01:10,980 INFO (WebContainer : 31) (MOBILE-1000753765) [ResponseFilter:]: == URL:/ft/mcsend/v1/fxrate/fetch processed, total time:6932 msec ==
-----------------------------------------

	public McFxRateFetchResponse fetchMCFxRate(final McFxRateFetchRequest request) {
		McFxRateFetchResponse response = new McFxRateFetchResponse();
		return execute(request, response, req -> {
			boolean isNonUSDSettlement = false;
			Double marginPerc = null;
			Double fxRate = null;
			Double conversionRate = null;
			String toCurrency = request.getToCurrency();
			Integer timeToLive = null;
			
			List<McProduct> productByCurrAndType = mcSendRepository.getProductByCurrAndType(request.getToCurrency(),
					request.getTransferType());
			if (!productByCurrAndType.isEmpty()) {
				McProduct mcProduct = productByCurrAndType.get(0);
				if (Objects.nonNull(mcProduct) && StringUtils.isNotBlank(mcProduct.getCurrencyCode())
						&& mcProduct.getCurrencyCode().equalsIgnoreCase(mcProduct.getSendCurrency())) {
					isNonUSDSettlement = true;
				}
			}
			log.info("isNonUSDSettlement flag is :: {}", isNonUSDSettlement);
			if(!isNonUSDSettlement) {
				log.debug("continuing with non USD settlement flow");
				ExchangeRateRequest exchangeRateRequest = new ExchangeRateRequest();
				String dealtCurrency = CURR_AED;
				String buyCurrency = CURR_USD;
				String sellCurrency = CURR_AED;
				exchangeRateRequest.addRate(buyCurrency, sellCurrency, dealtCurrency);
				exchangeRateRequest.setCreditValueDate(new Date());
				exchangeRateRequest.setCustomerRateSegment(MCSEND_SEGMENT);
				exchangeRateRequest.setAmount(request.getAmount());
				
				// 1.Fetch AED to USD rate
				FxRateGetRateResponse exchangeRateResponse = exchangeRateServiceInvoker
						.fetchExchangeRate(exchangeRateRequest);
				if (Objects.nonNull(exchangeRateResponse)
						&& RATE_MODE_REALTIME.equalsIgnoreCase(exchangeRateResponse.getCommon().getRateMode())
						&& exchangeRateResponse.getRatesResponse().isEmpty()) {
					throw new AppException(ErrorCodes.ERROR_FETCH_FX_RATE);
				}

				if (Objects.nonNull(exchangeRateResponse)
						&& !RATE_MODE_REALTIME.equalsIgnoreCase(exchangeRateResponse.getCommon().getRateMode())
						&& exchangeRateResponse.getRateResponse().isEmpty()) {
					throw new AppException(ErrorCodes.ERROR_FETCH_FX_RATE);
				}
				
				RateResponse rateResponse = RATE_MODE_REALTIME.equalsIgnoreCase(exchangeRateResponse.getCommon().getRateMode())
						? exchangeRateResponse.getRatesResponse().get(0)
						: exchangeRateResponse.getRateResponse().get(0);
				Double aedToUsdRate = 1/rateResponse.getSellingRate();
				
				// 2.Fetch USD to FCY rate from DB
				
				McFcyRate mcFcyRate = mcSendRepository.getMcFcyRate(toCurrency, request.getTransferType());
				if (Objects.isNull(mcFcyRate)) {
					throw new AppException(ErrorCodes.ERROR_FETCH_FX_RATE);
				}
				Double usdToFcyRate = mcFcyRate.getFxRate();
				conversionRate = aedToUsdRate * usdToFcyRate;
				log.info("conversionRate received in non USD settlement flow is :: {}", conversionRate);
				
			}else {
				//getDeal invocation
				log.debug("continuing with USD settlement flow :: ");
				FxRateFetchRequest fxRatefetchReq = new FxRateFetchRequest();
				fxRatefetchReq.setFromCurrency(request.getFromCurrency());
				fxRatefetchReq.setToCurrency(toCurrency);
				fxRatefetchReq.setTransferCurrency(request.getTransferCurrency());
				fxRatefetchReq.setAmount(request.getAmount());
				fxRatefetchReq.setTxnRef(request.getTxnRef());
				GetDealResponse dealResponse = getDeal(fxRatefetchReq);
				log.debug("Deal resp received is :: {}", dealResponse);
				if (Objects.nonNull(dealResponse)&&Objects.nonNull(dealResponse.getRate())) {
					conversionRate = 1/dealResponse.getRate().getValue();
					timeToLive = dealResponse.getTimeToLive();
				}else {
					throw new AppException(ErrorCodes.SYS_TECHNICAL_ERROR);
				}
				log.info("conversionRate received in USD settlement flow is :: {} and timeToLive is :: {}", conversionRate, timeToLive);
			}
			
			// 3.fetch margin
			//Double fxRate = aedToFcyRate;
			if (!productByCurrAndType.isEmpty()) {
				McProduct mcProduct = productByCurrAndType.get(0);
				if (Objects.nonNull(mcProduct)) {
					List<String> staffSectorList = settingsRepository.getStaffSectorList();
					if (SessionContext.getSession().getUser().identifyStaff(staffSectorList)) {
						marginPerc = mcProduct.getStaffFxMargin();
					}else
						marginPerc = mcProduct.getFxMargin();
				}
			}
			if (Objects.nonNull(marginPerc)) {
				fxRate = (conversionRate * (1 - marginPerc / 100));
			}
			McFxRate mcFxRate = new McFxRate();
			mcFxRate.setRate(new Amount(fxRate, toCurrency));
			mcFxRate.setTransferAmount(new Amount(fxRate * request.getAmount(), toCurrency));
			mcFxRate.setFromCurrency(request.getFromCurrency());
			mcFxRate.setToCurrency(toCurrency);
			mcFxRate.setTimeToLive(timeToLive);
			List<McFxRate> mcFxRates = new ArrayList<>();
			mcFxRates.add(mcFxRate);
			response.setMcFxRates(mcFxRates);
			log.debug("McFxRate is :: {}", mcFxRate.getRate());
			
			// 4. UPDATE rates in txnsession
			TxnSession txnSession = sessionRepository.findTxnSessionByTxnRef(req.getTxnRef());
			String exchangeRateStr = txnSession.getExchangeRate();
			log.debug("exchangeRateStr received from DB is :: {}", exchangeRateStr);
			FxRateGetDealResponse fxRateDealResponse = null;
			if(isNonUSDSettlement) {
				if (StringUtils.isNotBlank(exchangeRateStr)) {
					fxRateDealResponse = JsonUtils.convertToObject(FxRateGetDealResponse.class, exchangeRateStr);
					log.debug("exchangeRate received from deal service is :: {}", fxRateDealResponse);
				}else {
					log.error("Didnt receive exchangerate infor from session repo");
				}
			}
			McExchangeRate mcExchangeRate = new McExchangeRate();
			//if fx rate not exist in session
			if (StringUtils.isNotBlank(exchangeRateStr)) {
				mcExchangeRate = JsonUtils.convertToObject(McExchangeRate.class, exchangeRateStr);
			}
			mcExchangeRate.setFxRate(conversionRate);//dealWrapperRate
			mcExchangeRate.setFxRateWithMargin(fxRate);
			mcExchangeRate.setFxMargin(marginPerc);
			mcExchangeRate.setTrapiFxRate(conversionRate);//dealWrapperRate
			mcExchangeRate.setExchangeRate(!Objects.isNull(fxRateDealResponse)?getExchangeRateObj(fxRateDealResponse):null);
			log.info("final mcExchangeRate formed is :: {}", mcExchangeRate);
			
			TxnSession session = new TxnSession();
			session.setExchangeRate(JsonUtils.convertToJson(mcExchangeRate));
			session.setTxnRef(req.getTxnRef());
			log.info("Update TXN Session | txnRef: {} exchangerate:{}",req.getTxnRef(),JsonUtils.convertToJson(mcExchangeRate));
			sessionRepository.updateExchangeRate(session);

			return response;
		});
	}

----------------------------------------------------
public FxRateGetRateResponse fetchExchangeRate(ExchangeRateRequest iibRequest) {
		return invoke(ServiceURLs.FX_EXCHANGE_RATE,iibRequest,requestComposer, responseComposer);
	}

----------------------------------------------------
protected <T, R> R invoke(final ServiceURLs serviceURL, T reqObj, Function<T, String> requestComposer, Function<ConnectorResponse, R> responseComposer) {
		ConnectorResponse response = null;
		R respObj = null;
		long t1 = System.currentTimeMillis();
		try {
			serviceInvokerHelper.populateServicUrlEnum(serviceURL);
			String request = requestComposer.apply(reqObj);
			response = httpConnector.post(serviceURL, request, null);
			handleResponse(response, serviceURL);
			respObj = responseComposer.apply(response);
		} catch (Exception e) {
			if (e instanceof AppException || e instanceof SysException) {
				throw e;
			}
			log.error("service invoke failed.." , e);
			throw new AppException(ErrorCodes.SYS_TECHNICAL_ERROR, e);
		} finally {
			log.debug("Service:{} invocation time:{} msec", serviceURL, System.currentTimeMillis() - t1);
			captureHttpStatus(response);
		}
		return respObj;
	}

-------------------------------------------------------
private final Function<ExchangeRateRequest,String> requestComposer = (iibRequest)->{	   
	    Map<String, Object> reqMap = new HashMap<>();
	    SessionInfo sessionInfo = SessionContext.getSession();
	    reqMap.put(APPLICATION_AREA,FABUtils.INSTANCE.getIibReqApplicationArea(sessionInfo.getChannelType(), localeHelper.resolveLanguage(), sessionInfo.getXref()));
	    reqMap.put(RATE_REQ_OBJECT, populateIIBRequest(iibRequest));
	    return JsonUtils.convertToJson(reqMap);
	};
		
	private final Function<ConnectorResponse, FxRateGetRateResponse> responseComposer = (response) -> {
		FxRateGetRateResponse serviceResponse = new FxRateGetRateResponse();
		if (AppConstants.SUCCESS.equalsIgnoreCase(JsonUtils.getJsonPrimitive(response.getJsonResponse(), "$.responseStatus.status"))) {
			serviceResponse = JsonUtils.convertToObject(FxRateGetRateResponse.class, response.getJsonResponse());
		} else {
			throw new AppException(ErrorCodes.ERROR_FETCH_FX_RATE);
		}	
		
		return serviceResponse;
	};




https://www.credly.com/users/umer-farooq.1cd67eef/badges
https://cs.lpi.org/caf/Xamman/certification/verify/LPI000281162/jjngcyhqvv
http://81cd1176253f3f59d435-ac22991740ab4ff17e21daf2ed577041.r77.cf1.rackcdn.com/Certificates/ScrumFundamentalsCertified-UmerFarooq-554089.pdf
http://certification.salesforce.com/certification-detail-print?conId=0034A00002p

*/5 * * * *
If a user enters a credit card number:

It will check if the card is from one of these banks: FIRST GULF BANK, NATIONAL BANK OF ABU DHABI, or FIRST ABU DHABI BANK.
If the card is from one of these banks:
It will make sure the account is in AED (Emirati Dirham) and belongs to the logged-in user.
If the card is not from one of these banks:
It will check if it is a valid IBAN number.

0 0 5 * * ?
 filters records to only include those that have been modified within the past 24 hours from the current time.

Detailed Breakdown for Stakeholders with Justifications
Product Content Configuration:

Integration with Sitecore API:
Task: Develop robust API clients and handle authentication, data retrieval, and error handling.
Justification: Integrating with the Sitecore API is essential to ensure real-time updates and accurate product information on the website. Robust error handling and authentication are necessary to maintain data integrity and security.
Estimation: 2 weeks
Database Design:
Task: Create a database schema to efficiently store and query product details.
Justification: A well-designed database schema ensures that product data is stored efficiently and can be retrieved quickly, which is crucial for performance and scalability.
Estimation: 1 week
API Development:
Task: Build scalable REST APIs to serve the product content to the frontend applications.
Justification: Exposing product details through a REST API allows for decoupling the backend and frontend, making the system more modular and easier to maintain. It also facilitates integration with other systems or future enhancements.
Estimation: 2 weeks
UI/UX - Capture User Data:

Content Configuration:
Task: Set up configurations for content delivery, ensuring it is responsive to user inputs and preferences.
Justification: Dynamic content delivery enhances user experience by providing personalized information based on user inputs, which can increase user engagement and satisfaction.
Estimation: 1 week
Data Capture Endpoints:
Task: Develop backend endpoints to securely capture and store user data.
Justification: Capturing user data accurately and securely is crucial for compliance with data protection regulations and for personalizing user experience. Ensuring secure data handling prevents potential data breaches.
Estimation: 2 weeks
Validation and Processing:
Task: Implement server-side validation to ensure data integrity and security.
Justification: Validating data on the server-side helps prevent invalid or malicious data from entering the system, thus protecting the application from potential attacks and ensuring data quality.
Estimation: 1 week
Quote Functionality:

Service Integration:
Task: Develop service layer to communicate with insurance microservices.
Justification: Integrating with external microservices allows for leveraging existing functionalities and data from insurance providers, which can reduce development time and improve reliability.
Estimation: 3 weeks
Quote Logic Enhancement:
Task: Update existing quote creation logic to handle new insurance options.
Justification: Enhancing the quote functionality to include additional insurance options provides users with more choices, potentially increasing conversion rates and customer satisfaction.
Estimation: 2 weeks
Testing and Validation:
Task: Perform extensive testing to ensure the new quote functionality works seamlessly with existing systems.
Justification: Thorough testing is essential to identify and fix bugs, ensuring that the new features work correctly and do not introduce any regressions. This helps maintain system stability and reliability.
Estimation: 2 weeks

Summary with Justifications
Total Duration: Approximately 13 weeks
Resources: Depending on the team size and expertise, parallel task execution might reduce the overall time.
Justifications:
Integration Tasks: Necessary for ensuring that the backend can communicate effectively with external systems and provide real-time, accurate data to the frontend.
Database Design: Critical for performance, scalability, and efficient data retrieval.
API Development: Facilitates modularity, maintainability, and potential future integrations.
Content Configuration: Enhances user experience through personalized content delivery.
Data Capture and Validation: Ensures data integrity, compliance with regulations, and security against potential threats.
Service Integration and Logic Enhancement: Provides users with enhanced functionalities and options, improving overall service offering.
Testing and Validation: Ensures the reliability and stability of the system, preventing future issues.
This detailed and justified plan helps stakeholders understand the necessity of each task, the effort involved, and the benefits these tasks bring to the overall project. This understanding is crucial for accurate resource allocation and time estimation.


----------------------------
Product Content Configuration
Tasks:
Integration with Sitecore API:
Needs to be built from scratch: Developing API clients to fetch product data from Sitecore.
Database Design:
Needs to be built from scratch: Creating a database schema to store product details.
API Development:
Needs to be built from scratch: Building REST APIs to expose product details.
UI/UX - Capture User Data
Tasks:
Content Configuration:
Needs to be built from scratch: Setting up configurations for content delivery based on user data.
Data Capture Endpoints:
Needs to be built from scratch: Developing endpoints to capture and store user data.
Validation and Processing:
Needs to be built from scratch: Implementing server-side validation and processing for captured data.
Quote Functionality
Tasks:
Service Integration:
Needs to be built from scratch: Developing service layers to communicate with insurance microservices.
Quote Logic Enhancement:
Enhancement: Updating existing quote creation logic to handle new insurance options.
Testing and Validation:
Needs to be built from scratch: Performing extensive testing of the new and enhanced functionalities.
Summary of Tasks
Needs to be built from scratch:
Product Content Configuration

Integrate with Sitecore API
Design and implement database schema for product data
Develop REST APIs to expose product details
UI/UX - Capture User Data

Configure content delivery based on user data
Develop endpoints for capturing and storing user data
Implement server-side validation and processing
Quote Functionality

Integrate with insurance microservices
Perform comprehensive testing of new and enhanced functionalities
Needs to be enhanced:
Quote Functionality
Update the existing quote creation logic to handle new insurance options
Detailed Justification
Product Content Configuration:

Integration with Sitecore API: This task involves building the integration from scratch as it requires developing new API clients and handling specific authentication and data retrieval mechanisms.
Database Design: Creating a new database schema is necessary to store the product data effectively.
API Development: New REST APIs are required to expose product details, ensuring that frontend applications can access this data seamlessly.
UI/UX - Capture User Data:

Content Configuration: This involves setting up a new configuration system to deliver content dynamically based on user inputs, which is a new build.
Data Capture Endpoints: Developing new endpoints to capture and store user data is essential for personalizing the user experience.
Validation and Processing: Implementing server-side validation and processing ensures data integrity and security, which needs to be built from scratch.
Quote Functionality:

Service Integration: This involves building new service layers to communicate with insurance microservices, which is a new task.
Quote Logic Enhancement: Modifying the existing quote creation logic to include new insurance options is an enhancement of the current functionality.
Testing and Validation: Comprehensive testing of both new and enhanced functionalities is crucial to ensure system stability and reliability.
This breakdown helps stakeholders understand the scope of new developments and enhancements, allowing for better estimation of build efforts and resource allocation.
