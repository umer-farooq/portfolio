FMDB-114370 - Inclusion of transfer advice in email notification       
PRM-10417-BUNA SI Transfer wrong tag mapping
FMDB-140086-FAB REWARDS INDULGE CREDIT CARD || 542536 [Productnamechange]
MF-2445 - Middleware Modernization Project
FMDB-134681 FAB Mobile Service Restriction During Phone Call
FMDB-144541 URL's migration to KONG       

Phase 1: Generation of Smart PDF
The first phase involves creating a smart and extensible PDF generation mechanism that supports various transfer types and ensures that the document creation logic remains generic. This phase focuses on applying the Template Method design pattern and creating abstract and concrete classes for the PDF generation.

Steps and Components
Abstract SmartPdfGenerator Class:

Create an abstract class SmartPdfGenerator that defines the common logic for generating a PDF document. The class includes:
A template method generatePdf that contains the common PDF generation logic for different transfer types.
An abstract method buildDocumentRequest, which subclasses will implement to build entity-specific document requests.
Constructor-based dependency injection for GenerateDocumentHelper, which will handle the actual PDF document generation.
Subclass TransferPdfGenerator:

Implement the TransferPdfGenerator class, extending SmartPdfGenerator to handle TransferAdviceRequest.
Override buildDocumentRequest to create a DocumentRequest specific to the transfer advice.
Include strategies to select content items (getContentItemExchange) and map data fields (mapDataFields) based on transfer types.
Use a strategy to determine the file name dynamically using the getFileName method.
Add metadata to DocumentRequest, such as documentGeneratedFor and documentGeneratedDate.
Supporting Strategies:

Implement helper classes or methods (ContentItemExchangeStrategy, DataFieldMapperStrategy, and FileNameStrategy) to handle the dynamic aspects of content generation.
These strategies will help build content items, map data fields, and determine file names based on different transfer types.
Updated Models:

Modify PdfRequest to include fields documentGeneratedFor and documentGeneratedDate.
Create a new subclass, TransferAdviceRequest, which extends PdfRequest and includes necessary transfer-related fields.
Update PdfDocAttachment to reflect the fields for document storage.
Outcome:
This phase introduces a flexible and extensible smart PDF generation framework that can support different transfer types. The SmartPdfGenerator template method ensures the logic is reusable, while subclasses implement transfer-specific behavior.

Phase 2: Enhancement in the Notification Service
The second phase focuses on enhancing the NotificationService to support sending notifications with or without PDF attachments. This involves refactoring existing methods to handle additional parameters and making the service more flexible.

Steps and Components
Refactor processNotification Method:

Overload the processNotification method to accept an optional PdfDocAttachment. The presence of this attachment will determine whether the email should include the PDF.
Implement the logic within processNotification to decide the type of notification based on whether a PdfDocAttachment is provided:
With Attachment: Calls notifyByEmailWithAttachment, passing the PDF as an attachment.
Without Attachment: Calls notifyByEmail for regular email notifications.
Remove direct dependencies on transfer-specific logic to make the method more generalized.
Implement notifyByEmailWithAttachment:

Create a private method notifyByEmailWithAttachment in NotificationService to handle email notifications that include a PDF attachment.
Retrieve the ContentItem using the getContentItem method and use it to build the email body and subject.
Utilize PdfHelper to apply encryption to the PDF if required and send the email using sendEmailWithAttachment.
Additional Support Methods:

Introduce helper methods like resolveLanguage and resolveChannelName to streamline the notification process.
Incorporate logic for handling SMS and digital notifications in the processNotification method as per user preferences.
Outcome:
The enhanced NotificationService is now capable of dynamically including PDF attachments when sending notifications. This service is now decoupled from transfer-specific logic, allowing it to be extended in the future to handle other notification types.

Phase 3: Enhancement in the Fund Transfers Service
The final phase integrates the PDF generation and enhanced notification service into the fund transfer process. This includes making the decision to generate a PDF based on the transfer type and passing the necessary parameters to the notification service.

Steps and Components
Modify notifyPaymentSuccess Method in FundTransferService:

Refactor the notifyPaymentSuccess method to handle different transfer types (WITHIN_UAE_FUNDS_TRANSFER and WITHIN_FAB_FUNDS_TRANSFER).
Introduce logic to determine if a transfer advice PDF should be generated by using the shouldSendTransferAdvice method.
For WITHIN_UAE_FUNDS_TRANSFER, only generate the PDF if the account supports IPP or IPI.
For WITHIN_FAB_FUNDS_TRANSFER, always generate the PDF.
Generate PDF Attachment:

If the transfer requires a PDF, call TransferPdfGenerator.generatePdf to generate the document.
Use transferAdvicePdfGenerator.buildEncryptionKey to get the necessary encryption key for the PDF.
Store the resulting PdfDocAttachment for later use in the notification process.
Update Content ID:

Introduce getContentForTransferAdvice to append the word "ATTACHMENT" to the original ContentID, indicating that the notification includes a PDF attachment.
Pass PDF to NotificationService:

Pass the PdfDocAttachment to the NotificationService using the overloaded processNotification method.
If no PDF is required, call processNotification without the attachment, falling back to the default notification process.
Helper Methods:

Implement utility methods like buildParametersForContent to construct the message arguments for the notification.
Update the shouldSendTransferAdvice method to include the conditions for generating the PDF.
Outcome:
The FundTransferService is now capable of dynamically deciding whether to generate and send a transfer advice PDF based on the type of transfer. This logic is cleanly separated, reducing code duplication and making future extensions easier.

Summary
These three phases provide a cohesive solution for generating, managing, and delivering transfer advice PDFs:

Phase 1: Introduces a smart, extensible PDF generation mechanism (SmartPdfGenerator and its subclass TransferPdfGenerator).
Phase 2: Enhances the NotificationService to handle notifications with or without PDF attachments, improving flexibility.
Phase 3: Integrates the smart PDF generation and enhanced notification handling into the fund transfer process in FundTransferService.
This structured approach ensures the system adheres to the Open-Closed Principle, allowing for future enhancements and extensions without modifying the core logic.
sequenceDiagram
    participant App
    participant PersonalBankingAPI
    participant TransferFundsService
    participant SmartPdfGenerator
    participant TransferPdfGenerator
    participant GenerateDocumentHelper
    participant NotificationService
    participant EmailService

    App->>PersonalBankingAPI: initiateTransfer(transferRequest)
    PersonalBankingAPI->>TransferFundsService: processTransfer(transferRequest)
    
    TransferFundsService->>TransferFundsService: check if transfer type is WITHIN_UAE_FUNDS_TRANSFER or WITHIN_FAB_FUNDS_TRANSFER
    
    alt transferType is WITHIN_UAE_FUNDS_TRANSFER
        TransferFundsService->>TransferFundsService: check if IPI or IPP support is present
        alt IPI or IPP support present
            TransferFundsService->>SmartPdfGenerator: generatePdf(transferRequest)
            SmartPdfGenerator->>TransferPdfGenerator: buildDocumentRequest()
            TransferPdfGenerator->>GenerateDocumentHelper: generateDocument(documentRequest)
            GenerateDocumentHelper-->>TransferPdfGenerator: return PDF document
            TransferPdfGenerator-->>SmartPdfGenerator: return PdfDocAttachment
            SmartPdfGenerator-->>TransferFundsService: return PdfDocAttachment
            TransferFundsService->>TransferFundsService: update content ID for attachment
        else IPI or IPP support not present
            TransferFundsService->>TransferFundsService: Skip PDF generation
        end
    else transferType is WITHIN_FAB_FUNDS_TRANSFER
        TransferFundsService->>SmartPdfGenerator: generatePdf(transferRequest)
        SmartPdfGenerator->>TransferPdfGenerator: buildDocumentRequest()
        TransferPdfGenerator->>GenerateDocumentHelper: generateDocument(documentRequest)
        GenerateDocumentHelper-->>TransferPdfGenerator: return PDF document
        TransferPdfGenerator-->>SmartPdfGenerator: return PdfDocAttachment
        SmartPdfGenerator-->>TransferFundsService: return PdfDocAttachment
        TransferFundsService->>TransferFundsService: update content ID for attachment
    else transferType is neither
        TransferFundsService->>TransferFundsService: Skip PDF generation
    end

    TransferFundsService->>NotificationService: processNotification(contentID, sessionInfo, params, PdfDocAttachment)
    NotificationService->>NotificationService: check if PDF attachment is present
    alt If PDF attachment is present
        NotificationService->>EmailService: notifyByEmailWithAttachment()
    else If PDF attachment is not present
        NotificationService->>EmailService: notifyByEmail()
    end

    NotificationService->>NotificationService: decide on SMS/Digital notification
    NotificationService-->>TransferFundsService: Notification processed
    TransferFundsService-->>PersonalBankingAPI: return transfer response
    PersonalBankingAPI-->>App: return transfer response


public class PdfDocAttachment implements Serializable {

    private static final long serialVersionUID = 1L;
    private String fileContent;
    private DocumentContentTypes documentType;
    private String fileName;

public static final String WITHIN_FAB_TRANSFER_ADVICE_FILE_NAME = "WithinFAB_TransferAdvice";
	public static final String WITHIN_UAE_TRANSFER_ADVICE_FILE_NAME = "WithinUAE_TransferAdvice";
FT_WITHIN_UAE_SUCCESS_ATTACHMENT
FT_WITHIN_BANK_SUCCESS_ATTACHMENT
processNotification(ContentID contentID, SessionInfo sessionInfo, Map<String, Object> parameters) {
public void processNotification(ContentID contentID, SessionInfo sessionInfo, Map<String, Object> parameters) {
		try {
			User user = sessionInfo.getUser();
			log.info("User: "+user);
			if (Objects.isNull(user) || Objects.isNull(contentID)) {
				log.warn("##### Notification did not send as User or contentID is null. Params:{}", parameters);
				return;
			}

			String language = user.getPreferredLanguage();
			log.info("Language: "+language);
			language = this.resolveLanguage(language, sessionInfo);

			ChannelType channelType = sessionInfo.getChannelType();
			log.info("ChannelType: "+channelType);
			if (channelType == ChannelType.TAB) {
				channelType = ChannelType.MOBILE;
			}

			if (channelType == null) {
				log.warn("ChannelType in SessionContext is:{}", channelType);
				channelType = ChannelType.BROWSER;
			}
			
			log.info("Parameters: "+parameters);

			if(Objects.nonNull(parameters)){
				parameters.put("sendDateTime", DateTimeHelper.INSTANCE.getCurrentDateForMessage(null,DATE_DDMMYYYYHHMM));
				
				if (!((staticDataRepository.fetchStaticData_EN(FAB_CONTACT_US, LOCAL_CONTACT_CENTER_PHONE_ISL).getDescription()).equals(parameters.get("localContactCenterPhone"))))
				{
					parameters.put("localContactCenterPhone", staticDataRepository.fetchStaticData_EN(FAB_CONTACT_US, LOCAL_CONTACT_CENTER_PHONE).getDescription()); //"600525500"
				}
				if (!((staticDataRepository.fetchStaticData_EN(FAB_CONTACT_US, GLOBAL_CONTACT_CENTER_PHONE_ISL).getDescription()).equals(parameters.get("globalContactCenterPhone"))))
				{
					parameters.put("globalContactCenterPhone", staticDataRepository.fetchStaticData_EN(FAB_CONTACT_US, GLOBAL_CONTACT_CENTER_PHONE).getDescription()); //"+97126811511"
				}
				parameters.put("contactCenterEmail",  staticDataRepository.fetchStaticData_EN(FAB_CONTACT_US, CONTACT_CENTER_EMAIL).getDescription()); //"atyourservice@bankfab.com"
				parameters.put("channelName",channelType.equals(ChannelType.BROWSER)?"Online":"Mobile");

			}

			final String channelName = channelType.name().toUpperCase();
			
			//Replace with Debug
			log.info("Preparing notification for language:{}, channel:{}, contentID:{} for CIF:{}", language, channelName, contentID, user.getCif());
			
			
			if(user.getOtpState() == OTPState.EMAIL){
				this.notifyByEmail(contentID, user, language, channelName, parameters);
			} else if(user.getOtpState() == OTPState.SMS){
				this.notifyBySms(contentID, user, language, channelName, parameters);
			} else {
				this.notifyByEmail(contentID, user, language, channelName, parameters);
				this.notifyBySms(contentID, user, language, channelName, parameters);
				this.notifyByDigitalNotifications(contentID, user, language, channelName, parameters);
			}
			
		} catch (Exception e) {
			log.error("Exception while processing notification (processNotification) for:{}. Cause:{}", contentID, e);
		}
	}
	
	public void processNotificationByUserConfigPref(ContentID contentID,SessionInfo sessionInfo, Map<String, Object> parameters) {
		try {
			User user = sessionInfo.getUser();
			if (Objects.isNull(user) || Objects.isNull(contentID)) {
				log.warn("##### Notification did not send as User or contentID is null. Params:{}", parameters);
				return;
			}
	
			String language = user.getPreferredLanguage();
			language = this.resolveLanguage(language, sessionInfo);
			final String cif = user.getCif();
	
			ChannelType channelType = sessionInfo.getChannelType();
			if (channelType == ChannelType.TAB) {
				channelType = ChannelType.MOBILE;
			}

			if (channelType == null) {
				channelType = ChannelType.BROWSER;
			}
			if(Objects.nonNull(parameters)){
				parameters.put("sendDateTime", DateTimeHelper.INSTANCE.getCurrentDateForMessage(null,DATE_DDMMYYYYHHMM));
				parameters.put("localContactCenterPhone", staticDataRepository.fetchStaticData_EN(FAB_CONTACT_US, LOCAL_CONTACT_CENTER_PHONE).getDescription()); //"600525500"
				parameters.put("globalContactCenterPhone", staticDataRepository.fetchStaticData_EN(FAB_CONTACT_US, GLOBAL_CONTACT_CENTER_PHONE).getDescription()); //"+97126811511"
				parameters.put("contactCenterEmail",  staticDataRepository.fetchStaticData_EN(FAB_CONTACT_US, CONTACT_CENTER_EMAIL).getDescription()); //"atyourservice@bankfab.com"
				parameters.put("channelName",channelType.equals(ChannelType.BROWSER)?"Online":"Mobile");
			}
			
			final String channelName = channelType.name().toUpperCase();
			log.debug("Preparing notification for language:{}, channel:{}, contentID:{} for CIF:{}", language, channelName, contentID, user.getCif());
	
			if (StringUtils.isNotBlank(cif)) {				
				// Check user preferences for EMAIL notification
				if (Boolean.valueOf(preferenceRepository.userConfigEnabled(cif, contentID.name(), CONFIG_EMAIL))) {
					notifyByEmail(contentID, user, language, channelName, parameters);
				}
				// Check user preferences for SMS notification
				if (Boolean.valueOf(preferenceRepository.userConfigEnabled(cif, contentID.name(), CONFIG_SMS))) {
					notifyBySms(contentID, user, language, channelName, parameters);
				}		
				this.notifyByDigitalNotifications(contentID, user, language, channelName, parameters);
			}
		} catch (Exception e) {
			log.error("Exception while processing alert notification (processNotificationByUserConfigPref) for:{}. Cause:{}", contentID, e);
		}
	}
	
	/**
	 * Notification using preferences
	 * 
	 * @param contentID
	 * @param sessionInfo
	 * @param notificationPref
	 * @param parameters
	 */
	public void processNotification(ContentID contentID, User user, NotificationType notificationPref, Map<String, Object> parameters) {
		try {
			
			if (Objects.isNull(user) || Objects.isNull(contentID)) {
				log.warn("##### Notification did not send as User or contentID is null. Params:{}", parameters);
				return;
			}

			if(StringUtils.isBlank(user.getPreferredLanguage())) {
				user.setPreferredLanguage("EN");
			}
			log.info("Language: "+user.getPreferredLanguage());


			ChannelType channelType = ChannelType.MOBILE;
			log.info("ChannelType: "+channelType);


			final String channelName = channelType.name().toUpperCase();
			log.debug("Preparing notification for language:{}, channel:{}, contentID:{} ", user.getPreferredLanguage(), channelName, contentID);
			
			if(Objects.nonNull(notificationPref)) {
				if(notificationPref.equals(NotificationType.SMS)) {
					this.notifyBySms(contentID, user, user.getPreferredLanguage(), channelName, parameters);
				} else if(notificationPref.equals(NotificationType.EMAIL)) {
					this.notifyByEmail(contentID, user, user.getPreferredLanguage(), channelName, parameters);
				}  else if(notificationPref.equals(NotificationType.DIGITAL)) {
					this.notifyByDigitalNotifications(contentID, user, user.getPreferredLanguage(), channelName, parameters);
				}
			}
			
		} catch (Exception e) {
			log.error("Exception while processing notification (processNotification) for:{}. Cause:{}", contentID, e);
		}
	}

	
	private void notifyBySms(ContentID contentID, User user, String language, String channelName, Map<String, Object> parameters) {
		if(smsPreferenceValidation(user.getCif(), contentID.name())) {
			ContentItem contentItem = this.getContentItem(contentID, NotificationType.SMS, language, channelName);
			
			log.info("ContentItem: "+contentItem);

		if (Objects.nonNull(contentItem)) {
			final String msg = TextUtils.INSTANCE.createTextFromTemplate(contentItem.getContentText(), parameters);
			//if(!contentItem.getPath().contains("OTP")) {
				log.info("notifyBySms: CIF:{}, Generated SMS Text:{}", user.getCif(), msg);
			//}
			this.sendSms(user.getMobileNo(), msg, contentItem.getAlertId());
			if (ContentID.CUSTOMER_ONBOARD_NTB_OTP.equals(contentID) || ContentID.CUSTOMER_ONBOARD_NTB_SMS_OTP.equals(contentID)) {
				pushOtpEventToAnalytics(contentID, user, "sms otp ");
			}
		} else {
			log.error("**WARNING** Content_Item is not configured for:{}, notification:{}, language:{}, channel:{}", contentID, NotificationType.SMS, language, channelName);
			}
		}else {
			log.info("SMS- User preference didn't match with SMS delivery");
		}
	}

	private void notifyBySms(ContentID contentID, User user, String language, String channelName, String... parameters) {
		if(smsPreferenceValidation(user.getCif(), contentID.name())) {
			ContentItem contentItem = this.getContentItem(contentID, NotificationType.SMS, language, channelName);

			if (Objects.nonNull(contentItem)) {
				final String msg = TextUtils.INSTANCE.createTextFromTemplate(contentItem.getContentText(), parameters);
				if(!contentItem.getPath().contains("OTP")) {
					log.info("notifyBySms: CIF:{}, Generated SMS Text:{}", user.getCif(), msg);
				}
				this.sendSms(user.getMobileNo(), msg, contentItem.getAlertId());
			} else {
				log.error("Content_Item is not configured in database for:{}, notification:{}, language:{}, channel:{}", contentID, NotificationType.EMAIL, language, channelName);
			}
		}else {
			log.info("SMS- User preference didn't match");
		}
	}

	private void sendSms(final String mobileNo, final String smsText, final String alertId, final String... parameters) {
		
		log.info("Inside sendSMS");
		SmsRequest request = new SmsRequest();
		if (StringUtils.isBlank(mobileNo))
			throw new AppException(ErrorCodes.REG_CONTACT_NA);
		
		request.setMobileNo(mobileNo);
		request.setSmsText(smsText);
		request.setSender(settingsRepository.getEntityName());
		request.setSourceSystem(PERSONAL_BANKING_API);
		request.setRequestID(TextUtils.INSTANCE.generateId());
		request.setAlertId(Objects.nonNull(alertId)?alertId:BLANK);
	
		mqNotifier.sendSMS(JsonUtils.convertToJson(request));
	}

	private void notifyByEmail(ContentID contentID, User user, String language, String channelName, Map<String, Object> parameters) {
		ContentItem contentItem = this.getContentItem(contentID, NotificationType.EMAIL, language, channelName);
		boolean nameOtpBody = false;
		boolean mobileOtpBody = false;
		
		if (Objects.nonNull(contentItem)) {
			final String msg = TextUtils.INSTANCE.createTextFromTemplate(contentItem.getContentText(), parameters);
			final String emailSubject = TextUtils.INSTANCE.createTextFromTemplate(contentItem.getMetadata(), parameters);
			//if(!contentItem.getPath().contains("OTP")) {
				log.info("notifyByEmail: CIF:{}, Email subject:{} and Email Text:{}", user.getCif(), emailSubject, msg);
			//}

			if (DocumentContentTypes.PDF.getDbShortCode().equalsIgnoreCase(contentItem.getDocumentType())) {
				String encryptionKey = null;
				if(StringUtils.isBlank(user.getDateOfBirth())) {

					// Change for CASA NFC - Start
					if(StringUtils.isBlank(user.getName())) {
						// As name is not present, use pdf password as last 6 digit of mobile no
						encryptionKey = StringUtils.right(user.getMobileNo(), 6);
						mobileOtpBody = true;
						log.debug("CASA NFC :: mobileOtpBody="+mobileOtpBody);
					} else {
					// Change for CASA NFC - End

						String name = StringUtils.deleteWhitespace(user.getName());
						encryptionKey = StringUtils.left(name, 4) + StringUtils.right(user.getMobileNo(), 4);
						nameOtpBody = true;
					}
				} else {
					encryptionKey = StringUtils.right(user.getMobileNo(), 4) + StringUtils.right(user.getDateOfBirth(), 4);	
				}
				
				final String base64Bin = pdfHelper.createPdf(msg, encryptionKey.toLowerCase(), encryptionKey.toUpperCase(),false);
				String documentName = StringUtils.isBlank(user.getCif()) ? user.getMobileNo() : user.getCif();
				// with attachment
				String fileName = documentName.concat(".").concat(contentItem.getDocumentType());
				if(ContentID.CUSTOMER_ONBOARD_CASA_ISL_OTP.equals(contentID)) {
					this.sendEmail(user.getEmail(), base64Bin, emailSubject, fileName, contentItem.getContentType(), true, nameOtpBody, mobileOtpBody);
				}else {
					//this.sendEmail(user.getEmail(), msg, emailSubject, null, contentItem.getContentType(), false , false, mobileOtpBody);
					this.sendEmail(user.getEmail(), base64Bin, emailSubject, fileName, contentItem.getContentType(), true, nameOtpBody, mobileOtpBody);
				}

				//this.sendEmail(user.getEmail(), base64Bin, emailSubject, fileName, contentItem.getContentType(), true, nameOtpBody, mobileOtpBody);
			} else {
				// without attachment
				if(ContentID.CUSTOMER_ONBOARD_CASA_ISL_OTP.equals(contentID)) {
					this.sendEmail(user.getEmail(), msg, emailSubject, null, contentItem.getContentType(), false , false,mobileOtpBody,contentID);
					
				}else {
					log.info("Inside SendEmail");
					this.sendEmail(user.getEmail(), msg, emailSubject, null, contentItem.getContentType(), false , false, mobileOtpBody);
					if (ContentID.CUSTOMER_ONBOARD_NTB_OTP.equals(contentID)) {
						pushOtpEventToAnalytics(contentID, user, "email otp ");
					}
				}
				
			}
		} else {
			log.error("**WARNING** Content_Item is not configured for:{}, notification:{}, language:{}, channel:{}", contentID, NotificationType.EMAIL, language, channelName);
		}
	}

	private void notifyByEmail(ContentID contentID,String subjectParameter, User user, String language, String channelName, String... parameters) {
		ContentItem contentItem = this.getContentItem(contentID, NotificationType.EMAIL, language, channelName);
				
		if (Objects.nonNull(contentItem)) {
			final String msg = TextUtils.INSTANCE.createTextFromTemplate(contentItem.getContentText(), parameters);
			final String emailSubject = TextUtils.INSTANCE.createTextFromTemplate(contentItem.getMetadata(), subjectParameter);

			if(!contentItem.getPath().contains("OTP")) {
				log.info("notifyByEmail: CIF:{}, subject:{} and Email Text:{}", user.getCif(), emailSubject, msg);
			}

			if (DocumentContentTypes.PDF.getDbShortCode().equalsIgnoreCase(contentItem.getDocumentType())) {
				final String encryptionKey = StringUtils.right(user.getMobileNo(), 4) + StringUtils.right(user.getDateOfBirth(), 4);
				final String base64Bin = pdfHelper.createPdf(msg, encryptionKey, encryptionKey,false);

				// with attachment
				String fileName = user.getCif().concat(".").concat(contentItem.getDocumentType());
				this.sendEmail(user.getEmail(), base64Bin, emailSubject, fileName, contentItem.getContentType(), true, false, false);
			} else {
				// without attachment
				this.sendEmail(user.getEmail(), msg, emailSubject, null, contentItem.getContentType(), false, false, false);
			}
		} else {
			log.error("Content_Item is not configured in database for:{}, notification:{}, language:{}, channel:{}", contentID, NotificationType.EMAIL, language, channelName);
		}
	}
	
	public void notifyATSByEmailForFAQ(FAQUserDetails userDetails,ContentID contentID,String[] subjectParameter, String language, String channelName,List<TessAttachment> attachments, String... parameters) {
		boolean mailStatus = false;

		ContentItem contentItem = this.getContentItem(contentID, NotificationType.EMAIL, language, channelName);

		if (Objects.nonNull(contentItem)) {
			final String msg = TextUtils.INSTANCE.createTextFromTemplate(contentItem.getContentText(), parameters);
			final String emailSubject = TextUtils.INSTANCE.createTextFromTemplate(contentItem.getMetadata(), subjectParameter);

			log.info("notifyByEmail: subject:{} and Email Text:{}", emailSubject, msg);

			mailStatus = this.sendEmailToAtYourService(staticDataRepository.fetchStaticData_EN(FAB_CONTACT_US, CONTACT_CENTER_EMAIL).getDescription(),msg, emailSubject,contentItem.getContentType(),attachments);

		} else {
			log.error("Content_Item is not configured in database for:{}, notification:{}, language:{}, channel:{}", contentID, NotificationType.EMAIL, language, channelName);
		}

		ContentItem contentItemUser = this.getContentItem(ContentID.AT_YOUR_SERVICE_USER, NotificationType.EMAIL, language, channelName);

		if (Objects.nonNull(contentItemUser)) {
			if(StringUtils.isNotBlank(userDetails.getMaskedCin())){
				parameters[3] = "CIN: "+userDetails.getMaskedCin();
			}
			parameters[5] = userDetails.getMobileMasked();
			parameters[6] = userDetails.getEmailMasked();

			final String msg = TextUtils.INSTANCE.createTextFromTemplate(contentItemUser.getContentText(), parameters);
			final String emailSubject = TextUtils.INSTANCE.createTextFromTemplate(contentItemUser.getMetadata(), subjectParameter);

			log.info("notifyByEmail: subject:{} and Email Text:{}", emailSubject, msg);
			if(mailStatus) {
				this.sendEmailToAtYourService(userDetails.getEmail(),msg, emailSubject,contentItemUser.getContentType(),new ArrayList<>());
			}else {
				log.info("Email to At Your service failed, Hence ignoring user email communication");
			}
		} else {
			log.error("Content_Item is not configured in database for:{}, notification:{}, language:{}, channel:{}", ContentID.AT_YOUR_SERVICE_USER, NotificationType.EMAIL, language, channelName);
		}

	}

	private void notifyByEmail(ContentID contentID, User user, String language, String channelName, String... parameters) {
		ContentItem contentItem = this.getContentItem(contentID, NotificationType.EMAIL, language, channelName);

		if (Objects.nonNull(contentItem)) {
			final String msg = TextUtils.INSTANCE.createTextFromTemplate(contentItem.getContentText(), parameters);
			if(!contentItem.getPath().contains("OTP")) {
				log.info("notifyByEmail: CIF:{}, Generated Email Text:{}", user.getCif(), msg);
			}
			
			//Added for debugging
			log.info("Inside NotifyByEmail");

			if (DocumentContentTypes.PDF.getDbShortCode().equalsIgnoreCase(contentItem.getDocumentType())) {
				//final String encryptionKey = TextUtils.INSTANCE.createTextFromTemplate("{0}{1}", StringUtils.right(user.getMobileNo(), 4), StringUtils.right(user.getDateOfBirth(), 4));
				final String encryptionKey = StringUtils.right(user.getMobileNo(), 4) + StringUtils.right(user.getDateOfBirth(), 4);
				final String base64Bin = pdfHelper.createPdf(msg, encryptionKey, encryptionKey,false);
				// with attachment
				String fileName = user.getCif().concat(".").concat(contentItem.getDocumentType());
				this.sendEmail(user.getEmail(), base64Bin, contentItem.getMetadata(), fileName, contentItem.getContentType(), true, false, false);
			} else {
				// without attachment
				log.info("Inside SendEmail");
				this.sendEmail(user.getEmail(), msg, contentItem.getMetadata(), null, contentItem.getContentType(), false, false, false);
			}
		} else {
			log.error("Content_Item is not configured in database for:{}, notification:{}, language:{}, channel:{}", contentID, NotificationType.EMAIL, language, channelName);
		}
	}

	private void sendEmail(final String emailId, final String emailTxt, final String emailSubject, final String emailFileName, 
			final String mimeType, final boolean attachmentFlag, final boolean nameOtpEmailBody, final boolean mobileOtpBody) {
		if (StringUtils.isBlank(emailId)) {
			log.warn("Email processing SKIPPED as no emailid available in system. emailSubject:{}", emailSubject);
			return;
		}
			
		EmailRequest request = new EmailRequest();
		request.setFromAddress(settingsRepository.getEmailFromAddress());
		request.addToAddress(emailId);
		request.setEntityName(settingsRepository.getEntityName());
		request.setSourceSystem(settingsRepository.getEntityName());
		request.setEmailSubject(emailSubject);
		request.setRequestID(TextUtils.INSTANCE.generateId());
	
		if (attachmentFlag) {
			// SET EMAIL ATTACHMENT
			EmailAttachment attachment = new EmailAttachment();
			attachment.setAttachementBytes(emailTxt);
			attachment.setMimeType(mimeType);
			attachment.setFileName(emailFileName);
			request.addEmailAttachment(attachment);
			log.debug("CASA NFC :: mobileOtpBody={}, envConfig.getMobileOtpEmailBody()={}", mobileOtpBody, envConfig.getMobileOtpEmailBody());
			if(mobileOtpBody && Objects.nonNull(envConfig.getMobileOtpEmailBody())) {
				request.setEmailBodyContent(new String(envConfig.getMobileOtpEmailBody()));
				log.debug("CASA NFC :: request.getEmailBodyContent()={}", request.getEmailBodyContent());
			} else if(nameOtpEmailBody && Objects.nonNull(envConfig.getNameOtpEmailBody())){
				request.setEmailBodyContent(new String(envConfig.getNameOtpEmailBody()));
			} else if(Objects.nonNull(envConfig.getOtpEmailBody())) {
				request.setEmailBodyContent(new String(envConfig.getOtpEmailBody()));
			}
			request.setEmailBodyContentType(TEXT);	
		} else {
			request.setEmailBodyContent(emailTxt);
			request.setEmailBodyContentType(mimeType);
		}
		
		mqNotifier.sendEmail(JsonUtils.convertToJson(request));
	}
	
	private void sendEmail(final String emailId, final String emailTxt, final String emailSubject, final String emailFileName, 
			final String mimeType, final boolean attachmentFlag, final boolean nameOtpEmailBody, final boolean mobileOtpBody, ContentID contentId) {
		if (StringUtils.isBlank(emailId)) {
			log.warn("Email processing SKIPPED as no emailid available in system. emailSubject:{}", emailSubject);
			return;
		}
			
		EmailRequest request = new EmailRequest();
		request.setFromAddress(settingsRepository.getEmailFromAddress());
		request.addToAddress(emailId);
		request.setEntityName(settingsRepository.getEntityName());
		request.setSourceSystem(settingsRepository.getEntityName());
		request.setEmailSubject(emailSubject);
		request.setRequestID(TextUtils.INSTANCE.generateId());
	
		if (attachmentFlag) {
			// SET EMAIL ATTACHMENT
			EmailAttachment attachment = new EmailAttachment();
			attachment.setAttachementBytes(emailTxt);
			attachment.setMimeType(mimeType);
			attachment.setFileName(emailFileName);
			request.addEmailAttachment(attachment);
			if(ContentID.CUSTOMER_ONBOARD_CASA_ISL_OTP.equals(contentId)) {
				if(mobileOtpBody && Objects.nonNull(envConfig.getMobileOtpEmailBody())) {
					request.setEmailBodyContent(new String(envConfig.getMobileOtpEmailBody()));
				}
				else if(nameOtpEmailBody && Objects.nonNull(envConfig.getNameOtpEmailBodyCasaIsl())){
					request.setEmailBodyContent(new String(envConfig.getNameOtpEmailBodyCasaIsl()));
				} else if(Objects.nonNull(envConfig.getOtpEmailBodyCasaIsl())) {
					request.setEmailBodyContent(new String(envConfig.getOtpEmailBodyCasaIsl()));
				}
			}
			else {
				if(mobileOtpBody && Objects.nonNull(envConfig.getMobileOtpEmailBody())) {
					request.setEmailBodyContent(new String(envConfig.getMobileOtpEmailBody()));
				}
				else if(nameOtpEmailBody && Objects.nonNull(envConfig.getNameOtpEmailBody())){
					request.setEmailBodyContent(new String(envConfig.getNameOtpEmailBody()));
				} else if(Objects.nonNull(envConfig.getOtpEmailBody())) {
					request.setEmailBodyContent(new String(envConfig.getOtpEmailBody()));
				}
			}
			request.setEmailBodyContentType(TEXT);	
		} else {
			request.setEmailBodyContent(emailTxt);
			request.setEmailBodyContentType(mimeType);
		}
		
		mqNotifier.sendEmail(JsonUtils.convertToJson(request));
	}

	private boolean sendEmailToAtYourService(final String toAddress,final String emailTxt, final String emailSubject, final String mimeType, List<TessAttachment> attachments) {
		
		boolean mailStatus = false;
		try {
			EmailRequest request = new EmailRequest();
			request.setFromAddress(settingsRepository.getEmailFromAddress());
			request.addToAddress(toAddress);
			request.setEntityName(settingsRepository.getEntityName());
			request.setSourceSystem(settingsRepository.getEntityName());
			request.setEmailSubject(emailSubject);
			request.setRequestID(TextUtils.INSTANCE.generateId());

			request.setEmailBodyContent(emailTxt);
			request.setEmailBodyContentType(mimeType);

			if(Objects.nonNull(attachments) && !attachments.isEmpty()) {
				for(TessAttachment attach:attachments) {
					EmailAttachment attachment = new EmailAttachment();
					attachment.setAttachementBytes(attach.getFileContent());
					attachment.setMimeType(attach.getFileFormat());
					attachment.setFileName(attach.getFileName());
					request.addEmailAttachment(attachment);

				}
			}
			log.info(request.toString());
			mqNotifier.sendEmail(JsonUtils.convertToJson(request));
			mailStatus = true;
		}catch(Exception ex) {
			log.info("Error while creating email request to : {}",toAddress);
		}
		log.info("Email status send to {} : {}",toAddress,mailStatus);

		return mailStatus;
	}

	private String resolveLanguage(String language, SessionInfo sessionInfo) {
		if(Objects.nonNull(sessionInfo)) {
			Locale locale = sessionInfo.getLocale();
			language = locale.getLanguage();
			if (Objects.isNull(language)) {
				User user = sessionInfo.getUser();
				if (Objects.nonNull(user))
					language = user.getPreferredLanguage();
			}
		} 
		
		language = StringUtils.isBlank(language) ? AppConstants.LOCALE_EN : StringUtils.left(language, 2);
		return language;
	}

	private ContentItem getContentItem(ContentID contentID, NotificationType notificationType, String language, String channelName) {
		ContentItem contentItem = contentItemRepository.fetchContentByPath(ContentGroup.MSGTEMPLATE.name(), contentID.name(), notificationType.name(), language, channelName);
	    if(!AppConstants.LOCALE_EN.equalsIgnoreCase(language) && Objects.isNull(contentItem)) {
	    	contentItem = contentItemRepository.fetchContentByPath(ContentGroup.MSGTEMPLATE.name(), contentID.name(), notificationType.name(), AppConstants.LOCALE_EN, channelName);
	    }

		return contentItem;
	}
	
	public void sendMutualFundEnquiry(final NotificationRequest notificationRequest) {
		if (Objects.isNull(notificationRequest))
			return;
		EmailRequest request = new EmailRequest();
		request.setFromAddress(settingsRepository.getEmailFromAddress());
		request.addToAddress(settingsRepository.getSetting(MUTUAL_FUND_ENQUIRY_EMAIL));
		request.setEntityName(settingsRepository.getEntityName());
		request.setSourceSystem(settingsRepository.getEntityName());
		request.setEmailSubject(notificationRequest.getSubject());
		request.setRequestID(TextUtils.INSTANCE.generateId());
		
		StringBuilder messageBuilder = new StringBuilder();
		messageBuilder.append(notificationRequest.getMessageText());
		if(SessionContext.getSession() != null && SessionContext.getSession().getUser() != null) {
			messageBuilder.append("\n\n From:");
			messageBuilder.append(SessionContext.getSession().getUser().getName());
			messageBuilder.append("\n User ID:");
			messageBuilder.append(SessionContext.getSession().getUser().getCin());
		}
		request.setEmailBodyContent(messageBuilder.toString());
		
		mqNotifier.sendEmail(JsonUtils.convertToJson(request));
	}

	@Asynchronous
	public Future<Boolean>  processNotificationTess(ContentID contentID, SessionInfo sessionInfo, TessAttachment attachement,
			String fileName, StringBuffer body) {
		
		try {
			User user = sessionInfo.getUser();
			if (Objects.isNull(attachement) || Objects.isNull(contentID)) {
				log.warn("##### Notification did not send as content is null.");
				return new javax.ejb.AsyncResult<Boolean>(false);
			}
			
			ChannelType channelType = sessionInfo.getChannelType();
			if (channelType == ChannelType.TAB) {
				channelType = ChannelType.MOBILE;
			}
			if (channelType == null) {
				log.warn("ChannelType in SessionContext is:{}", channelType);
				channelType = ChannelType.BROWSER;
			}
			final String channelName = channelType.name().toUpperCase();
			log.debug("Preparing notification for language:{}, channel:{}, contentID:{}", "en", channelName, contentID);
			
			this.notifyByEmail(contentID, user, channelName, attachement, fileName, body);
			
		} catch (Exception e) {
			log.error("Exception while processing notification for {}. Cause:{}", contentID, e);
		}
		return new javax.ejb.AsyncResult<Boolean>(true);
	}

	private void notifyByEmail(ContentID contentID, User user, String channelName, TessAttachment attachement, String fileName, StringBuffer body) {
		
		ContentItem contentItem = this.getContentItem(contentID, NotificationType.EMAIL, "en", channelName);
		if (Objects.nonNull(contentItem)) {
			String subParam = user.getCin()+" "+fileName;
			final String emailSubject = TextUtils.INSTANCE.createTextFromTemplate(contentItem.getMetadata(), subParam);
			//final String zipFileContent = FABUtils.INSTANCE.generateZip(attachement.getFileName(), attachement.getFileContent());
			
			body.append("\n"+ contentItem.getContentText());
			log.info("notifyByEmailTess: CIF:{}, Generated Email Text:{}", user.getCif(), body.toString());
			this.sendEmail( attachement.getFileContent(), body.toString(), emailSubject, fileName, attachement.getFileFormat(), true);
			}
	}

	private void sendEmail(String zipFileContent, String emailBodyContent, String emailSubject, String emailFileName, String mimeType,
			boolean attachmentFlag) {
		
		EmailRequest request = new EmailRequest();
		request.setFromAddress(settingsRepository.getEmailFromAddress());
		request.addToAddress(settingsRepository.getEmailToAddressForTess());
		List<String> ccList = settingsRepository.getEmailCcAddressForTess();
		if(Objects.nonNull(ccList) && ccList.size()> 0)
			request.setCcAddress(ccList);
		//request.setBccAddress("");
		request.setEntityName(settingsRepository.getEntityName());
		request.setSourceSystem(settingsRepository.getEntityName());
		request.setEmailSubject(emailSubject);
		request.setRequestID(TextUtils.INSTANCE.generateId());
	
		if (attachmentFlag) {
			// SET EMAIL ATTACHMENT
			EmailAttachment attachment = new EmailAttachment();
			attachment.setAttachementBytes(zipFileContent);
			attachment.setMimeType(mimeType);
			attachment.setFileName(emailFileName);
			request.addEmailAttachment(attachment);
			
			request.setEmailBodyContent(emailBodyContent);
			request.setEmailBodyContentType(TEXT);	
		}
		
		mqNotifier.sendEmail(JsonUtils.convertToJson(request));
	}
	
	/*
	 * This Method is to send notification without getting User deatils from session.
	 */
	public void processNotification(ContentID contentID, User user,ChannelType channelType, Map<String, Object> parameters) {
		try {
			
			if (Objects.isNull(user) || Objects.isNull(contentID)) {
				log.warn("##### Notification did not send as User or contentID is null. Params:{}", parameters);
				return;
			}

			String language = user.getPreferredLanguage();

			if (channelType == null) {
				log.warn("ChannelType in SessionContext is:{}", channelType);
				channelType = ChannelType.MOBILE;
			}

			final String channelName = channelType.name().toUpperCase();
			log.debug("Preparing notification for language:{}, channel:{}, contentID:{} ", language, channelName, contentID);
			
			this.notifyByEmail(contentID, user, language, channelName, parameters);
			this.notifyBySms(contentID, user, language, channelName, parameters);
			//vccNotificationService.preparePushNotification(contentID, user, language, channelName, parameters);
			
		} catch (Exception e) {
			log.error("Exception while processing notification (processNotification) for:{}. Cause:{}", contentID, e);
		}
	}
	
	/**
	 * Notification using preferences
	 * 
	 * @param contentID
	 * @param sessionInfo
	 * @param notificationPref
	 * @param parameters
	 */
	public void processNotification(ContentID contentID, SessionInfo sessionInfo, NotificationType notificationPref, Map<String, Object> parameters) {
		try {
			
			User user = sessionInfo.getUser();
			if (Objects.isNull(user) || Objects.isNull(contentID)) {
				log.warn("##### Notification did not send as User or contentID is null. Params:{}", parameters);
				return;
			}

			String language = user.getPreferredLanguage();
			log.info("Language: "+language);
			language = this.resolveLanguage(language, sessionInfo);

			ChannelType channelType = sessionInfo.getChannelType();
			if (channelType == ChannelType.TAB) {
				channelType = ChannelType.MOBILE;
			}
			log.info("ChannelType: "+channelType);

			if (channelType == null) {
				log.warn("ChannelType in SessionContext is:{}", channelType);
				channelType = ChannelType.MOBILE;
			}

			final String channelName = channelType.name().toUpperCase();
			log.debug("Preparing notification for language:{}, channel:{}, contentID:{} ", language, channelName, contentID);
			
			if(Objects.nonNull(notificationPref)) {
				if(notificationPref.equals(NotificationType.SMS)) {
					this.notifyBySms(contentID, user, language, channelName, parameters);
				} else if(notificationPref.equals(NotificationType.EMAIL)) {
					this.notifyByEmail(contentID, user, language, channelName, parameters);
				} else if(notificationPref.equals(NotificationType.DIGITAL)) {
					this.notifyByDigitalNotifications(contentID, user, language, channelName, parameters);
				}
			}
			
		} catch (Exception e) {
			log.error("Exception while processing notification (processNotification) for:{}. Cause:{}", contentID, e);
		}
	}
	private boolean smsPreferenceValidation(String cif, String eventType){
		boolean validation = true;
		List<NotificationConfig> notificationConfigs = notificationCentreRepository.getNotificationDetailByDeliveryChannel("SMS");
		if(Objects.nonNull(notificationConfigs) && notificationConfigs.size()>0) {
			NotificationConfig eventConfig = notificationConfigs.stream().filter(config->config.getEventType().equals(eventType)).findFirst().orElse(null);
			if(Objects.nonNull(eventConfig) && StringUtils.isNotBlank(eventConfig.getCatagoryId())) {
				validation = "Y".equals(eventConfig.getIsEnabled())?true:false;
				if(validation) {
					validation = notificationCentreSF.getUserNotificationPreferenceByDeliveryChannel(eventConfig.getCatagoryId(), cif, "SMS");
				}else {
					log.info("SMS is disabled in Notification_config for eventType:{}",eventType);
				}
			}
		}
		return validation;
	}
	
	public void processNotificationForIpo(ContentID contentID, SessionInfo sessionInfo, String mobileNo,
			Map<String, Object> parameters) {
		log.info("inside send notification for IPO");
		try {
			User user = sessionInfo.getUser();
			if (Objects.isNull(user) || Objects.isNull(contentID)) {
				log.warn("##### Notification did not send as User or contentID is null. Params:{}", parameters);
				return;
			}

			String language = user.getPreferredLanguage();
			language = this.resolveLanguage(language, sessionInfo);

			ChannelType channelType = sessionInfo.getChannelType();
			if (channelType == ChannelType.TAB) {
				channelType = ChannelType.MOBILE;
			}
			if (channelType == null) {
				log.warn("ChannelType in SessionContext is:{}", channelType);
				channelType = ChannelType.BROWSER;
			}

			if (Objects.nonNull(parameters)) {
				parameters.put("sendDateTime",
						DateTimeHelper.INSTANCE.getCurrentDateForMessage(null, DATE_DDMMYYYYHHMM));

				if (!((staticDataRepository.fetchStaticData_EN(FAB_CONTACT_US, LOCAL_CONTACT_CENTER_PHONE_ISL)
						.getDescription()).equals(parameters.get("localContactCenterPhone")))) {
					parameters.put("localContactCenterPhone", staticDataRepository
							.fetchStaticData_EN(FAB_CONTACT_US, LOCAL_CONTACT_CENTER_PHONE).getDescription()); // "600525500"
				}
				if (!((staticDataRepository.fetchStaticData_EN(FAB_CONTACT_US, GLOBAL_CONTACT_CENTER_PHONE_ISL)
						.getDescription()).equals(parameters.get("globalContactCenterPhone")))) {
					parameters.put("globalContactCenterPhone", staticDataRepository
							.fetchStaticData_EN(FAB_CONTACT_US, GLOBAL_CONTACT_CENTER_PHONE).getDescription()); // "+97126811511"
				}
				parameters.put("contactCenterEmail",
						staticDataRepository.fetchStaticData_EN(FAB_CONTACT_US, CONTACT_CENTER_EMAIL).getDescription()); // "atyourservice@bankfab.com"
				parameters.put("channelName", channelType.equals(ChannelType.BROWSER) ? "Online" : "Mobile");

			}

			final String channelName = channelType.name().toUpperCase();
			log.debug("Preparing notification for language:{}, channel:{}, contentID:{} for CIF:{}", language,
					channelName, contentID, user.getCif());
			user.setMobileNo(mobileNo);
			this.notifyBySms(contentID, user, language, channelName, parameters);

		} catch (Exception e) {
			log.error("Exception while processing notification (processNotification) for:{}. Cause:{}", contentID, e);
		}
	}
	
	/**
	 * Push OTP event to analytics
	 * 
	 * @param contentID
	 * @param user
	 * @param otpEventComment
	 */
	private void pushOtpEventToAnalytics(ContentID contentID, User user, String otpEventComment) {
		log.info("In pushOtpEventToAnalytics");
		if (Objects.nonNull(user) && StringUtils.isNotBlank(user.getReferenceId())) {
			User userInfo = (User) cacheHelper.getFromUserDataCache(user.getReferenceId() + AppConstants.OTP_EVENT);
			OnboardAnalyticEventType eventType = null;
			DocumentScanJourneyFlow journey = null;
			if (Objects.nonNull(userInfo) && StringUtils.isNotBlank(userInfo.getInitiationType())) {
				log.info("notify resent userInfo:{}", user.getOtpState());
				otpEventComment = otpEventComment + "resent.";
				eventType = OnboardAnalyticEventType.OTP_RESENT;
				journey = DocumentScanJourneyFlow.valueOf(userInfo.getInitiationType());
			} else {
				if (StringUtils.isNotBlank(user.getInitiationType())) {
					log.info("notify sent userInfo:{}", user.getOtpState());
					otpEventComment = otpEventComment + "sent.";
					eventType = OnboardAnalyticEventType.OTP_SENT;
					journey = DocumentScanJourneyFlow.valueOf(user.getInitiationType());
					// Adding data to cache for verify otp stage
					if (otpEventComment.equalsIgnoreCase("sms otp sent.")) {
						cacheHelper.addToUserDataCache(user.getReferenceId() + AppConstants.OTP_EVENT, user);
					}
				}
			}
			HashMap<String, String> keyVals = new HashMap<>();
			keyVals.put(OnboardingAnalyticHelper.OTP_COMMENTS, otpEventComment);
			analyticHelper.publishOTPEvent(eventType, user.getReferenceId(), journey, keyVals);
		}
	}

	public void processSMSNotification(ContentID contentId, SessionInfo sessionInfo, Map<String, Object> msgArgs) {

		log.info("inside send notification for IPO");
		try {
			User user = sessionInfo.getUser();
			if (Objects.isNull(user) || Objects.isNull(contentId)) {
				log.warn("##### Notification did not send as User or contentID is null. Params:{}", msgArgs);
				return;
			}

			String language = user.getPreferredLanguage();
			language = this.resolveLanguage(language, sessionInfo);

			ChannelType channelType = sessionInfo.getChannelType();
			if (channelType == ChannelType.TAB) {
				channelType = ChannelType.MOBILE;
			}
			if (channelType == null) {
				log.warn("ChannelType in SessionContext is:{}", channelType);
				channelType = ChannelType.BROWSER;
			}

			final String channelName = channelType.name().toUpperCase();
			log.debug("Preparing notification for language:{}, channel:{}, contentID:{} for CIF:{}", language,
					channelName, contentId, user.getCif());
			this.notifyBySms(contentId, user, language, channelName, msgArgs);

		} catch (Exception e) {
			log.error("Exception while processing notification (processNotification) for:{}. Cause:{}", contentId, e);
		}

	}

	public void processNotificationTransferAdvice(ContentID contentID, SessionInfo sessionInfo, Map<String, Object> parameters,
												  final ExecuteTransferRequest transferRequest, ExecutePaymentResponse paymentResponse) {
		log.info("Invoked processNotificationTransferAdvice for fundTransferType = {} ",transferRequest.getFundTransferType());
		try {
			User user = sessionInfo.getUser();
			log.info("User: "+user);
			if (Objects.isNull(user) || Objects.isNull(contentID)) {
				log.warn("##### Notification did not send as User or contentID is null. Params:{}", parameters);
				return;
			}
			String language = user.getPreferredLanguage();
			log.info("Language: "+language);
			language = this.resolveLanguage(language, sessionInfo);
			ChannelType channelType = sessionInfo.getChannelType();
			log.info("ChannelType: "+channelType);
			if (channelType == ChannelType.TAB) {
				channelType = ChannelType.MOBILE;
			}
			if (channelType == null) {
				log.warn("ChannelType in SessionContext is:{}", channelType);
				channelType = ChannelType.BROWSER;
			}
			final String channelName = channelType.name().toUpperCase();
			log.info("Preparing notification for  channel:{}, contentID:{} for CIF:{}", channelName, contentID, user.getCif());
			if(user.getOtpState() == OTPState.EMAIL){
				this.notifyThroughEmailForTransferAdvice(transferRequest,paymentResponse,contentID,channelName,sessionInfo,parameters,language);
			} else if(user.getOtpState() == OTPState.SMS){
				this.notifyBySms(contentID, user, language, channelName, parameters);
			} else {
				this.notifyThroughEmailForTransferAdvice(transferRequest,paymentResponse,contentID,channelName,sessionInfo,parameters,language);
				this.notifyBySms(contentID, user, language, channelName, parameters);
				this.notifyByDigitalNotifications(contentID, user, language, channelName, parameters);
			}
		} catch (Exception e) {
			log.error("Exception while processing notification (processNotificationTransferAdvice) for:{}. Cause:{}", contentID, e);
		}
	}

	/**
	 * Method to build Email body, Email Subject, Smart Pdf password encryption
	 * @param contentItem ContentItem from content_item table
	 * @param user User
	 * @param parameters parameters
	 * @param pdfDocAttachment samet pdf
	 * @param encryptionKey smart pdf password
	 */
	private void notifyByEmailWithSmartPdf(ContentItem contentItem, User user, Map<String, Object> parameters,
										   PdfDocAttachment pdfDocAttachment, String encryptionKey) {
		final String emailBodyContent = TextUtils.INSTANCE.createTextFromTemplate(contentItem.getContentText(), parameters);
		final String emailSubject = TextUtils.INSTANCE.createTextFromTemplate(contentItem.getMetadata(), parameters);
		log.info("notifyByEmailWithSmartPdf: CIF:{}, Email subject:{} and Email Text:{}", user.getCif(), emailSubject, emailBodyContent);
		String base64Bin = Objects.nonNull(encryptionKey) ?
				pdfHelper.getPasswordProtectedPDF(pdfDocAttachment.getFileContent(), encryptionKey) : pdfDocAttachment.getFileContent();
		final String fileName = pdfDocAttachment.getFileName().concat(".").concat(pdfDocAttachment.getDocumentType().getDbShortCode().toLowerCase());
		this.sendEmailWithSmartPdf(user.getEmail(), base64Bin, emailSubject, fileName,
				pdfDocAttachment.getDocumentType().getContentType(), emailBodyContent,contentItem.getContentType());
	}

	private String buildEncryptionKey(User user) {
		String encryptionKey = null;
		if (Objects.nonNull(user.getDateOfBirth()) && Objects.nonNull(user.getMobileNo())) {
			log.info("User DOB is present");
			String dateOfBirth = user.getDateOfBirth().substring(0,2)+user.getDateOfBirth().substring(3,5);
			encryptionKey = StringUtils.right(user.getMobileNo(), 4) + dateOfBirth;
		}
		return encryptionKey;
	}

	/**
	 * Method to send emailRequest with smartPdf to Email MQ Queue
	 * @param emailId emailId
	 * @param base64Bin smartPdf
	 * @param emailSubject emailSubject
	 * @param emailFileName attachmentFileName
	 * @param mimeType PDF
	 * @param emailBody emailBody
	 */
	private void sendEmailWithSmartPdf(final String emailId, final String base64Bin, final String emailSubject, final String emailFileName,
									   final String mimeType, final String emailBody, final String emailCntMimeType) {
		if (StringUtils.isBlank(emailId)) {
			log.warn("Email processing SKIPPED as no emailid available in system. emailSubject:{}", emailSubject);
			return;
		}
		EmailRequest request = buildSmartPdfEmailReq(emailId,base64Bin,emailSubject,emailFileName,mimeType,emailBody,emailCntMimeType);
		log.info("Sending email request to mq queue notifier to process further");
		mqNotifier.sendEmail(JsonUtils.convertToJson(request));
	}

	/**
	 * Method to Build Email Attachment
	 * @param base64Bin PDF Content
	 * @param mimeType PDF
	 * @param emailFileName Name of PDF file
	 * @return EmailAttachment
	 */
	private EmailAttachment buildEmailAttachment(final String base64Bin,final String mimeType,final String emailFileName) {
		EmailAttachment attachment = new EmailAttachment();
		attachment.setAttachementBytes(base64Bin);
		attachment.setMimeType(mimeType);
		attachment.setFileName(emailFileName);
		return attachment;
	}

	private void notifyThroughEmailForTransferAdvice(final ExecuteTransferRequest transferRequest, ExecutePaymentResponse paymentResponse,
													 ContentID contentID, String channelName, SessionInfo sessionInfo,
													 Map<String, Object> parameters, String language) {
		String encryptionKey = buildEncryptionKey(sessionInfo.getUser());
		if (Objects.nonNull(encryptionKey)) {
			PdfDocAttachment pdfDocAttachment = transferPdfHelper.generateDocument(transferRequest, paymentResponse, sessionInfo);
			if (Objects.nonNull(pdfDocAttachment) && Objects.nonNull(pdfDocAttachment.getFileContent())) {
				log.info("Notify by Email with Transfer Advice attachment");
				notifyByEmailTransferAdvice(contentID,channelName,sessionInfo,parameters,pdfDocAttachment,encryptionKey,language);
			} else {
				log.info("Notify by Email without Transfer Advice attachment");
				this.notifyByEmail(contentID, sessionInfo.getUser(), language, channelName, parameters);
			}
		} else {
			log.info("User DOB or Mobile No. not present, proceeding notifyByEmail without TransferAdvice attachment");
			this.notifyByEmail(contentID, sessionInfo.getUser(), language, channelName, parameters);
		}
	}

	/**
	 * Method to get the contentItem from table for WithinFab and WithinUAE with transfer advice message
	 * @param contentID ContentID
	 * @param channelName channelName
	 * @param sessionInfo SessionInfo
	 * @param parameters  parameters
	 * @param pdfDocAttachment smart pdf
	 * @param encryptionKey smart pdf password
	 */
	private void notifyByEmailTransferAdvice(ContentID contentID, String channelName,SessionInfo sessionInfo, Map<String, Object> parameters,
											 PdfDocAttachment pdfDocAttachment,String encryptionKey,String language) {
		ContentItem contentItem = getContent(contentID,channelName,language);
		if (Objects.nonNull(contentItem)) {
			this.notifyByEmailWithSmartPdf(contentItem, sessionInfo.getUser(), parameters, pdfDocAttachment,
					encryptionKey);
		} else {
			log.error("**WARNING** Content_Item is not configured for:{}, notification:{}, language:{}, channel:{}", contentID, NotificationType.EMAIL, AppConstants.LOCALE_EN, channelName);
		}
	}

	/**
	 * Method to get the content from content_item table for WithinFAB and WithinUAE(IPP and IPI)
	 * @param contentID ContentID
	 * @param channelName channelName
	 * @return ContentItem
	 */
	private ContentItem getContent(ContentID contentID, String channelName,String language) {
		ContentItem contentItem;
		if (contentID.name().equalsIgnoreCase(ContentID.WITHIN_UAE_FUNDS_TRANSFER_SUCCESS.name())) {
			contentItem = this.getContentItem(ContentID.WITHIN_UAE_FUNDS_TRANSFER_ATTACH_SUCCESS, NotificationType.EMAIL, language, channelName);
		} else {
			contentItem = this.getContentItem(ContentID.WITHIN_BANK_FUNDS_TRANSFER_ATTACH_SUCCESS, NotificationType.EMAIL, language, channelName);
		}
		return contentItem;
	}

	/**
	 * Build Smart Pdf Email Request
	 * @param emailId emailId
	 * @param base64Bin smart Pdf
	 * @param emailSubject emailSubject
	 * @param emailFileName attachment file name
	 * @param mimeType PDF
	 * @param emailBody emailBody
	 * @return EmailRequest
	 */
	private EmailRequest buildSmartPdfEmailReq(final String emailId, final String base64Bin, final String emailSubject,
											   final String emailFileName, final String mimeType, final String emailBody,
											   final String emailCntMimeType) {
		EmailRequest request = new EmailRequest();
		request.setFromAddress(settingsRepository.getEmailFromAddress());
		request.addToAddress(emailId);
		request.setEntityName(settingsRepository.getEntityName());
		request.setSourceSystem(settingsRepository.getEntityName());
		request.setEmailSubject(emailSubject);
		request.setRequestID(TextUtils.INSTANCE.generateId());
		request.addEmailAttachment(buildEmailAttachment(base64Bin,mimeType,emailFileName));
		request.setEmailBodyContentType(emailCntMimeType);
		request.setEmailBodyContent(emailBody);
		return request;
	}


private Boolean createAutopay;
	private Boolean createBeneficiary;
	private String sourceProductRef;
	private ProductTypes sourceProductType;
	private String sourceCurrency;
	private ProductTypes receiverProductType;
	private String receiverProductRef;
	private String receiverCurrency; 	// Will be used in case of only Ownaccount transfer. In other case beneficiary currency will be used for all existing beneficiary transfer.
	private String transferDescription;
	private Double amount;
	private String transferCurrency;
	private FundTransferTypes fundTransferType;	
	private String transferType;
	private String chargeOption;
	private String accountingUnitIdentifier;
	private Autopay autopay;
	private Beneficiary beneficiary;
	private String transferDate;
	private Double chargeToCustomer;
	private String nickName;
	private Double cashAdvanceFee;
	private Double taxAmount;
	private boolean isIPIRequest; // Enriched by Channel backend for Within uae transfer
	private String transferPurposeCode;
	private String isAddwithTransfer;// This will be used in PAYIT to bypass authentication in case on add and pay
	private String edirhamCardId;// This will be used in E11 to add E11 card id to pass IIB execute call
	private String edirhamTransitAccNumber; // This will be used in E11 to set as credit account number to pass IIB execute call
	private Double edirhamCharges;//  This will be used in E11 to add in amount while top up
	private Boolean isReceiverNameUpdated;
	private String mCPaymentType;
    private IPOApplyDetails ipoSubscribeDetails;

    private boolean isIPPRequest;
    private String cityOfBirth;
    private String dateOfBirth;

    private InsuranceDetails insuranceDetails;
    private Integer version = 1;


	public boolean isIPIRequest() {
		return isIPIRequest;
	}

	public void setIPIRequest(boolean isIPIRequest) {
		this.isIPIRequest = isIPIRequest;
	}

	public String getTransferDate() {
		return transferDate;
	}

	public void setTransferDate(String transferDate) {
		this.transferDate = transferDate;
	}

	public Boolean getCreateAutopay() {
		return createAutopay;
	}

	public void setCreateAutopay(Boolean createAutopay) {
		this.createAutopay = createAutopay;
	}

	public Boolean getCreateBeneficiary() {
		return createBeneficiary;
	}

	public void setCreateBeneficiary(Boolean createBeneficiary) {
		this.createBeneficiary = createBeneficiary;
	}

	public Beneficiary getBeneficiary() {
		return beneficiary;
	}

	public void setBeneficiary(Beneficiary beneficiary) {
		this.beneficiary = beneficiary;
	}

	public Autopay getAutopay() {
		return autopay;
	}

	public void setAutopay(Autopay autopay) {
		this.autopay = autopay;
	}

	public ProductTypes getSourceProductType() {
		return sourceProductType;
	}

	public void setSourceProductType(ProductTypes sourceProductType) {
		this.sourceProductType = sourceProductType;
	}

	public ProductTypes getReceiverProductType() {
		return receiverProductType;
	}

	public void setReceiverProductType(ProductTypes receiverProductType) {
		this.receiverProductType = receiverProductType;
	}

	public String getSourceProductRef() {
		return sourceProductRef;
	}

	public void setSourceProductRef(String sourceProductRef) {
		this.sourceProductRef = sourceProductRef;
	}

	public String getReceiverProductRef() {
		return receiverProductRef;
	}

	public void setReceiverProductRef(String receiverProductRef) {
		this.receiverProductRef = receiverProductRef;
	}

	public String getTransferDescription() {
		return transferDescription;
	}

	public void setTransferDescription(String transferDescription) {
		this.transferDescription = transferDescription;
	}

	public Double getAmount() {
		return amount;
	}

	public void setAmount(Double amount) {
		this.amount = amount;
	}

	public String getTransferCurrency() {
		return transferCurrency;
	}

	public void setTransferCurrency(String transferCurrency) {
		this.transferCurrency = transferCurrency;
	}


	public String getChargeOption() {
		return chargeOption;
	}

	public void setChargeOption(String chargeOption) {
		this.chargeOption = chargeOption;
	}

	public String getAccountingUnitIdentifier() {
		return accountingUnitIdentifier;
	}

	public String getTransferType() {
		return transferType;
	}

	public void setAccountingUnitIdentifier(String accountingUnitIdentifier) {
		this.accountingUnitIdentifier = accountingUnitIdentifier;
	}

	public FundTransferTypes getFundTransferType() {
		return fundTransferType;
	}

	public void setFundTransferType(FundTransferTypes fundTransferType) {
		this.fundTransferType = fundTransferType;
	}

	public void setTransferType(String transferType) {
		this.transferType = transferType;
	}

	/**
	 * @return the chargeToCustomer
	 */
	public Double getChargeToCustomer() {
		return chargeToCustomer;
	}

	/**
	 * @return the chargeToCustomer
	 */
	@JsonIgnore
	public String getChargeToCustomerAsString() {
		if(Objects.nonNull(chargeToCustomer)) {
			return String.valueOf(chargeToCustomer);
		}
		return String.valueOf(0.0);
	}

	/**
	 * @param chargeToCustomer the chargeToCustomer to set
	 */
	public void setChargeToCustomer(Double chargeToCustomer) {
		this.chargeToCustomer = chargeToCustomer;
	}

	/**
	 * @return the nickName
	 */
	public String getNickName() {
		return nickName;
	}

	/**
	 * @param nickName the nickName to set
	 */
	public void setNickName(String nickName) {
		this.nickName = nickName;
	}

	public String getSourceCurrency() {
		return sourceCurrency;
	}

	public void setSourceCurrency(String sourceCurrency) {
		this.sourceCurrency = sourceCurrency;
	}

	public String getReceiverCurrency() {
		return receiverCurrency;
	}

	public void setReceiverCurrency(String receiverCurrency) {
		this.receiverCurrency = receiverCurrency;
	}

	public Double getCashAdvanceFee() {
		return cashAdvanceFee;
	}

	public void setCashAdvanceFee(Double cashAdvanceFee) {
		this.cashAdvanceFee = cashAdvanceFee;
	}

	/**
	 * @return the taxAmount
	 */
	public Double getTaxAmount() {
		return taxAmount;
	}

	/**
	 * @param taxAmount the taxAmount to set
	 */
	public void setTaxAmount(Double taxAmount) {
		this.taxAmount = taxAmount;
	}

	public String getTransferPurposeCode() {
		return transferPurposeCode;
	}

	public void setTransferPurposeCode(String transferPurposeCode) {
		this.transferPurposeCode = transferPurposeCode;
	}

	public String getIsAddwithTransfer() {
		return isAddwithTransfer;
	}

	public void setIsAddwithTransfer(String isAddwithTransfer) {
		this.isAddwithTransfer = isAddwithTransfer;
	}

	public String getEdirhamCardId() {
		return edirhamCardId;
	}

	public void setEdirhamCardId(String edirhamCardId) {
		this.edirhamCardId = edirhamCardId;
	}

	public String getEdirhamTransitAccNumber() {
		return edirhamTransitAccNumber;
	}

	public void setEdirhamTransitAccNumber(String edirhamTransitAccNumber) {
		this.edirhamTransitAccNumber = edirhamTransitAccNumber;
	}

	public Double getEdirhamCharges() {
		return edirhamCharges;
	}

	public void setEdirhamCharges(Double edirhamCharges) {
		this.edirhamCharges = edirhamCharges;
	}

	public Boolean getIsReceiverNameUpdated() {
		return isReceiverNameUpdated;
	}

	public void setIsReceiverNameUpdated(Boolean isReceiverNameUpdated) {
		this.isReceiverNameUpdated = isReceiverNameUpdated;
	}

	public String getmCPaymentType() {
		return mCPaymentType;
	}

	public void setmCPaymentType(String mCPaymentType) {
		this.mCPaymentType = mCPaymentType;
	}
	
	public IPOApplyDetails getIpoSubscribeDetails() {
		return ipoSubscribeDetails;
	}

	public void setIpoSubscribeDetails(IPOApplyDetails ipoSubscribeDetails) {
		this.ipoSubscribeDetails = ipoSubscribeDetails;
	}


	public boolean isIPPRequest() {
		return isIPPRequest;
	}

	public void setIPPRequest(boolean isIPPRequest) {
		this.isIPPRequest = isIPPRequest;
	}

	public String getCityOfBirth() {
		return cityOfBirth;
	}

	public void setCityOfBirth(String cityOfBirth) {
		this.cityOfBirth = cityOfBirth;
	}

	public String getDateOfBirth() {
		return dateOfBirth;
	}

	public void setDateOfBirth(String dateOfBirth) {
		this.dateOfBirth = dateOfBirth;
	}
	
	public InsuranceDetails getInsuranceDetails() {
		return insuranceDetails;
	}

	public void setInsuranceDetails(InsuranceDetails insuranceDetails) {
		this.insuranceDetails = insuranceDetails;
	}

	public Integer getVersion() {
		return version;
	}

	public void setVersion(Integer version) {
		this.version = version;
	}

private void notifyPaymentSuccess(final ExecuteTransferRequest transferRequest, ExecutePaymentResponse paymentResponse, SessionInfo sessionInfo) {
		log.info("Invoked notifyPaymentSuccess for fundTransferType = {} ",transferRequest.getFundTransferType());
		ContentID contentTransfer = ContentID.getSuccessContentId(transferRequest.getFundTransferType().name(), BLANK, SUCCESS);
		final String bal = paymentResponse.getBalanceForFundingSource() == null ? ZERO : paymentResponse.getBalanceForFundingSource().getValueFmt();
		final Amount requestAmount = TextUtils.INSTANCE.formatAmount(transferRequest.getAmount(), transferRequest.getTransferCurrency());
		String sourceDetail = transferRequest.getSourceProductRef();
		final String creditAccountNo = Objects.nonNull(transferRequest.getBeneficiary())
				? StringUtils.isNotBlank(transferRequest.getBeneficiary().getAcctOrCardNo()) ? transferRequest.getBeneficiary().getAcctOrCardNo() : transferRequest.getReceiverProductRef()
				: transferRequest.getReceiverProductRef();
		if(transferRequest.getSourceProductType() == ProductTypes.CARD) {
			sourceDetail = TextUtils.INSTANCE.getCardNumber(sourceDetail);
		}
				
		Map<String, Object> messageArgs = new HashMap<String, Object>();
		boolean isTransferAdviceSend = false;
	
		messageArgs.put("txnDesc", transferRequest.getFundTransferType().getTransferDesc());
		
		switch(transferRequest.getFundTransferType()) {
			case BANK_TO_BANK_FUNDS_TRANSFER:
				messageArgs.put("transferCurrency", transferRequest.getTransferCurrency());
				messageArgs.put("txnAmountFmt", requestAmount.getValueFmt());
				messageArgs.put("sourceAcc", TextUtils.INSTANCE.acctOrCardLast4Digits(sourceDetail));
				messageArgs.put("destAcc", TextUtils.INSTANCE.acctOrCardLast4Digits(creditAccountNo));
				messageArgs.put("txnDateTime", DateTimeHelper.INSTANCE.getCurrentDateForMessage(null));
				messageArgs.put("txnRef", paymentResponse.getTransactionRefNo());
				messageArgs.put("beneBankName", transferRequest.getBeneficiary().getBankName());
				messageArgs.put("nickName", transferRequest.getBeneficiary().getNickName());
				//messageArgs = new String [] {transferRequest.getTransferCurrency(), requestAmount.getValueFmt(), transferRequest.getBeneficiary().getBankName() ,
				//		transferRequest.getBeneficiary().getAcctOrCardNo(),	DateTimeHelper.INSTANCE.getCurrentDateForMessage(null)};
				break;
			case CARD_PAYMENT_BY_ACCOUNT: 
				String card = TextUtils.INSTANCE.maskNumber(StringUtils.isNotBlank(transferRequest.getReceiverProductRef()) ? transferRequest.getReceiverProductRef() : transferRequest.getBeneficiary().getAcctOrCardNo(),MASK_CHARCTER , 4, 12);
				messageArgs.put("transferCurrency", transferRequest.getTransferCurrency());
				messageArgs.put("txnAmountFmt", requestAmount.getValueFmt());
				messageArgs.put("sourceAcc", TextUtils.INSTANCE.acctOrCardLast4Digits(sourceDetail));
				messageArgs.put("destAcc", card); // <5213XXXXXXXX1234>
				messageArgs.put("txnDateTime", DateTimeHelper.INSTANCE.getCurrentDateForMessage(null)); //<DD:MM:YY>
				messageArgs.put("txnRef", paymentResponse.getTransactionRefNo());
				messageArgs.put("sourceCCY", transferRequest.getSourceCurrency());
				messageArgs.put("availableBalance", bal);
				
				//	messageArgs = new String [] {transferRequest.getTransferCurrency(),requestAmount.getValueFmt(), card, DateTimeHelper.INSTANCE.getCurrentDateForMessage(null),transferRequest.getSourceCurrency(), bal};
				break;
			case SMS_CASH:
				Date date = new Date();
				messageArgs.put("transferCurrency", transferRequest.getTransferCurrency());
				messageArgs.put("txnAmountFmt", requestAmount.getValueFmt());
				messageArgs.put("sourceAcc", TextUtils.INSTANCE.acctOrCardLast4Digits(sourceDetail));
				messageArgs.put("destAcc", creditAccountNo); // <9715XXXXXXXX> //TextUtils.INSTANCE.maskNumber(creditAccountNo, MASK_CHARCTER, 4, creditAccountNo.length())
				messageArgs.put("txnDate", DateTimeHelper.INSTANCE.formatDate(date, DATE_DDMMYYYY));
				messageArgs.put("txnTime", DateTimeHelper.INSTANCE.formatDate(date, TIME_HHMMSSSSS));
				messageArgs.put("txnDateTime", DateTimeHelper.INSTANCE.getCurrentDateForMessage(null));
				messageArgs.put("txnRef", paymentResponse.getTransactionRefNo());
				messageArgs.put("availableBalance", bal);
				break;
			case PAYIT_WALLET_TOPUP:
					messageArgs.put("nickName", transferRequest.getBeneficiary().getNickName());
					messageArgs.put("transferCurrency", transferRequest.getTransferCurrency());
					messageArgs.put("txnAmountFmt", requestAmount.getValueFmt());
					messageArgs.put("sourceAcc", TextUtils.INSTANCE.acctOrCardLast4Digits(sourceDetail));
					messageArgs.put("destAcc", TextUtils.INSTANCE.acctOrCardLast4Digits(transferRequest.getBeneficiary().getRemitInfo()));
					messageArgs.put("txnDateTime", DateTimeHelper.INSTANCE.getCurrentDateForMessage(null));
					messageArgs.put("txnRef", paymentResponse.getTransactionRefNo());
				break;
			case IPO_SUBSCRIPTION:
				messageArgs.put("refNo", paymentResponse.getApplicationNumber());
				messageArgs.put("amount", requestAmount.getValueFmt());
				messageArgs.put("txnDesc",transferRequest.getIpoSubscribeDetails().getIpoDetails().getCompanyName()) ;
				break;
			case INSURANCE_PAYMENT:
				if(Objects.nonNull(transferRequest.getSourceProductType()) && (transferRequest.getSourceProductType().compareTo(ProductTypes.ACCOUNT) == 0))
				{
					contentTransfer = ContentID.INSURANCE_PAYMENT_ACC_SUCCESS;
					messageArgs.put("insuranceType", transferRequest.getInsuranceDetails().getInsuranceType().getDescription());
					messageArgs.put("currency",paymentResponse.getBalanceForFundingSource().getCurrency()) ;
					messageArgs.put("amount", requestAmount.getValueFmt());
					messageArgs.put("accountEnding",TextUtils.INSTANCE.acctOrCardLast4Digits(sourceDetail)) ;
				}
				else
				{
					contentTransfer = ContentID.INSURANCE_PAYMENT_CC_SUCCESS;
					messageArgs.put("insuranceType", transferRequest.getInsuranceDetails().getInsuranceType().getDescription());
					messageArgs.put("currency",paymentResponse.getBalanceForFundingSource().getCurrency()) ;
					messageArgs.put("amount", requestAmount.getValueFmt());
					messageArgs.put("cardEnding",TextUtils.INSTANCE.acctOrCardLast4Digits(sourceDetail)) ;
				}
				break;
			case WITHIN_BANK_FUNDS_TRANSFER:
				buildParameterForContent(messageArgs,requestAmount,transferRequest);
				isTransferAdviceSend = true;
				break;
			case WITHIN_UAE_FUNDS_TRANSFER:
				if(transferRequest.getSourceProductType().compareTo(ProductTypes.ACCOUNT) == 0) {
					if (transferRequest.isIPPRequest() || transferRequest.isIPIRequest()) {
						buildParameterForContent(messageArgs, requestAmount, transferRequest);
						isTransferAdviceSend = true;
					} else {
						buildDefaultMessageArgs(messageArgs,requestAmount,sourceDetail,transferRequest,
								paymentResponse,creditAccountNo,bal);
					}
				} else {
					buildParameterForContent(messageArgs, requestAmount, transferRequest);
					isTransferAdviceSend = true;
				}
				break;
			default:
				messageArgs.put("transferCurrency", transferRequest.getTransferCurrency());
				messageArgs.put("txnAmountFmt", requestAmount.getValueFmt());
				messageArgs.put("sourceAcc", TextUtils.INSTANCE.acctOrCardLast4Digits(sourceDetail));
				messageArgs.put("destAcc", TextUtils.INSTANCE.acctOrCardLast4Digits(creditAccountNo));
				messageArgs.put("txnDateTime", DateTimeHelper.INSTANCE.getCurrentDateForMessage(null));
				messageArgs.put("txnRef", paymentResponse.getTransactionRefNo());
				messageArgs.put("sourceCCY", transferRequest.getSourceCurrency());
				messageArgs.put("availableBalance", bal);
				messageArgs.put("txnDesc",transferRequest.getFundTransferType().getTransferDesc()) ;
				if(Objects.nonNull(transferRequest.getBeneficiary())) {
					messageArgs.put("nickName", transferRequest.getBeneficiary().getNickName());
				}
			
			//messageArgs = new String [] { requestAmount.getValueFmt(), sourceDetail, DateTimeHelper.INSTANCE.getCurrentDateForMessage(null), bal,
				//	paymentResponse.getTransactionRefNo(), transferRequest.getSourceCurrency(), transferRequest.getTransferCurrency() };
			break;
		}
		if (isTransferAdviceSend) {
			notificationService.processNotificationTransferAdvice(contentTransfer,sessionInfo,messageArgs,transferRequest,paymentResponse);
		}
		else {
			notificationService.processNotification(contentTransfer, sessionInfo, messageArgs);
		}
	}

private void buildParameterForContent(Map<String, Object> messageArgs,
														 Amount requestAmount,ExecuteTransferRequest transferRequest) {
		messageArgs.put("txnAmountFmt", requestAmount.getValueFmt());
		messageArgs.put("transferCurrency", requestAmount.getCurrency());
		messageArgs.put("destAcc", TextUtils.INSTANCE.acctOrCardLast4Digits(transferRequest.getBeneficiary().getAcctOrCardNo()));
		messageArgs.put("sourceAcc", TextUtils.INSTANCE.acctOrCardLast4Digits(getSourceAccOrCard(transferRequest)));
		messageArgs.put("txnDateTime", DateTimeHelper.INSTANCE.getCurrentDateForMessage(null));
		messageArgs.put("localContactCenterPhone", staticDataRepository.fetchStaticData_EN(FAB_CONTACT_US, LOCAL_CONTACT_CENTER_PHONE).getDescription()); //"600525500"
		messageArgs.put("globalContactCenterPhone", staticDataRepository.fetchStaticData_EN(FAB_CONTACT_US, GLOBAL_CONTACT_CENTER_PHONE).getDescription()); //"+97126811511"
		messageArgs.put("contactCenterEmail",  staticDataRepository.fetchStaticData_EN(FAB_CONTACT_US, CONTACT_CENTER_EMAIL).getDescription()); //"atyourservice@bankfab.com"
		messageArgs.put("txnDesc", transferRequest.getFundTransferType().getTransferDesc());
	}




	public void processNotificationTransferAdvice(ContentID contentID, SessionInfo sessionInfo, Map<String, Object> parameters,
												  final ExecuteTransferRequest transferRequest, ExecutePaymentResponse paymentResponse) {
		log.info("Invoked processNotificationTransferAdvice for fundTransferType = {} ",transferRequest.getFundTransferType());
		try {
			User user = sessionInfo.getUser();
			log.info("User: "+user);
			if (Objects.isNull(user) || Objects.isNull(contentID)) {
				log.warn("##### Notification did not send as User or contentID is null. Params:{}", parameters);
				return;
			}
			String language = user.getPreferredLanguage();
			log.info("Language: "+language);
			language = this.resolveLanguage(language, sessionInfo);
			ChannelType channelType = sessionInfo.getChannelType();
			log.info("ChannelType: "+channelType);
			if (channelType == ChannelType.TAB) {
				channelType = ChannelType.MOBILE;
			}
			if (channelType == null) {
				log.warn("ChannelType in SessionContext is:{}", channelType);
				channelType = ChannelType.BROWSER;
			}
			final String channelName = channelType.name().toUpperCase();
			log.info("Preparing notification for  channel:{}, contentID:{} for CIF:{}", channelName, contentID, user.getCif());
			if(user.getOtpState() == OTPState.EMAIL){
				this.notifyThroughEmailForTransferAdvice(transferRequest,paymentResponse,contentID,channelName,sessionInfo,parameters,language);
			} else if(user.getOtpState() == OTPState.SMS){
				this.notifyBySms(contentID, user, language, channelName, parameters);
			} else {
				this.notifyThroughEmailForTransferAdvice(transferRequest,paymentResponse,contentID,channelName,sessionInfo,parameters,language);
				this.notifyBySms(contentID, user, language, channelName, parameters);
				this.notifyByDigitalNotifications(contentID, user, language, channelName, parameters);
			}
		} catch (Exception e) {
			log.error("Exception while processing notification (processNotificationTransferAdvice) for:{}. Cause:{}", contentID, e);
		}
	}

private void notifyThroughEmailForTransferAdvice(final ExecuteTransferRequest transferRequest, ExecutePaymentResponse paymentResponse,
													 ContentID contentID, String channelName, SessionInfo sessionInfo,
													 Map<String, Object> parameters, String language) {
		String encryptionKey = buildEncryptionKey(sessionInfo.getUser());
		if (Objects.nonNull(encryptionKey)) {
			PdfDocAttachment pdfDocAttachment = transferPdfHelper.generateDocument(transferRequest, paymentResponse, sessionInfo);
			if (Objects.nonNull(pdfDocAttachment) && Objects.nonNull(pdfDocAttachment.getFileContent())) {
				log.info("Notify by Email with Transfer Advice attachment");
				notifyByEmailTransferAdvice(contentID,channelName,sessionInfo,parameters,pdfDocAttachment,encryptionKey,language);
			} else {
				log.info("Notify by Email without Transfer Advice attachment");
				this.notifyByEmail(contentID, sessionInfo.getUser(), language, channelName, parameters);
			}
		} else {
			log.info("User DOB or Mobile No. not present, proceeding notifyByEmail without TransferAdvice attachment");
			this.notifyByEmail(contentID, sessionInfo.getUser(), language, channelName, parameters);
		}
	}

private String buildEncryptionKey(User user) {
		String encryptionKey = null;
		if (Objects.nonNull(user.getDateOfBirth()) && Objects.nonNull(user.getMobileNo())) {
			log.info("User DOB is present");
			String dateOfBirth = user.getDateOfBirth().substring(0,2)+user.getDateOfBirth().substring(3,5);
			encryptionKey = StringUtils.right(user.getMobileNo(), 4) + dateOfBirth;
		}
		return encryptionKey;
	}

/**
	 * Method to get the contentItem from table for WithinFab and WithinUAE with transfer advice message
	 * @param contentID ContentID
	 * @param channelName channelName
	 * @param sessionInfo SessionInfo
	 * @param parameters  parameters
	 * @param pdfDocAttachment smart pdf
	 * @param encryptionKey smart pdf password
	 */
	private void notifyByEmailTransferAdvice(ContentID contentID, String channelName,SessionInfo sessionInfo, Map<String, Object> parameters,
											 PdfDocAttachment pdfDocAttachment,String encryptionKey,String language) {
		ContentItem contentItem = getContent(contentID,channelName,language);
		if (Objects.nonNull(contentItem)) {
			this.notifyByEmailWithSmartPdf(contentItem, sessionInfo.getUser(), parameters, pdfDocAttachment,
					encryptionKey);
		} else {
			log.error("**WARNING** Content_Item is not configured for:{}, notification:{}, language:{}, channel:{}", contentID, NotificationType.EMAIL, AppConstants.LOCALE_EN, channelName);
		}
	}


/**
	 * Method to get the content from content_item table for WithinFAB and WithinUAE(IPP and IPI)
	 * @param contentID ContentID
	 * @param channelName channelName
	 * @return ContentItem
	 */
	private ContentItem getContent(ContentID contentID, String channelName,String language) {
		ContentItem contentItem;
		if (contentID.name().equalsIgnoreCase(ContentID.WITHIN_UAE_FUNDS_TRANSFER_SUCCESS.name())) {
			contentItem = this.getContentItem(ContentID.WITHIN_UAE_FUNDS_TRANSFER_ATTACH_SUCCESS, NotificationType.EMAIL, language, channelName);
		} else {
			contentItem = this.getContentItem(ContentID.WITHIN_BANK_FUNDS_TRANSFER_ATTACH_SUCCESS, NotificationType.EMAIL, language, channelName);
		}
		return contentItem;
	}

/**
	 * Build Smart Pdf Email Request
	 * @param emailId emailId
	 * @param base64Bin smart Pdf
	 * @param emailSubject emailSubject
	 * @param emailFileName attachment file name
	 * @param mimeType PDF
	 * @param emailBody emailBody
	 * @return EmailRequest
	 */
	private EmailRequest buildSmartPdfEmailReq(final String emailId, final String base64Bin, final String emailSubject,
											   final String emailFileName, final String mimeType, final String emailBody,
											   final String emailCntMimeType) {
		EmailRequest request = new EmailRequest();
		request.setFromAddress(settingsRepository.getEmailFromAddress());
		request.addToAddress(emailId);
		request.setEntityName(settingsRepository.getEntityName());
		request.setSourceSystem(settingsRepository.getEntityName());
		request.setEmailSubject(emailSubject);
		request.setRequestID(TextUtils.INSTANCE.generateId());
		request.addEmailAttachment(buildEmailAttachment(base64Bin,mimeType,emailFileName));
		request.setEmailBodyContentType(emailCntMimeType);
		request.setEmailBodyContent(emailBody);
		return request;
	}




public class TransferPdfHelper {

    private final Logger log = LoggerFactory.getLogger(getClass());

    @EJB
    private GenerateDocumentHelper generateDocumentHelper;

    public PdfDocAttachment generateDocument(final ExecuteTransferRequest transferRequest, ExecutePaymentResponse paymentResponse,
                                             SessionContext.SessionInfo sessionInfo) {
        log.info("TransferPdfHelper generateDocument method invoked");
        PdfDocAttachment response=null;
        final Amount requestAmount = TextUtils.INSTANCE.formatAmount(transferRequest.getAmount(), transferRequest.getTransferCurrency());
        DocumentRequest documentRequest = new DocumentRequest();
        documentRequest.setContentItemExchange(contentItemExchangeBuilder(transferRequest.getFundTransferType().name()));
        documentRequest.setDataFields(dataFieldMapper(transferRequest,paymentResponse,sessionInfo,requestAmount));
        if (transferRequest.getFundTransferType().name().equalsIgnoreCase(FundTransferTypes.WITHIN_BANK_FUNDS_TRANSFER.name())) {
            documentRequest.setFileName(WITHIN_FAB_TRANSFER_ADVICE_FILE_NAME);
        } else {
            documentRequest.setFileName(WITHIN_UAE_TRANSFER_ADVICE_FILE_NAME);
        }
        try {
            String result = generateDocumentHelper.generateDocument(documentRequest, sessionInfo.getEnvironment());
            if (Objects.nonNull(result)) {
                log.info("Document Service generateDocument api returned with response : {}",result);
                response = JsonUtils.convertToObject(PdfDocAttachment.class, result);
            }
        } catch (Exception e) {
            log.error("Document Service generateDocument failed with exception : {}",e);
        }
        return response;
    }

    private Map<String, String> dataFieldMapper(ExecuteTransferRequest transferRequest, ExecutePaymentResponse paymentResponse,
                                                SessionContext.SessionInfo sessionInfo, Amount requestAmount) {
        Map<String, String> fieldMap = new HashMap<>();
        User user = sessionInfo.getUser();
        String name = user.getName();
        String salutation = user.getSalutation();
        fieldMap.put(P1_1, requestAmount.getCurrency()+SPACE+requestAmount.getValueFmt());
        fieldMap.put(P1_2, getCharge(transferRequest));
        fieldMap.put(P1_3, transferRequest.getTransferDate());
        fieldMap.put(P1_4, paymentResponse.getTransactionRefNo());
        fieldMap.put(P1_5, getLimitedChar(transferRequest.getTransferDescription()));
        fieldMap.put(P1_6, getBankName(FAB));
        fieldMap.put(P1_7, getSourceAccOrCard(transferRequest));
        fieldMap.put(P1_8, getLimitedChar(salutation+SPACE+name));
        fieldMap.put(P1_9, getLimitedChar(getBankName(transferRequest.getBeneficiary().getBankName())));
        fieldMap.put(P1_10, getBeneficiaryAccOrCard(transferRequest.getReceiverProductType().name(),transferRequest.getBeneficiary().getAcctOrCardNo()));
        fieldMap.put(P1_11, getLimitedChar(transferRequest.getBeneficiary().getName()));
        return fieldMap;
    }

    private ContentItemExchange contentItemExchangeBuilder(String transferType) {
        ContentItemExchange contentItemExchange = new ContentItemExchange();
        ContentItemModel contentItem = new ContentItemModel();
        if (transferType.equalsIgnoreCase(FundTransferTypes.WITHIN_BANK_FUNDS_TRANSFER.name())) {
            contentItem.setContentIdStr(WITHIN_FAB_TRANSFER_ADVICE);
        } else {
            contentItem.setContentIdStr(WITHIN_UAE_TRANSFER_ADVICE);
        }
        contentItem.setContentGroup(ContentGroup.TNC.name());
        contentItem.setLanguage(Language.EN.name());
        contentItem.setContentType(DocumentContentTypes.PDF.name());
        contentItemExchange.setContentItems(Collections.singletonList(contentItem));
        return contentItemExchange;
    }

    private String getCharge(ExecuteTransferRequest transferRequest) {
        String charge = Objects.nonNull(transferRequest.getChargeToCustomer()) ?
                String.valueOf(transferRequest.getChargeToCustomer()) : DEFAULT_CHARGE_AMOUNT;
        final Amount requestAmount = TextUtils.INSTANCE.formatAmount(charge, LOCAL_CURRENCY);
        return requestAmount.getCurrency()+SPACE+requestAmount.getValueFmt();
    }

    private String getSourceAccOrCard(ExecuteTransferRequest transferRequest) {
        String fromAccOrCard;
        if (transferRequest.getSourceProductType().name().equalsIgnoreCase(ProductTypes.CARD.name())) {
            fromAccOrCard = TextUtils.INSTANCE.maskCardNumber(TextUtils.INSTANCE.getCardNumber(transferRequest.getSourceProductRef()), AppConstants.MASK_CHARCTER);
        } else {
            fromAccOrCard = transferRequest.getSourceProductRef();
        }
        return fromAccOrCard;
    }

    private String getBankName(String bankName) {
        return FAB.equalsIgnoreCase(bankName) ? BANK_NAME_FAB : bankName;
    }

    private String getBeneficiaryAccOrCard(String productTypeName, String cardOrAcctNo) {
        String fromAccOrCard;
        if (Objects.nonNull(productTypeName) && productTypeName.equalsIgnoreCase(ProductTypes.CARD.name())) {
            fromAccOrCard = TextUtils.INSTANCE.maskCardNumber(cardOrAcctNo, AppConstants.MASK_CHARCTER);
        } else {
            fromAccOrCard = cardOrAcctNo;
        }
        return fromAccOrCard;
    }

    /**
     * Method to fetch the first 24 char of the string
     * @param value String
     * @return String
     */
    private String getLimitedChar(String value) {
        return Objects.nonNull(value) ? StringUtils.left(value,24) : "";
    }
}
------------------------------
The extracted codebase contains several Java files. To implement the changes for the "forget password" feature, we will focus on the following:

Password Expiry Check:

Locate the part of the code where user login is handled. This is typically in files related to user authentication, such as LoginService, UserService, or AuthenticationController.
Implement logic to compare the "last password update date" with the current date plus 90 days. If it exceeds, set a flag to indicate that a password change is required.
Change Password Flow:

Look for the file handling the change password API, often named something like ChangePasswordService or PasswordController.
After the password is successfully updated, include code to update the "last password update date" to the current date.
Reset Password Flow:

Find the reset password API (possibly in a file like ResetPasswordService or PasswordController).
Ensure that the code updates the "last password update date" to the current date whenever a reset password action occurs.
I will now examine the contents of files that are likely to contain these functionalities to provide more specific instructions. Let's start by searching for keywords like "login," "password," or "reset" within the Java files to pinpoint the relevant code. 

Based on the search results, some key files in your codebase related to login, password change, and reset operations include:

Password Expiry Check and Login:

/src/main/java/com/fab/pb/services/login/facades/VerifyUserLoginSF.java
/src/main/java/com/fab/pb/services/login/facades/VerifyUserLoginV2SF.java
These files handle the user login process. Here, you need to:

Implement the logic to compare the "last password update date" with the current date + 90 days.
If the condition is met (90 days passed), set a flag to indicate that a password change is required and include this in the login response.
Change Password Flow:

/src/main/java/com/fab/pb/services/login/facades/UpdateCredentialSF.java
This file is likely responsible for updating user credentials (password). Here, you need to:

After successfully updating the password, also update the "last password update date" column with the current date.
Reset Password Flow:

/src/main/java/com/fab/pb/services/login/facades/ResetCredentialSF.java
This file handles the reset password logic. Here, you need to:

Once the password is reset, update the "last password update date" to the current date.
PGS Issue Handling (If applicable):

No specific file indicates direct handling of PGS in the search results. However, the changes for PGS could be related to the login check and the response you send back to the frontend.
Next Steps:
Modify the code in VerifyUserLoginSF.java or VerifyUserLoginV2SF.java to include the password expiry check logic.
Update UpdateCredentialSF.java to set the "last password update date" when the password is changed.
Modify ResetCredentialSF.java to update the "last password update date" when the password is reset.
If you'd like, I can open these files and look at specific lines for more detailed instructions. Let me know how you want to proceed! 






You said:
Yes please proceed and share the updated code
ChatGPT said:
ChatGPT
Here are the relevant code changes required to implement the password expiry check and update the "last password update date":

1. Password Expiry Check in VerifyUserLoginSF.java and VerifyUserLoginV2SF.java:
These files handle user login. We will add logic to check the "last password update date" and compare it with the current date + 90 days. If the password has expired, set a flag in the response.
Code Snippet for VerifyUserLoginSF.java (Modify Around Line 464):
java
Copy code
// Assuming 'userChannel' has the 'lastPasswordUpdateDate' field
LocalDate lastPasswordUpdateDate = userChannel.getLastPasswordUpdateDate();
LocalDate currentDate = LocalDate.now();
LocalDate expiryDate = lastPasswordUpdateDate.plusDays(90);

if (expiryDate.isBefore(currentDate)) {
    // Password expired, set a flag in the response
    verifyUserLoginResponse.setPasswordChangeRequired(true);
} else {
    // Password not expired
    verifyUserLoginResponse.setPasswordChangeRequired(false);
}
Add similar logic in VerifyUserLoginV2SF.java around the success response handling (near line 176).
2. Update "last password update date" in UpdateCredentialSF.java:
When the password is updated, modify the code to also update the "last password update date" field in the database.
Code Snippet for UpdateCredentialSF.java (Modify Around the Password Update Logic):
java
Copy code
// Assuming 'userChannel' is available and has a method to set 'lastPasswordUpdateDate'
userChannel.setLastPasswordUpdateDate(LocalDate.now());
// Save 'userChannel' to persist the updated date in the database
userChannelRepository.save(userChannel);
3. Reset Password Flow in ResetCredentialSF.java:
Similar to the change password flow, update the "last password update date" when the password is reset.
Code Snippet for ResetCredentialSF.java (Modify Around Line 71):
java
Copy code
// After resetting the password, update the last password update date
userChannel.setLastPasswordUpdateDate(LocalDate.now());
// Save 'userChannel' to persist the updated date in the database
userChannelRepository.save(userChannel);
These modifications will implement the required changes for the forget password feature. Make sure to test these changes thoroughly to ensure they work as expected in all relevant scenarios. 






You said:
Can you give me mermaid diagram for the solution?
ChatGPT said:
ChatGPT
Here's a Mermaid diagram representing the solution for the password expiry check and update flow:

mermaid
Copy code
sequenceDiagram
    participant User as User
    participant Frontend as Internet Banking (IB)
    participant Backend as Backend Server
    participant DB as Database

    User->>Frontend: Attempt to Login
    Frontend->>Backend: Send Login Request (Username, Password)
    Backend->>DB: Retrieve User's Last Password Update Date
    DB-->>Backend: Return Last Password Update Date
    Backend->>Backend: Calculate Expiry Date (Last Update + 90 days)
    
    alt Password Expired
        Backend->>Frontend: Set Flag: Password Change Required
        Frontend->>User: Redirect to Change Password Screen
        User->>Frontend: Enter New Password
        Frontend->>Backend: Send Change Password Request
        Backend->>DB: Update Password and Set Last Password Update Date = Current Date
        Backend->>Frontend: Password Change Successful
    else Password Not Expired
        Backend->>Frontend: Set Flag: Password Change Not Required
        Frontend->>User: Proceed to Home Screen
    end

    User->>Frontend: Initiate Forgot Password (Reset)
    Frontend->>Backend: Send Reset Password Request
    Backend->>DB: Reset Password and Set Last Password Update Date = Current Date
    Backend->>Frontend: Password Reset Successful
    Frontend->>User: Prompt to Login Again
Explanation:
The flow starts with the user attempting to log in.
The backend checks the "last password update date" from the database and calculates if the password has expired (90 days).
If expired, the backend sets a flag for the frontend to redirect the user to the change password screen.
After the user successfully changes or resets the password, the backend updates the "last password update date" in the database.


Component	Class	Existing/New	Method(s) Impacted/Added	Description of Impact	Class Responsibilities
Transfer Execution	FundTransferSF	Existing	executeTransfer	Modified to call notifyPaymentSuccess for WITHIN_UAE_FUNDS_TRANSFER and WITHIN_BANK_FUNDS_TRANSFER.	Handles the main logic for executing various types of fund transfers. Manages notifications for successful transfers.
Existing	notifyPaymentSuccess	Updated to handle PDF generation (via TransferPdfHelper), encryption (via PdfHelper), and call the new processNotificationWithAttachment in NotificationServiceSF.	Coordinates the creation and dispatch of success notifications for transfer processes.
PDF Generation	TransferPdfHelper	New	generateTransferAdvicePdf	New method for generating transfer advice PDFs specific to WITHIN_UAE and WITHIN_BANK transfers.	Responsible for generating PDFs related to fund transfer advice, leveraging the document service.
PDF Encryption	PdfHelper	Existing	encryptPdf	Utilized to encrypt the generated PDF file. No changes required in this class.	Handles the encryption of PDF documents, ensuring secure handling of sensitive information.
Notification	NotificationServiceSF	New	processNotificationWithAttachment	New method to send an email notification with an attachment (encrypted PDF) without involving SMS or digital notifications.	Manages the processing and dispatch of notifications (email, SMS) for various banking activities.
Document Service	DocumentService	Existing	invokePost	Indirectly used for transfer advice PDF generation within TransferPdfHelper. No changes required in the method itself.	Interacts with the document generation service to create various PDF documents required for bank operations.
Data Models	ExecuteTransferRequest, ExecutePaymentResponse, SessionInfo, User	Existing	N/A	No direct changes, but they provide necessary data for PDF generation and notification.	Represents data structures used in fund transfers, providing the necessary information to generate and send notifications.
Attachment Handling	TessAttachment	Existing	N/A	Used to create attachment objects for the encrypted PDF files. No changes required.	Represents file attachments to be sent in email notifications.
Notification Content	ContentID	Existing	N/A	Potential addition of new content IDs for transfer advice notifications.	Identifies content templates for email notifications, facilitating dynamic content generation.

Main Issue: When a customer adds a beneficiary with both a Swift code and a routing code, the middleware first checks for the routing code. If the routing code is present, it sends that to the T24 system. If the routing code is not found, it then checks for the Swift code.

The problem arises with transfers to Jordan because there were no rules set for Jordan in the table. As a result, both the Swift and routing codes were being sent to the middleware, leading to incorrect tags being generated.

You need to configure a specific table that makes the Swift code mandatory for Jordan and ignores the routing code.

CR description: Increase the number of log files in IBMB to ensure logs are not stopped when the threshold level of 1550 is reached.
<?xml version="1.0" encoding="UTF-8"?>
<Configuration>
	<Appenders>
		<Console name="Console" target="SYSTEM_OUT">
			<PatternLayout
				pattern="%d{DATE} %p (%t) (%X{channel}-%X{user}) [%c{1}:%L]: %m%n" />
		</Console>
		<!-- <File name="CoreInfoAppender" fileName="${sys:server.root}/logs/PersonalBanking/PB_Core_Info.log"> 
			<PatternLayout pattern="%d{DATE} %p (%t) (%X{channel}-%X{user}) [%c{1}:%L]: 
			%m%n" /> </File> -->

		<RollingFile name="CoreInfoAppender"
			fileName="${sys:server.root}/logs/PersonalBanking/PB_Core_Info.log"
			filePattern="${sys:server.root}/logs/PersonalBanking/PB_Core_Info.log.%i">
			<PatternLayout
				pattern="%d{DATE} %p (%t) (%X{channel}-%X{user}) [%c{1}:%L]: %m%n" />
			<Policies>
				<SizeBasedTriggeringPolicy size="22 MB" />
			</Policies>
			<DefaultRolloverStrategy max="1549" />
		</RollingFile>

		<RollingFile name="CoreErrAppender"
			fileName="${sys:server.root}/logs/PersonalBanking/PB_Core_Err.log"
			filePattern="${sys:server.root}/logs/PersonalBanking/PB_Core_Err.log.%i">
			<ThresholdFilter level="ERROR" onMatch="ACCEPT"
				onMismatch="DENY" />
			<PatternLayout
				pattern="%d{DATE} %p (%t) (%X{channel}-%X{user}) [%c{1}:%L]: %m%n" />
			<Policies>
				<SizeBasedTriggeringPolicy size="20 MB" />
			</Policies>
			<DefaultRolloverStrategy max="100" />
		</RollingFile>

		<RollingFile name="RepositoryInfoAppender"
			fileName="${sys:server.root}/logs/PersonalBanking/Repository/PB_SQL_Info.log"
			filePattern="${sys:server.root}/logs/PersonalBanking/Repository/PB_SQL_Info.log.%i">
			<ThresholdFilter level="INFO" onMatch="ACCEPT"
				onMismatch="DENY" />
			<PatternLayout
				pattern="%d{DATE} %p (%t) (%X{channel}-%X{user}) [%c{1}:%L]: %m%n" />
			<Policies>
				<SizeBasedTriggeringPolicy size="20 MB" />
			</Policies>
			<DefaultRolloverStrategy max="200" />
		</RollingFile>

		<RollingFile name="RepositoryErrAppender"
			fileName="${sys:server.root}/logs/PersonalBanking/Repository/PB_SQL_Err.log"
			filePattern="${sys:erver.root}/logs/PersonalBanking/Repository/PB_SQL_Err.log.%i">
			<ThresholdFilter level="ERROR" onMatch="ACCEPT"
				onMismatch="DENY" />
			<PatternLayout
				pattern="%d{DATE} %p (%t) (%X{channel}-%X{user}) [%c{1}:%L]: %m%n" />
			<Policies>
				<SizeBasedTriggeringPolicy size="50 MB" />
			</Policies>
			<DefaultRolloverStrategy max="10" />
		</RollingFile>
		

		<RollingFile name="NotificationInfoAppender"
			fileName="${sys:server.root}/logs/PersonalBanking/Notifications/PB_Notification.log"
			filePattern="${sys:server.root}/logs/PersonalBanking/Notifications/PB_Notification.log.%i">
			<ThresholdFilter level="INFO" onMatch="ACCEPT"
				onMismatch="DENY" />
			<PatternLayout
				pattern="%d{DATE} %p (%t) (%X{channel}-%X{user}) [%c{1}:%L]: %m%n" />
			<Policies>
				<SizeBasedTriggeringPolicy size="10 MB" />
			</Policies>
			<DefaultRolloverStrategy max="10" />
		</RollingFile>

		<RollingFile name="NotificationErrAppender"
			fileName="${sys:server.root}/logs/PersonalBanking/Notifications/PB_Notification_Err.log"
			filePattern="${sys:server.root}/logs/PersonalBanking/Notifications/PB_Notification_Err.log.%i">
			<ThresholdFilter level="ERROR" onMatch="ACCEPT"
				onMismatch="DENY" />
			<PatternLayout
				pattern="%d{DATE} %p (%t) (%X{channel}-%X{user}) [%c{1}:%L]: %m%n" />
			<Policies>
				<SizeBasedTriggeringPolicy size="200 MB" />
			</Policies>
			<DefaultRolloverStrategy max="10" />
		</RollingFile>

		<RollingFile name="MongoDbInfoAppender"
			fileName="${sys:server.root}/logs/PersonalBanking/Mongo/PB_Mongo_Info.log"
			filePattern="${sys:server.root}/logs/PersonalBanking/Mongo/PB_Mongo_Info.log.%i">
			<ThresholdFilter level="INFO" onMatch="ACCEPT"
				onMismatch="DENY" />
			<PatternLayout
				pattern="%d{DATE} %p (%t) (%X{channel}-%X{user}) [%c{1}:%L]: %m%n" />
			<Policies>
				<SizeBasedTriggeringPolicy size="20 MB" />
			</Policies>
			<DefaultRolloverStrategy max="100" />
		</RollingFile>

		<RollingFile name="MongoDbErrAppender"
			fileName="${sys:server.root}/logs/PersonalBanking/Mongo/PB_Mongo_Err.log"
			filePattern="${sys:server.root}/logs/PersonalBanking/Mongo/PB_Mongo_Err.log.%i">
			<ThresholdFilter level="ERROR" onMatch="ACCEPT"
				onMismatch="DENY" />
			<PatternLayout
				pattern="%d{DATE} %p (%t) (%X{channel}-%X{user}) [%c{1}:%L]: %m%n" />
			<Policies>
				<SizeBasedTriggeringPolicy size="50 MB" />
			</Policies>
			<DefaultRolloverStrategy max="10" />
		</RollingFile>

		<RollingFile name="EventsInfoAppender"
			fileName="${sys:server.root}/logs/PersonalBanking/MQ_Events/PB_MQ_Info.log"
			filePattern="${sys:server.root}/logs/PersonalBanking/MQ_Events/PB_MQ_Info.log.%i">
			<ThresholdFilter level="INFO" onMatch="ACCEPT"
				onMismatch="DENY" />
			<PatternLayout
				pattern="%d{DATE} %p (%t) (%X{channel}-%X{user}) [%c{1}:%L]: %m%n" />
			<Policies>
				<SizeBasedTriggeringPolicy size="20 MB" />
			</Policies>
			<DefaultRolloverStrategy max="100" />
		</RollingFile>

		<RollingFile name="EventsErrAppender"
			fileName="${sys:server.root}/logs/PersonalBanking/MQ_Events/PB_MQ_Err.log"
			filePattern="${sys:server.root}/logs/PersonalBanking/MQ_Events/PB_MQ_Err.log.%i">
			<ThresholdFilter level="ERROR" onMatch="ACCEPT"
				onMismatch="DENY" />
			<PatternLayout
				pattern="%d{DATE} %p (%t) (%X{channel}-%X{user}) [%c{1}:%L]: %m%n" />
			<Policies>
				<SizeBasedTriggeringPolicy size="10 MB" />
			</Policies>
			<DefaultRolloverStrategy max="50" />
		</RollingFile>

		<RollingFile name="KafkaInfoEventsAppender"
			fileName="${sys:server.root}/logs/PersonalBanking/Kafka_Events/PB_Kafka_Info.log"
			filePattern="${sys:server.root}/logs/PersonalBanking/Kafka_Events/PB_Kafka_Info.log.%i">
			<ThresholdFilter level="INFO" onMatch="ACCEPT"
				onMismatch="DENY" />
			<PatternLayout
				pattern="%d{DATE} %p (%t) (%X{channel}-%X{user}) [%c{1}:%L]: %m%n" />
			<Policies>
				<SizeBasedTriggeringPolicy size="20 MB" />
			</Policies>
			<DefaultRolloverStrategy max="100" />
		</RollingFile>

		<RollingFile name="KafkaErrEventsAppender"
			fileName="${sys:server.root}/logs/PersonalBanking/Kafka_Events/PB_Kafka_Err.log"
			filePattern="${sys:server.root}/logs/PersonalBanking/Kafka_Events/PB_Kafka_Err.log.%i">
			<ThresholdFilter level="ERROR" onMatch="ACCEPT"
				onMismatch="DENY" />
			<PatternLayout
				pattern="%d{DATE} %p (%t) (%X{channel}-%X{user}) [%c{1}:%L]: %m%n" />
			<Policies>
				<SizeBasedTriggeringPolicy size="10 MB" />
			</Policies>
			<DefaultRolloverStrategy max="50" />
		</RollingFile>

	</Appenders>

	<Loggers>
		<Logger name="org.mongodb.driver" additivity="false">
			<AppenderRef ref="MongoDbInfoAppender" />
			<AppenderRef ref="MongoDbErrAppender" />
		</Logger>

		<Logger name="com.fab.pb.services.notification.facades"
			additivity="false">
			<AppenderRef ref="NotificationInfoAppender" />
			<AppenderRef ref="NotificationErrAppender" />
		</Logger>

		<Logger name="com.fab.pb.repositories" additivity="false">
			<AppenderRef ref="RepositoryInfoAppender" />
			<AppenderRef ref="RepositoryErrAppender" />
		</Logger>

		<Logger name="com.fab.pb.jms.services" additivity="false">
			<AppenderRef ref="EventsInfoAppender" />
			<AppenderRef ref="EventsErrAppender" />
		</Logger>

		<Logger name="com.fab.pb.services.efms.facades" additivity="true">
			<AppenderRef ref="EventsInfoAppender" />
			<AppenderRef ref="EventsErrAppender" />
		</Logger>

		<Logger name="org.apache.kafka" additivity="false">
			<AppenderRef ref="KafkaInfoEventsAppender" />
			<AppenderRef ref="KafkaErrEventsAppender" />
		</Logger>
		<Root level="info">
			<AppenderRef ref="CoreInfoAppender" />
			<AppenderRef ref="CoreErrAppender" />
			<!-- <AppenderRef ref="Console" /> -->
		</Root>
	</Loggers>
</Configuration>

2200 we can keep as new file limit


public FundsTransferRequest prepareFundsTransferReq(final SIDetails siDetails, final Beneficiary beneficiary, final TemplateId transferType) {
    // Call the new method to override Swift or Routing Code based on the rules
    overrideSwiftOrRoutingCode(siDetails, beneficiary);

    // Existing logic for preparing the funds transfer request
    ...
}
/**
 * Overrides Swift or Routing Code based on country-specific routing rules.
 * 
 * @param siDetails The SI details containing beneficiary information.
 * @param beneficiary The beneficiary details.
 */
private void overrideSwiftOrRoutingCode(SIDetails siDetails, Beneficiary beneficiary) {
    // Fetch routing rules based on the country
    List<RoutingRule> routingRules = staticDataRepository.getRoutingRulesByCountry(beneficiary.getCountry().getShortCode());

    if (Objects.nonNull(routingRules) && !routingRules.isEmpty()) {
        for (RoutingRule routingRule : routingRules) {
            // Both Swift and Routing Code mandatory
            if (routingRule.getSwiftMandatory() && routingRule.getRoutingCodeMandatory()) {
                if (StringUtils.isNotBlank(beneficiary.getRoutingCode())) {
                    // Swift code should not flow if routing code is available
                    beneficiary.setSwiftCode(StringUtils.EMPTY);
                }
            } 
            // Only Swift Code is mandatory
            else if (routingRule.getSwiftMandatory() && StringUtils.isNotBlank(beneficiary.getSwiftCode())) {
                // Routing code should not flow if Swift code is available
                beneficiary.setRoutingCode(StringUtils.EMPTY);
            } 
            // Only Routing Code is mandatory
            else if (routingRule.getRoutingCodeMandatory() && StringUtils.isNotBlank(beneficiary.getRoutingCode())) {
                // Swift code should not flow if routing code is available
                beneficiary.setSwiftCode(StringUtils.EMPTY);
            }
        }
    }
}
Add this method to your SIUtility.java file.

---------------------------
private void overrideSwiftOrRtCode(final ExecuteTransferRequest transferRequest) {
		final List<RoutingRule> routingRules = staticDataRepository.getRoutingRulesByCountry(transferRequest.getBeneficiary().getCountry().getShortCode());
		if(Objects.nonNull(routingRules) && !routingRules.isEmpty()) {
			for (RoutingRule routingRule : routingRules) {
				// Both either-or check
				if(routingRule.getSwiftMandatory() && routingRule.getRoutingCodeMandatory()) {
					if(StringUtils.isNotBlank(transferRequest.getBeneficiary().getRoutingCode())) {
						// Swift code should not flow if routing code available
						transferRequest.getBeneficiary().setSwiftCode(StringUtils.EMPTY);
					} 
				} else if(routingRule.getSwiftMandatory() && StringUtils.isNotBlank(transferRequest.getBeneficiary().getSwiftCode())) {
					// Routing code should not flow if Swift code available
					transferRequest.getBeneficiary().setRoutingCode(StringUtils.EMPTY);
				} else if(routingRule.getRoutingCodeMandatory() && StringUtils.isNotBlank(transferRequest.getBeneficiary().getRoutingCode())) {
					// Swift code should not flow if routing code available
					transferRequest.getBeneficiary().setSwiftCode(StringUtils.EMPTY);
				} 
			}
		}
	}

else if(FundTransferTypes.INTERNATIONAL_FUNDS_TRANSFER.compareTo(transferRequest.getFundTransferType()) == 0) {
						// Server side dual validation to verify again
						//validateAndOverrideSwiftOrRtCode(transferRequest);
						overrideSwiftOrRtCode(transferRequest);
						// Apply override routing code rules
						if(StringUtils.isNotBlank(transferRequest.getBeneficiary().getRoutingCode())) {
							String routingCode = applyOverrideRoutingRule(transferRequest.getBeneficiary().getRoutingCode(), transferRequest.getBeneficiary().getBankName());
							transferRequest.getBeneficiary().setRoutingCode(routingCode);	
						}

						if(LOCAL_CURRENCY.equals(destinationCurrency)) {
							transferRequest.getBeneficiary().setCorrBankBicCode(settingsRepository.getSetting(NOSTRO_ACCOUNT+ UNDERSCORE + LOCAL_CURRENCY));
						} else {
							List<CorrespondentBankDetails> correnpondentBankDetailList = fundTransferRepo.getCorrenpondentBankDetails(transferRequest.getBeneficiary().getCountry().getShortCode(), destinationCurrency, transferRequest.getBeneficiary().getSwiftCode());
							if(Objects.isNull(correnpondentBankDetailList) || correnpondentBankDetailList.isEmpty()) {
								log.error("Correspondent bank details not mapped for country:{} , and currency:{} ",transferRequest.getBeneficiary().getCountry().getShortCode() , destinationCurrency);
								apiResponse.setError(ErrorCodes.INT_TRANSFER_BANK_NOT_MAPPED,transferRequest.getBeneficiary().getCountry().getShortCode() , destinationCurrency );
								return apiResponse;
							}
							if (correnpondentBankDetailList.size() > 1) {
								overrideCorresBankDetails(transferRequest, correnpondentBankDetailList);
							} else {
								transferRequest.getBeneficiary().setCorrBankBicCode(PREFIX_SWIFT + correnpondentBankDetailList.get(0).getBicCode());
							}	
						}

						//Modify paymentDescription to append purpose code
						//TICR-142: Purpose code changes
						if (FundTransferTypes.INTERNATIONAL_FUNDS_TRANSFER
								.compareTo(transferRequest.getFundTransferType()) == 0
								&& destinationCurrency.equalsIgnoreCase(AppConstants.CURRENCY_INR)) {
							String purposeCode = getPurposeCodeForSwiftInr(transferRequest);
							String txnPurposeCode = "/" + purposeCode + "/";
							transferRequest
							.setTransferDescription(txnPurposeCode + transferRequest.getTransferDescription());
						}

Change the code of lambda to use pb-core with less minimum efforts
PBcore -> Paramstore, ssl context, rest connector
Parameterstore -> service urls

Challege:
->When this was deployed there were no concept of roles.
->Naming convention of lambda -> Country-Santury-sit, if I change it to proper conv, so I need to recreate the lambda and associate with existing bucket, if I dont change it fetch param store will not work
-> S3 Bucket data should not be lost
-> When the resource is created without CDK:
Jab tum existing bucket ko use kar rahe ho (jo pehle se bana hua hai) aur uske sath event source mapping karne ki koshish karte ho, to CloudFormation ko bucket ki presence ka pata nahi hota. 
Is wajah se, wo kuch extra resources create karne ki koshish karta hai, jaise IAM roles, jo tumhare permission restrictions ki wajah se fail hota hai.

New parameters such as ENV is missing

Environment issues
SIT Lambda role has not created.
Issue yeh hai ke existing Lambda function ko update karte waqt CDK ke sath kuch issues aa rahe hain. Jab tum ek Lambda function ko existing S3 bucket ke sath associate karte ho, 
to ek specific masla yeh hota hai ke S3 bucket pe sirf ek hi event notification configure ho sakti hai. 
Matlab yeh ke tum ek time pe sirf ek hi event ko associate kar sakte ho, jaise ke staging environment ke liye tumhari Lambda chal rahi ho to doosri environment (SIT ya UAT) ke liye nahi chal sakti.


Existing Resources Handling: 
Manual Process: Sai yeh suggest kar raha hai ke kuch cases main tumhe manual intervention karna par sakta hai, jaise S3 bucket se event notifications ko manually remove karna ya nayi notifications dalna.

------------------------------------
Umer, jo tumhara issue hai, us mein Pune region ke liye international fund transfers mein ek problem aa rahi hai, specifically jab Jordan country ke liye transfers ho rahe hain. Problem ye hai ke middleware se T24 system tak jo data jaa raha hai, us mein galat tag lag raha hai. Expected tag hai 57B, lekin system mein 57A tag lag raha hai. Yeh issue tab aa raha hai jab beneficiary ke pass dono Swift code aur routing code diye jaa rahe hain.

Main Issue:
Jab customer beneficiary add karta hai dono Swift code aur routing code ke sath, middleware pehle routing code check karta hai, aur agar routing code hai, to wahi T24 system mein send kar deta hai. 
Agar routing code nahi milta, to Swift code check kiya jata hai.
Yeh problem Jordan transfers ke liye aa rahi hai, kyunki Jordan ke liye table mein rules set nahi the. Is wajah se dono Swift aur routing codes middleware mein jaa rahe the, jo galat tag ban raha tha.
Tumhe ek specific table mein configuration karni hogi jo Jordan ke liye sirf Swift code ko mandatory banaye aur routing code ko ignore kare.
Code mein kya search karna hai:
Tumhe code mein "transfer routing code rules" ya "routing logic" wali table ko check karna hai. Yeh table country-specific rules set karti hai ke kis country ke liye Swift ya routing code mandatory hai.
Middleware ya T24 system ke tag generation logic ko dekhna hoga, jo Swift aur routing code ke basis par tag 57B ya 57A assign karta hai.
Analysis mein kya share karna hai:
Root Cause: Explain karo ke problem tab aa rahi hai jab Jordan transfers ke liye dono Swift aur routing code diye ja rahe hain, lekin table mein rules nahi hain is country ke liye.
Table Configuration: Batana hoga ke tumne Jordan ke liye table mein rules update kar diye hain jahan sirf Swift code mandatory hoga aur routing code ignore hoga.
Next Steps: Tumhare team ke sath discuss karo ke SI transfers mein bhi wahi table refer ki jaaye jo non-SI transfers ke liye ho rahi hai, taki future mein yeh problem dubara na aaye.
Is tarah se tum apna analysis present kar sakte ho, aur code check karne ke liye yeh specific logic ko dhundhoge.







You said:
Can you explain what is meant by swift code and routing code?
ChatGPT said:
ChatGPT
Swift code aur routing code dono hi financial identifiers hain jo international aur domestic fund transfers mein use hote hain, lekin inka kaam thoda alag hota hai.

Swift Code:
Swift code ko "Society for Worldwide Interbank Financial Telecommunication" code bhi kehte hain. Yeh ek unique identifier hota hai jo banks ya financial institutions ko globally identify karne ke liye use hota hai. Jab tum international fund transfer karte ho, Swift code sender aur receiver bank ke beech communication ko simplify karta hai aur ensures karta hai ke paisa sahi bank ko transfer ho raha hai. Swift code mein general format 8 ya 11 characters ka hota hai:

First 4 letters: Bank ka code
Next 2 letters: Country code
Next 2 letters: Location code
Last 3 letters (optional): Branch code
Example: HSBCGB2L (HSBC Bank ka Swift code UK mein).

Routing Code:
Routing code ko Routing Transit Number (RTN) ya ABA number bhi kehte hain, aur yeh specific banks ke liye hota hai jo mostly domestic (local) transfers ke liye use hota hai, especially USA aur Canada mein. Routing code bank aur uske specific branch ko identify karta hai, aur ensure karta hai ke paisa sahi branch mein pohonche.

Routing code generally 9 digits ka hota hai.

Example: 021000021 (JPMorgan Chase Bank ka routing number USA mein).
Key Difference:
Swift code international transfers ke liye use hota hai.
Routing code domestic (within-country) transfers ke liye use hota hai, especially in countries like the USA.
Tumhare case mein, jab Swift aur routing code dono diya jaata hai, system ko confusion hoti hai kis code ko use kare. Is liye, tumhare code mein check ho raha hai ke kis country ke liye kaunsa code mandatory hai aur based on that, middleware ya T24 system sahi tag assign karta hai.










PB-CORE
LAYERS
ENV
Parameter store


Background:
Tumhara system AWS pe run ho raha hai jahan S3 bucket main koi file upload hoti hai, aur wo ek event trigger karta hai jo Lambda function ko activate karta hai. Tumhari request yeh hai ke jab bhi S3 main koi upload ho, Lambda automatically kaam kare.

Problem:

Key Issues:
Single Event Notification: Agar tumhari S3 bucket already kisi Lambda function ko trigger kar rahi hai (jaise STG ke liye), to tum ussi bucket ko doosri Lambda ke sath (jaise UAT ya SIT ke liye) associate nahi kar sakte. Tumhe error milayga ya phir pehli wali configuration overwrite ho jaye gi.


As a Backend Developer, tumhe kya samajhna chahiye:
CDK Limitations: Tumhe yeh samajhna hoga ke CDK ke through existing resources ke sath interact karna problematic ho sakta hai, especially agar wo manually create ki gayi ho ya agar tumhare paas resources ko modify karne ka permission na ho.

Manual Changes: Tumhare analysis ka ek part yeh hoga ke tum batao ke kin areas main manual configuration ki zaroorat par rahi hai, jaise S3 events ko delete karna ya Lambda functions ke parameters ko update karna.

Role Handling: Tumhe yeh bhi dekhna hoga ke agar CDK roles create kar raha hai internally aur permission nahi mil rahi, to iska kya impact hoga aur kaise manually isko bypass kar sakte ho.

Yes, there are a few approaches to handle existing resources, especially when using AWS CDK, and they can help you overcome the issues you're facing with event source mapping for existing S3 buckets and Lambda functions.

Suggested Solutions for Existing Resource Handling:
Use fromBucketName() or fromBucketArn() for S3 Buckets: When you're dealing with an existing S3 bucket that wasn't created within the CDK stack, you can use methods like fromBucketName() or fromBucketArn() in your CDK code. These methods allow you to reference the existing bucket without attempting to create it again. This way, CloudFormation will know that the bucket already exists and wont attempt to recreate or manage it, preventing the permission issues.

typescript
Copy code
const bucket = s3.Bucket.fromBucketName(this, 'ExistingBucket', 'your-bucket-name');
This approach works for other AWS resources as well (like Lambda, DynamoDB, etc.). You can use the corresponding methods to import existing resources into your CDK stack without causing conflicts.

Use Custom Resources for Event Source Mapping: Sometimes CDK tries to create roles or event mappings when you modify existing resources. One workaround is to use AWS Lambda-backed Custom Resources. These custom resources can manage the event source mapping outside of the CDK lifecycle, which means CDK doesnt need to handle the resource creation itself.

You can write a Lambda function that creates or updates the event source mapping for your existing S3 bucket and deploy it as a custom resource in the CDK stack. This way, you can decouple the event source management from the CDKs control.

Use Manual Steps for S3 Event Notifications: If adding event notifications for existing S3 buckets through CDK causes too many issues, another solution is to handle this manually or with separate automation scripts (outside CDK). You can:

Create a script that uses AWS CLI or SDK to add or modify the event notification.
Run this script after deploying your CDK stack. This is a manual step, but it bypasses the need for CDK to manage the existing bucket's event notifications.
Example AWS CLI command to add event notification:

bash
Copy code
aws s3api put-bucket-notification-configuration --bucket your-bucket-name --notification-configuration file://notification.json
Split CDK Stack for Existing and New Resources: You can also split your CDK stack into two:

One stack for managing new resources (like new Lambda functions or S3 buckets that you need to create).
Another stack or a manual process for handling updates to existing resources. This way, CDK won't try to recreate or interfere with existing resources and will only handle new ones.
By isolating the responsibilities of each stack, you reduce the risk of conflicts and unwanted changes to existing infrastructure.

IAM Permissions Review: Review the IAM permissions for the CDK role. Ensure that the CDK role has adequate permissions to modify existing resources, like event source mapping or IAM role creation. If the problem is purely related to IAM restrictions, adjusting the permissions may help resolve the issue.

Summary:
The best approach would depend on how much control you have over your AWS environment and whether manual intervention is acceptable:

For fully automated workflows: Use fromBucketName() to import existing resources and avoid recreating them.
For critical environments where changes must be done carefully, consider using custom resources or manual scripts for event source mapping.
For long-term maintainability, ensure IAM permissions are in place for CDK to manage existing resources properly.
Do any of these suggestions align with your environment or requirements?


data = json.dumps(message)
data = {
    "customerId": "your_customer_id_value"  # Replace with the actual customer ID
}

# Convert the dictionary to a JSON object
json_object = json.dumps(data, indent=4)


import software.amazon.awscdk.services.s3.Bucket;
import software.amazon.awscdk.services.s3.IBucket;
import software.amazon.awscdk.services.s3.notifications.LambdaDestination;
import software.amazon.awscdk.services.s3.notifications.NotificationKeyFilter;
import software.amazon.awscdk.services.s3.EventType; // Correct import for event type
import software.amazon.awscdk.services.ssm.CfnParameter;
import software.amazon.awscdk.services.ssm.CfnParameterProps;
import software.amazon.awscdk.services.lambda.Function;
import software.amazon.awscdk.services.lambda.LayerVersion;
import software.amazon.awscdk.services.lambda.ILayerVersion;
import software.amazon.awscdk.services.iam.IRole;
import software.amazon.awscdk.services.iam.Role;
import software.amazon.awscdk.services.kms.IKey;
import software.amazon.awscdk.services.kms.Key;
import software.constructs.Construct;
import java.util.List;
import java.util.Map;

CfnParameter envParameter = new CfnParameter(this, "env",
        CfnParameterProps.builder().defaultValue("local").build());
CfnParameter regionParameter = new CfnParameter(this, "region",
        CfnParameterProps.builder().defaultValue("me-central-1").build());
CfnParameter accountIdParameter = new CfnParameter(this, "account",
        CfnParameterProps.builder().defaultValue("517606038493").build());
CfnParameter kmsAccountIdParameter = new CfnParameter(this, "kms-account",
        CfnParameterProps.builder().defaultValue("644749578616").build());

CfnParameter vpcIdParameter = new CfnParameter(this, "vpcId",
        CfnParameterProps.builder().type("AWS::EC2::VPC::Id").build());
CfnParameter appSubnetIdsParameter = new CfnParameter(this, "appSubnetIds",
        CfnParameterProps.builder().type("List<AWS::EC2::Subnet::Id>").build());

CfnParameter xksKeyIdParameter = new CfnParameter(this, "xksKeyId",
        CfnParameterProps.builder().defaultValue("cc63e70e-6095-42fa-9fa0-a7c20a726de9").build());

CfnParameter s3BucketParameter = new CfnParameter(this, "s3Bucket",
        CfnParameterProps.builder().defaultValue("ibmb-gfri-reports").build());

CfnParameter s3bucketPathParameter = new CfnParameter(this, "bucketPath",
        CfnParameterProps.builder().defaultValue("negative-country-phase0/input/").build());

// Lambda Configuration parameters
CfnParameter memorySizeParameter = new CfnParameter(this, "memorySize",
        CfnParameterProps.builder().type("Number").defaultValue(128).build()); // Corrected to Number
CfnParameter lambdaTimeoutParameter = new CfnParameter(this, "timeout-seconds",
        CfnParameterProps.builder().type("Number").defaultValue(60).build()); // Corrected to Number
CfnParameter deploymentBucketParameter = new CfnParameter(this, "deployment-bucket",
        CfnParameterProps.builder().defaultValue("ibmb-ms-deployment-dev-uae").build());
CfnParameter deploymentFileParameter = new CfnParameter(this, "deployment-file-name",
        CfnParameterProps.builder().defaultValue("lambda/deployment/sanction-country-report_v1.zip").build());
CfnParameter layerVersionParameter = new CfnParameter(this, "python-layer-version",
        CfnParameterProps.builder().defaultValue(20).build()); // Corrected to Number

// Updated to use EventType.OBJECT_CREATED
ibucket.addEventNotification(EventType.OBJECT_CREATED, new LambdaDestination(sanctionCountryReportFunction),
        NotificationKeyFilter.builder()
                .prefix(s3BucketPath)
                .suffix(".csv")
                .build());

=-----------
CfnParameter envParameter = new CfnParameter(this, "env",
                CfnParameterProps.builder().defaultValue("local").build());
        CfnParameter regionParameter = new CfnParameter(this, "region",
                CfnParameterProps.builder().defaultValue("me-central-1").build());
        CfnParameter accountIdParameter = new CfnParameter(this, "account",
                CfnParameterProps.builder().defaultValue("517606038493").build());
        CfnParameter kmsAccountIdParameter = new CfnParameter(this, "kms-account",
                CfnParameterProps.builder().defaultValue("644749578616").build());

        CfnParameter vpcIdParameter = new CfnParameter(this, "vpcId",
                CfnParameterProps.builder().type("AWS::EC2::VPC::Id").build());
        CfnParameter appSubnetIdsParameter = new CfnParameter(this, "appSubnetIds",
                CfnParameterProps.builder().type("List<AWS::EC2::Subnet::Id>").build());

        CfnParameter xksKeyIdParameter = new CfnParameter(this, "xksKeyId",
                CfnParameterProps.builder().defaultValue("cc63e70e-6095-42fa-9fa0-a7c20a726de9").build());

        CfnParameter s3BucketParameter = new CfnParameter(this, "s3Bucket",
                CfnParameterProps.builder().defaultValue("ibmb-gfri-reports").build());

        CfnParameter s3bucketPathParameter = new CfnParameter(this, "bucketPath",
                CfnParameterProps.builder().defaultValue("negative-country-phase0/input/").build());

        // Lambda Configuration parameters
        CfnParameter memorySizeParameter = new CfnParameter(this, "memorySize",
                CfnParameterProps.builder().type("Number").defaultValue("128").build());
        CfnParameter lambdaTimeoutParameter = new CfnParameter(this, "timeout-seconds",
                CfnParameterProps.builder().type("Number").defaultValue("60").build());
        CfnParameter deploymentBucketParameter = new CfnParameter(this, "deployment-bucket",
                CfnParameterProps.builder().defaultValue("ibmb-ms-deployment-dev-uae").build());
        CfnParameter deploymentFileParameter = new CfnParameter(this, "deployment-file-name", CfnParameterProps
                .builder().defaultValue("lambda/deployment/sanction-country-report_v1.zip").build());
        CfnParameter layerVersionParameter = new CfnParameter(this, "python-layer-version",
                CfnParameterProps.builder().defaultValue("20").build());

        // Environment variables for Lambda function
        CfnParameter certificatePasswordParameter = new CfnParameter(this, "certificate-password",
                CfnParameterProps.builder().defaultValue("xxxxx").build());
        CfnParameter toAddressParameter = new CfnParameter(this, "to-address",
                CfnParameterProps.builder().defaultValue("vishal.jagtap@bankfab.com").build());
        CfnParameter fetchCinCifByRefIdServiceUrlParameter = new CfnParameter(this, "fetch-cin-cif-service-url", CfnParameterProps.builder()
                .defaultValue("https://api-sit.digital-ibmb-dev.aeapps.bankfab.com/pbdb/v1/customer/cust-id-info").build());
        CfnParameter sendEmailServiceUrlParameter = new CfnParameter(this, "send-email-service-url", CfnParameterProps.builder()
                .defaultValue("https://kproxy-uat.pcdigital-dev.aeapps.bankfab.com/NotificationService/nsapi/email/sendemail").build());
        CfnParameter getCustDetailsServiceUrlParameter = new CfnParameter(this, "get_customer_details", CfnParameterProps.builder()
                .defaultValue("https://dpuat.bankfab.com:2038/customeronboarding/v2/customer-details").build());

        String env = envParameter.getValueAsString();
        String region = regionParameter.getValueAsString();
        String account = accountIdParameter.getValueAsString();
        String kmsAccount = kmsAccountIdParameter.getValueAsString();
        String s3Arn = "arn:aws:s3:::" + s3BucketParameter.getValueAsString();
        String s3BucketPath = s3bucketPathParameter.getValueAsString();

        String vpcId = vpcIdParameter.getValueAsString();
        List<String> subnetIds = appSubnetIdsParameter.getValueAsList();

        String xksKeyId = xksKeyIdParameter.getValueAsString();

        Number memorySize = memorySizeParameter.getValueAsNumber();
        Number lambdaTimeout = lambdaTimeoutParameter.getValueAsNumber();
        String deploymentBucketName = deploymentBucketParameter.getValueAsString();
        String deploymentFileKey = deploymentFileParameter.getValueAsString();
        String layerVersion = layerVersionParameter.getValueAsString();

        String certificatePassword = certificatePasswordParameter.getValueAsString();
        String toAddress = toAddressParameter.getValueAsString();
        String fetchCinCifByRefIdServiceUrl = fetchCinCifByRefIdServiceUrlParameter.getValueAsString();
        String sendEmailServiceUrl = sendEmailServiceUrlParameter.getValueAsString();
        String getCustomerDetailsUrl = getCustDetailsServiceUrlParameter.getValueAsString();

        Map<String, String> lambdaEnvVariableMap = getEnvVariableMap(env, certificatePassword,
                toAddress, fetchCinCifByRefIdServiceUrl, sendEmailServiceUrl, getCustomerDetailsUrl);

        IKey kmsKey = Key.fromKeyArn(this, "kmsKey", "arn:aws:kms:" + region + ":" + kmsAccount + ":key/" + xksKeyId);

        ILayerVersion lambdaLayerVersion = LayerVersion.fromLayerVersionArn(this, "lambda-py-layer",
                "arn:aws:lambda:" + region + ":" + account + ":layer:lambda-py-layer:" + layerVersion);

        IBucket ibucket = Bucket.fromBucketArn(this, "negative-country-report-bucket", s3Arn);

        IRole scReportRole = Role.fromRoleName(this, "scReportRoleId", "sc-report-role-iam-lambda-" + env);

        Function sanctionCountryReportFunction = sanctionCountryReportFunction(id, env, vpcId, subnetIds,
                memorySize, lambdaTimeout, deploymentBucketName, deploymentFileKey, lambdaLayerVersion, kmsKey,
                scReportRole, lambdaEnvVariableMap);

        // Grant Lambda function read access to the S3 bucket
        ibucket.grantRead(sanctionCountryReportFunction);

        // Add an event notification for when an object is created in the S3 bucket
        ibucket.addEventNotification(S3EventSource.OBJECT_CREATED, new LambdaDestination(sanctionCountryReportFunction),
                NotificationKeyFilter.builder()
                        .prefix(s3BucketPath)
                        .suffix(".csv")
                        .build());

public APIResponse prefThemeUpdate(ThemeUpdateRequest request) {
			APIResponse apiResponse = new APIResponse();
			return execute(request, apiResponse, req -> {
				if (StringUtils.isBlank(request.getAppTheme()) || !AVAILABLE_THEMES.contains(request.getAppTheme())) {
					request.setAppTheme(CLASSIC_APP_THEME);
				}
				channelInfoRepository.updateAppTheme(request.getAppTheme());
				String key = AppConstants.CUST_APP_THEME + SessionContext.getSession().getUser().getCin();
				CustomerAppThemeDetails customerAppTheme = (CustomerAppThemeDetails) cacheHelper
						.getFromUserDataCache(key);
				customerAppTheme.setDefaultTheme(request.getAppTheme());
				cacheHelper.addToUserDataCache(key, customerAppTheme);
				return apiResponse;
			});
		}


 
5 min do
 
Me call kerta hu
 

(^4[0-9][0-9]{14}$)|(^5[1-5][0-9]{14}$)

I wanted to follow up regarding the deployment of NPSS services in the staging environment, which has been pending for the last two releases. Could you kindly prioritize fixing and deploying these services at the earliest possible?

We are eager to proceed with testing and validation, and this step is crucial for the timely progress of our upcoming releases. Please let me know if any further details or assistance are required from our side to facilitate the process.

Looking forward to your update.

Solution Approach:
Introduce a Boolean Flag (isUpdate):

Add a boolean flag isUpdate to the getEtgRequest method signature.
This flag will indicate whether the request is for an update operation or a new transaction.
Conditional Context Addition:

Use the isUpdate flag to conditionally add the transaction context and user context to the ETGTransactionRequest. If isUpdate is true, these contexts will not be added.
Modify Calling Methods:

Update the methods (initiateTransaction, migrateCustomer, reInitiateTransaction, updateTransaction) to pass the appropriate value for the isUpdate flag when calling getEtgRequest.

public ETGTransactionRequest getEtgRequest(CsTransactionRequest csTransactionRequest, ContextTypeEnum contextType, boolean isUpdate) {
    ETGTransactionRequest etgRequest = new ETGTransactionRequest();

    if (Objects.isNull(csTransactionRequest) || StringUtils.isBlank(csTransactionRequest.getCsTransactionId())
            || Objects.isNull(csTransactionRequest.getCsTransactionType())) {
        log.debug("Invalid request for CS Transaction");
        throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
    }

    etgRequest.setTransactionId(csTransactionRequest.getCsTransactionId());
    etgRequest.setOldTransactionId(csTransactionRequest.getCsOldTransactionId());
    etgRequest.setTransactionType(csTransactionRequest.getCsTransactionType());
    etgRequest.setAuthenticator(csTransactionRequest.getAuthenticator());

    SessionInfo session = SessionContext.getSession();
    etgRequest.setSessionId(session.getSessionID());
    String refId = HashUtil.getPseudoCinHash(session.getUser().getCif());
    etgRequest.setUserName(refId);
    etgRequest.setLanguage(StringUtils.isBlank(localeHelper.resolveLanguage()) ? AppConstants.LOCALE_EN.toLowerCase()
            : localeHelper.resolveLanguage().toLowerCase());

    // Always add the authentication context
    etgRequest.addContext(getEtgAuthnticationContext(csTransactionRequest, contextType));

    // Only add transaction and user context if it's not an update
    if (!isUpdate) {
        etgRequest.addContext(getEtgTransactionContext(csTransactionRequest));
        etgRequest.addContext(getUserContext(refId));
    }

    return etgRequest;
}

initiateTransaction Method:

Pass false for isUpdate as it is a new transaction.
ETGTransactionRequest etgRequest = csTransactionHelper.getEtgRequest(csTransactionRequest, ContextTypeEnum.AUTHENTICATION, false);
migrateCustomer Method:

Pass false for isUpdate as it involves migrating a customer and initiating a new transaction.
ETGTransactionRequest etgRequest = csTransactionHelper.getEtgRequest(csTransactionRequest, ContextTypeEnum.AUTHENTICATOR, false);
reInitiateTransaction Method:

Pass false for isUpdate since it is re-initiating a transaction.
ETGTransactionRequest etgRequest = csTransactionHelper.getEtgRequest(csTransactionRequest, ContextTypeEnum.AUTHENTICATION, false);
updateTransaction Method:

Pass true for isUpdate to avoid adding transaction and user contexts.
ETGTransactionRequest etgRequest = csTransactionHelper.getEtgRequest(csTransactionRequest, ContextTypeEnum.AUTHENTICATION, true);



--------------------------------

Current Issue: 

The request payload for the Sim Swap External Endpoint is duplicating the transaction details: 

PFBCallSignrequestcapturedonDP-{
	"applicationArea": {
		"senderId": ["IB","IB"],
		"countryOfOrigin": ["AE",
		"AE"],
		"transactionDateTime": ["2024-06-03T03:12:02.002Z",
		"2024-06-03T03:12:03.003Z"],
		"transactionId": "af885605-973e-4ebf-92ce-a8cd010d8bb2"
	},
	"dataArea": {
		"phoneNumber": ["0582725831",
		"0582725831"],
		"referenceDate": ["2024-05-04 03:12:02.751",
		"2024-05-04 03:12:03.079"],
		"customerIdentifier": ["594909f43972f1b78fb98526bcf2e74f",
		"594909f43972f1b78fb98526bcf2e74f"]
	}
}

Current PUT (Update) Payload: 

The current payload for the PUT (update) Request is adding additional transaction object and user object  this is causing the duplication above:

14 Aug 2024 10:49:43,919 INFO (WebContainer : 41) (BROWSER-1005871968) [HttpConnector:]: Http Request:{"userName":"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX","transac
tionId":"1fb2903d-3abe-4d79-8d57-9c01466cb242","sessionId":"482f787a-7eb9-4b93-82ea-5208c56b1cc7","transactionType":"LOGIN","context":[{"type":"AUTHENTICATIO
N","authentication":{"requirementsCombination":{"requirementId":"b950c446-3f7b-41a7-a74c-3fd733d1d8e7","metadata":{"tenantId":"tnt-fnh3br5y-tbdcvkty-3gvvdtxj
v-42kmmf2n","userId":"sub-4rh9n35s-9e1wk1dn-atyjw3pw5-qbx619q7","transactionId":"1fb2903d-3abe-4d79-8d57-9c01466cb242","externalSessionId":"482f787a-7eb9-4b9
3-82ea-5208c56b1cc7","qualifiedIdentity":{"namespace":"userName","id":"7b73e457af6bb6c46ecced0f5XXX88ed"},"timestamp":1723618183760,"mostRecentlyUsedDeviceId
":"-1","language":["en"]},"combinationType":"REQUIREMENT","priority":0,"priorityReason":"ORG_EXPLICIT","requirement":{"type":"AUTHENTICATE","authenticator":{
"channel":"EXTERNAL","bindChannel":"EXTERNAL","className":"UNP","validationMode":"EXTERNAL","deliveryMode":"DEFAULT","displayName":"UNP","mechanism":{"displa
yName":"UNP","factorTypes":["KNOWLEDGE"],"mechanismType":"EXTERNAL","mode":"PRIMARY"},"preference":0,"strength":0,"currentFailureCount":0,"dynamicLinkingFlag
":false,"templates":{},"restrictions":[],"restricted":false,"additionalAttributes":{"maxChallenges":"5","maxAttempts":"3","PERSISTANT_DATA":"false","EXCHANGE
_SDK_DATA":"false"}},"channel":"EXTERNAL","validationMode":"EXTERNAL","deliveryMode":"DEFAULT","challengeData":[{"id":"CS_TITLE","displayValue":"login"},{"id
":"CS_TOTAL_AMOUNT","displayName":"TOTAL_AMOUNT","displayValue":""},{"id":"CS_AUTH_CODE","displayName":"AUTH_CODE","displayValue":"67075478"}],"timestamp":0}
,"timestamp":1723618183794},"result":{"result":"SUCCESS"},"resultsMap":{"b950c446-3f7b-41a7-a74c-3fd733d1d8e7":{"result":"SUCCESS"}},"completedTimestamp":172
3618183863}}, {"type":"TRANSACTION","transaction":{"additionalTransactionInformation":{"forgotPasswordInHours":"19655","authmessage_en":"Swipe to complete you
r login to FAB Online Banking","transactionDateTime":"2024-XX-XXT10:49:43.043Z","forgotPINInHours":"9999","mobileBankingLock":"false","custOnboardInDays":"90
4","channel":"IB","pinChangedInDays":"9999","IB_AUTH":"MOBILE","simSwapReferenceInHours":"720","phoneNumber":"0XXXXX1580","internetBankingLock":"false","coun
tryOfOrigin":"AE","referenceDate":"2024-XX-XX 10:49:43.911","authmessage_ar":"Swipe to complete your login to FAB Online Banking","pwdChangedInDays":"9999"}}
},{"source":"DECISION_REQUEST","type":"USER","user":{"externalUniqueId":"7b73e457af6bb6c46ecced0f5XXX88ed","additionalAttributes":{"device_id":"br_083e0849-d
7ad-4ea7-aa91-dac8a882fabe"},"timestamp":1723618183911}}],"authenticator":"UNP","language":"en"} 


Proposed Solution for the above context:

In the FAB Code base - Remove ONLY the Transaction Object and User Object from the PUT (Update) ETG Call. Everything else should remain the same.

SAMPLE PUT (Update) Request Body:

{
    "request": {
        "metadata": {
            "tenantId": "{{tenantId}}",
            "timestamp": {{currentTime}},
            "externalSessionId": "sessionID",
            "transactionId": "transactionId",
            "qualifiedIdentity": {
                "id": "amuhaimin",
                "namespace": "userName"
            }
        },
        "transaction": {
            "brand": {
                "value": "{{organisationId}}"
            },
            "type": {
                "value": "login"
            },
            "channel": {
                "value": "IB"
            }
        },
        "context": [
            {
                "type": "AUTHENTICATION",
                "authentication": {
                    "requirementsCombination": {{requirementsCombination}},
                    "result":{
                        "result":"SUCCESS"
                    },
                    "resultsMap": {
                        "{{requirementId}}": {
                            "result": "SUCCESS"
                        }
                    },
                    "completedTimestamp": {{currentTime}}
                }
            }
        ],
        "authenticator": "UNP",
        "language": "en"
    }
}


The result should be (Example):

{"applicationArea":{"senderId":"IB","countryOfOrigin":"AE","transactionDateTime":"2024-XX-XXT10:49:43.043Z","transactionId":"txn-50fe9045-6ffa-4d9f-b182-8b938a4ef2bb"},"dataArea":{"phoneNumber":"0XXXXX1580","referenceDate":"2024-XX-XX 10:49:43.911","customerIdentifier":"7b73e457af6bb6c46ecced0f5XXX88ed"}}


NOTE:

This has been tested on the IB Login Journey within the Callsign Environment. This must be tested within the on-prem solution within the FAB environment before applying the change to PROD. 

It is strongly recommended to setup the FAB UAT or FAB Non-PROD environment with the same Initial POST ETG call and Update PUT ETG API calls with the same configurations and codebase as per the PROD environment. This should also include a working Sim Swap Service.  

////////////////////
public ETGTransactionRequest getEtgRequest(CsTransactionRequest csTransactionRequest, ContextTypeEnum contextType) {
		ETGTransactionRequest etgRequest = new ETGTransactionRequest();
		if (Objects.isNull(csTransactionRequest) || (StringUtils.isBlank(csTransactionRequest.getCsTransactionId())
						|| Objects.isNull(csTransactionRequest.getCsTransactionType()))) {
			log.debug("Invalid request for CS Transaction");
			throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
		}

		etgRequest.setTransactionId(csTransactionRequest.getCsTransactionId());
		etgRequest.setOldTransactionId(csTransactionRequest.getCsOldTransactionId());
		etgRequest.setTransactionType(csTransactionRequest.getCsTransactionType());
		etgRequest.setAuthenticator(csTransactionRequest.getAuthenticator());
		SessionInfo session = SessionContext.getSession();
		etgRequest.setSessionId(session.getSessionID());
		String refId = HashUtil.getPseudoCinHash(session.getUser().getCif());
		etgRequest.setUserName(refId);
		etgRequest
				.setLanguage(StringUtils.isBlank(localeHelper.resolveLanguage()) ? AppConstants.LOCALE_EN.toLowerCase()
						: localeHelper.resolveLanguage().toLowerCase());

		etgRequest.addContext(getEtgAuthnticationContext(csTransactionRequest, contextType));
		etgRequest.addContext(getEtgTransactionContext(csTransactionRequest));

		log.debug("Add additional Context with user details.");
		etgRequest.addContext(getUserContext(refId));
		return etgRequest;
	}

	/**
	 * 
	 * @param session
	 * @return context
	 */
	private Context getUserContext(String refId) {
		log.info("CsTransactionHelper.getUserContext.start");
		Context context = new Context();
		context.setSource(ContextSourceEnum.DECISION_REQUEST);
		context.setType(ContextTypeEnum.USER);

		UserIdentity userIdentity = new UserIdentity();
		userIdentity.setExternalUniqueId(refId);
		userIdentity.setTimestamp(System.currentTimeMillis());
		Map<String, String> additionalAttributes = new HashMap<>();
		additionalAttributes.put(AppConstants.ATTRIBUTE_DEVICE_ID, SessionContext.getSession().getUniqueDeviceId());
		userIdentity.setAdditionalAttributes(additionalAttributes);
		context.setUser(userIdentity);
		return context;
	}

	/**
	 * Transaction status for additional transaction information for Mobile and
	 * internet banking lock.
	 * 
	 * @return
	 */
	private Context getEtgTransactionContext(CsTransactionRequest csTransactionRequest) {
		SessionInfo session = SessionContext.getSession();
		Context context = new Context();
		context.setType(ContextTypeEnum.TRANSACTION);
		Transaction transaction = new Transaction();
		Map<String, String> additionalTransactionInformation = new HashMap<>();
		if (session.getChannelType() == ChannelType.BROWSER) {
			if((settingsRepository.isIBDependentOnMobile() && callsignAuthHelper.isCallsignEnabledCust(session, ChannelType.BROWSER))
					|| callsignAuthHelper.isCallsignEnabledCustWithDeviceCount(session, ChannelType.BROWSER)){
				additionalTransactionInformation.put(AppConstants.IB_AUTH_TYPE, AppConstants.IB_AUTH_MOBILE);
				ChannelInfo channelInfo = channelInfoRepository.fetchChannelInfoByChannelUserId(ChannelType.MOBILE.name(),
						session.getUser().getCif());
				boolean isChannelActive = Objects.nonNull(channelInfo) && StringUtils.isNotBlank(channelInfo.getStatus())
						&& AppConstants.ACTIVE.equals(channelInfo.getStatus());
				boolean isMobileLockOrBlocked = Objects.isNull(channelInfo) ? true
						: (TextUtils.INSTANCE.getBoolean(channelInfo.getIsLocked())
								|| TextUtils.INSTANCE.getBoolean(channelInfo.getIsBlocked()));
				additionalTransactionInformation.put(AppConstants.MOBILE_BANKING_LOCK, !isChannelActive ? AppConstants.TRUE
						: isMobileLockOrBlocked ? AppConstants.TRUE : AppConstants.FALSE);
			}else{
				additionalTransactionInformation.put(AppConstants.IB_AUTH_TYPE, AppConstants.IB_AUTH_OTP);
				additionalTransactionInformation.put(AppConstants.MOBILE_BANKING_LOCK, AppConstants.FALSE);
			}
			
			if(csTransactionRequest.getCsTransactionType() == CsTransactionType.PASSWORD_RESET) { 
				log.info("overriding the forget password flow to OTP based on FMDB-94354");
				additionalTransactionInformation.put(AppConstants.IB_AUTH_TYPE, AppConstants.IB_AUTH_OTP);
			}
			
			additionalTransactionInformation.put(AppConstants.INTERNET_BANKING_LOCK, AppConstants.FALSE);
		} else {
			additionalTransactionInformation.put(AppConstants.MOBILE_BANKING_LOCK, AppConstants.FALSE);
		}

		String authMessageEn = getDynamicAuthMessage(csTransactionRequest, AppConstants.AUTH_MESSAGE_EN);
		String authMessageAr = getDynamicAuthMessage(csTransactionRequest, AppConstants.AUTH_MESSAGE_AR);
		additionalTransactionInformation.put(AppConstants.AUTH_MESSAGE_EN, authMessageEn);
		additionalTransactionInformation.put(AppConstants.AUTH_MESSAGE_AR, authMessageAr);

		if (Objects.nonNull(csTransactionRequest.getRiskSeverity())) {
			additionalTransactionInformation.put(AppConstants.CS_TRANSACTION_RISK_CHECKER,
					csTransactionRequest.getRiskSeverity().getCode());
		}
		// additionalTransactionInformation.put("transactionDateTime" ,
		// FABUtils.INSTANCE.get);
		// RBA Code with extra details in the context.
		additionalTransactionInformation.put(AppConstants.TRANSACTION_DATE_TIME, determineTransactionDateTime());
		if (isLoginRregistratin(csTransactionRequest)) {
			// Call the new method and get the details and set in the map.
			setRBAUserDetails(session, additionalTransactionInformation);
		}
		if (csTransactionRequest.getCsTransactionType() == CsTransactionType.MB_REGISTRATION) {
			deviceNearMeNLiveness(csTransactionRequest, session, additionalTransactionInformation);
			// deviceAppCenterName = "HUAWEI" / "iPhone" / "Android"
			// additionalTransactionInformation.put("deviceAppCenterName" ,
			// FABUtils.INSTANCE.get);
			// additionalTransactionInformation.put(AppConstants.DEVICE_APP_CENTER_NAME,
			// deviceTypeChecker.generateDeviceAppCenterName());
			additionalTransactionInformation.put(AppConstants.DEVICE_APP_CENTER_NAME, typeChecker.determineDeviceAppCenterName());

		}
		transaction.setAdditionalTransactionInformation(additionalTransactionInformation);
		context.setTransaction(transaction);

		return context;
	}

	private String determineTransactionDateTime() {
		Date date = new Date();
		StringBuilder builder = new StringBuilder();
		builder.append(DateTimeHelper.INSTANCE.formatDate(date, DATE_YYYMMDD));
		builder.append("T");
		builder.append(DateTimeHelper.INSTANCE.formatDate(date, TIME_HHMMSSSSS));
		builder.append("Z");
		return builder.toString();
	}
==============================================
/**
	 * Initiate ETG transaction with Callsign.
	 * 
	 * @param transactionID
	 * @return cstran CsInitiateTransactionResponse
	 */
	public CsTransactionResponse initiateTransaction(CsTransactionRequest csTransactionRequest) {
		CsTransactionResponse csTransactionResponse = new CsTransactionResponse();
		return execute(csTransactionRequest, csTransactionResponse, req ->  {
			
			if (csTransactionRequest.getCsTransactionType() == CsTransactionType.LOGIN
					|| csTransactionRequest.getCsTransactionType() == CsTransactionType.LOGIN_V2
					|| csTransactionRequest.getCsTransactionType() == CsTransactionType.PIN_RESET)
				checkTrottle();
			
			SessionInfo session = SessionContext.getSession();
			User user = session.getUser();
			String cif = user.getCif();
			String convID = session.getConvID();
			String deviceID = session.getDeviceID();
			
			ChannelType channelType = session.getChannelType();	
			
			ChannelInfo channelInfo = channelInfoRepository.fetchChannelInfoByChannelUserId(channelType.name(), cif);
			channelValidator.validateChannelInfoForCs(channelInfo, channelType, csTransactionRequest);
						
			if(csTransactionRequest.getCsTransactionType() == CsTransactionType.IB_REGISTRATION
					|| csTransactionRequest.getCsTransactionType() == CsTransactionType.MB_REGISTRATION) 
			removeUserCacheDuringRegistration();
			
			if(csTransactionRequest.getCsTransactionType() == CsTransactionType.PIN_RESET_OTP || csTransactionRequest.getCsTransactionType() ==CsTransactionType.PIN_RESET
					|| csTransactionRequest.getCsTransactionType().equals(CsTransactionType.PASSWORD_RESET)) {		
				/** reset OTP authenticator **/
				csAuthenticatorSF.cleanUserDeviceAndAuthenticators(false);
			}
			
			ETGTransactionRequest etgRequest = csTransactionHelper.getEtgRequest(csTransactionRequest, ContextTypeEnum.AUTHENTICATION);
			log.debug("ETG Request {}", etgRequest);
			ETGTransactionResponse etgResponse = null;
			/*if(session.getChannelType() == ChannelType.BROWSER) {
				etgResponse = csTransactionHelper.mockEtgResponse(csTransactionRequest, false, false);
			} else {*/
				etgResponse = csTransactionServiceInvoker.initiateTransaction(etgRequest); // csTransactionHelper.mockEtgResponse(csTransactionRequest, false, false);
				//}
			transactionAudit.saveTransactionAuditInfo(prepareAudtiAttributes(csTransactionRequest,etgResponse , "INITIATE-TRANSACTION"));
			log.debug("ETG response {}", etgResponse);
			if(etgResponse.getResult() == ResultEnum.DENIED  || etgResponse.getResult() == ResultEnum.FAILED) {
				captureLoginFailure(csTransactionRequest, cif, deviceID, channelType);
				String message = etgResponse.getMessage();
				log.error("CsTransactionSF - message : {}", message);
				csTransactionResponse.setEtgTransactionResponse(etgResponse);
				if (StringUtils.isNotBlank(message)
						&& (message.equals(AppConstants.REG_MOBILE_CHANNEL_LOCKED)
								|| message.equals(AppConstants.RESET_MOBILE_CHANNEL_LOCKED)
								|| message.equals(AppConstants.LOGIN_MOBILE_CHANNEL_LOCKED))) {
					csTransactionHelper.processErrorBasedOnMessage(message);
				} else {
					throw new AppException(ErrorCodes.CS_TRANSACTION_INITIATE_FAILED);
				}
			} else if(etgResponse.getDecision() == DecisionEnum.DENY) {
				captureLoginFailure(csTransactionRequest, cif, deviceID, channelType);
				throw new AppException(ErrorCodes.CS_TRANSACTION_INITIATE_FAILED);
			} else if(etgResponse.getDecision() == DecisionEnum.ALLOW) {
				//Update the Session to verified.
				sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
				csTransactionResponse.setEtgTransactionResponse(etgResponse);
			} else if(etgResponse.getDecision() == DecisionEnum.REFER) {
				Long csTxnActiveTimeout = settingsRepository.getCsTxnActiveTimeout();
				int csTxnActiveIncorrectAttempts = settingsRepository.getCsTxnActiveIncorrectAttempts();
				int csTxnActiveMaxAttempts = settingsRepository.getCsTxnActiveMaxAttempts();
				csTransactionResponse.setEtgTransactionResponse(etgResponse);
				sendOTPRUnpAuthnticator(csTransactionResponse, session, user, csTransactionRequest, etgResponse);
				
				csTransactionResponse.setCsTxnActiveAllowedAttempts(csTxnActiveIncorrectAttempts);
				csTransactionResponse.setCsTxnActiveMaxResendAttempts(csTxnActiveMaxAttempts);
				csTransactionResponse.setCsTxnActiveTimeInSeconds(csTxnActiveTimeout);
			}
			mapNameNResponse(csTransactionResponse, cif, user, channelType);
			
			return csTransactionResponse;
		});
	}

/////////////////////
/**
	 * Migrate already registered user to callsign.
	 * 1. Create User in callsign.
	 * 2. initiate transaction with MPIN Authenticator.
	 * 
	 * @param transactionID
	 * @return cstran CsInitiateTransactionResponse
	 */
	public CsTransactionResponse migrateCustomer(CsTransactionRequest csTransactionRequest) {
		CsTransactionResponse csTransactionResponse = new CsTransactionResponse();
		return execute(csTransactionRequest, csTransactionResponse, req ->  {
			SessionInfo session = SessionContext.getSession();
			User user = session.getUser();
			String cif = user.getCif();
			ChannelType channelType = session.getChannelType();
			
			ChannelInfo channelInfo = channelInfoRepository.fetchChannelInfoByChannelUserId(channelType.name(), cif);
			channelValidator.validateChannelInfoForCs(channelInfo, channelType, csTransactionRequest);
			
			/**
			 * Create user in scim
			 */
			String refId = updateReferenceId(user, channelInfo);
			APIResponse createUserRes = csUserManagementSF.createUser(refId);
			
			if(!createUserRes.getResult().isSuccess()) {
				throw new AppException(ErrorCodes.CS_CREATE_USER_FAILED);
			}
			
			ETGTransactionRequest etgRequest = csTransactionHelper.getEtgRequest(csTransactionRequest, ContextTypeEnum.AUTHENTICATOR);
			
			ETGTransactionResponse etgResponse = csTransactionServiceInvoker.initiateTransaction(etgRequest);

			transactionAudit.saveTransactionAuditInfo(prepareAudtiAttributes(csTransactionRequest,etgResponse,  "MPIN-MIGRATE"));
			
			if(etgResponse.getResult() == ResultEnum.DENIED  || etgResponse.getResult() == ResultEnum.FAILED) {
				throw new AppException(ErrorCodes.CS_TRANSACTION_INITIATE_FAILED);
			} else if(etgResponse.getDecision() == DecisionEnum.DENY) {
				throw new AppException(ErrorCodes.CS_TRANSACTION_INITIATE_FAILED);
			}
			Long csTxnActiveTimeout = settingsRepository.getCsTxnActiveTimeout();
			int csTxnActiveIncorrectAttempts = settingsRepository.getCsTxnActiveIncorrectAttempts();
			int csTxnActiveMaxAttempts = settingsRepository.getCsTxnActiveMaxAttempts();
			
			csTransactionResponse.setCsTxnActiveAllowedAttempts(csTxnActiveIncorrectAttempts);
			csTransactionResponse.setCsTxnActiveMaxResendAttempts(csTxnActiveMaxAttempts);
			csTransactionResponse.setCsTxnActiveTimeInSeconds(csTxnActiveTimeout);
			csTransactionResponse.setEtgTransactionResponse(etgResponse);
			
			mapNameNResponse(csTransactionResponse, cif, user, channelType);
			return csTransactionResponse;
		});
	}
/////////////////////////////////////
/**
	 * Reinitiate ETG transaction with Callsign.
	 * Cancel and Initiate new transaction.
	 * 
	 * @param transactionID
	 * @return
	 */
	public CsTransactionResponse reInitiateTransaction(CsTransactionRequest csTransactionRequest) {
		log.debug("CsTransactionSF.reInitiateTransaction.Start {} ",csTransactionRequest);
		CsTransactionResponse csTransactionResponse = new CsTransactionResponse();
		return execute(csTransactionRequest, csTransactionResponse, req ->  {
			
			SessionInfo session = SessionContext.getSession();
			String cif = session.getUser().getCif();
			String convID = session.getConvID();
			String deviceID = session.getDeviceID();
			User user = session.getUser();
			ChannelType channelType = session.getChannelType();
			
			ErrorCodes error = csTransactionRequest.getCsTransactionType() == CsTransactionType.TRANSACTION_RISK_CHECKER 
					? ErrorCodes.CS_RISK_TRANSACTION_INITIATE_FAILED : ErrorCodes.CS_TRANSACTION_INITIATE_FAILED;
			
			ChannelInfo channelInfo = channelInfoRepository.fetchChannelInfoByChannelUserId(channelType.name(), cif);
			channelValidator.validateChannelInfoForCs(channelInfo, channelType, csTransactionRequest);
					
			
			if(csTransactionRequest.getCsTransactionType() == CsTransactionType.IB_REGISTRATION
					|| csTransactionRequest.getCsTransactionType() == CsTransactionType.MB_REGISTRATION) 
			removeUserCacheDuringRegistration();
			
			/*
			|| ( StringUtils.isNotBlank(csTransactionRequest.getCsTransactionId())
					&& StringUtils.isNotBlank(csTransactionRequest.getCsOldTransactionId()) 
					&& csTransactionRequest.getCsOldTransactionId().equals(csTransactionRequest.getCsTransactionId()) )
			*/
			
			if(StringUtils.isBlank(csTransactionRequest.getCsOldTransactionId()) || StringUtils.isBlank(csTransactionRequest.getCsTransactionId())) {
				throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
			}
			ETGTransactionResponse etgResponse = null;
			if(csTransactionRequest.getCsTransactionType() == CsTransactionType.MB_REGISTRATION) {
				//change to old transaction id
				csTransactionServiceInvoker.cancelTransaction(csTransactionRequest.getCsOldTransactionId());
				
				csUserManagementSF.createUser(channelInfo.getReferenceId());
				ETGTransactionRequest etgRequest = csTransactionHelper.getEtgRequest(csTransactionRequest, ContextTypeEnum.AUTHENTICATION);
				log.debug("CsTransactionSF.reInitiateTransaction.ETGTransactionRequest {}",etgRequest);
				
				etgResponse = csTransactionServiceInvoker.initiateTransaction(etgRequest);
			} else {
				ETGTransactionRequest etgRequest = csTransactionHelper.getEtgRequest(csTransactionRequest, ContextTypeEnum.AUTHENTICATION);
				log.debug("CsTransactionSF.reInitiateTransaction.ETGTransactionRequest {}",etgRequest);
				
				/*if(session.getChannelType() == ChannelType.BROWSER) {
					etgResponse = csTransactionHelper.mockEtgResponse(csTransactionRequest, false, false); 
				} else {*/
					etgResponse = csTransactionServiceInvoker.reInitiateTransaction(etgRequest); //csTransactionHelper.mockEtgResponse(csTransactionRequest, false, false); 
				//}
			}
			
			transactionAudit.saveTransactionAuditInfo(prepareAudtiAttributes(csTransactionRequest,etgResponse, "RE-INITIATE-TRANSACTION"));
			log.debug("CsTransactionSF.reInitiateTransaction.ETGTransactionResponse {}",etgResponse);
			if(etgResponse.getResult() == ResultEnum.DENIED  || etgResponse.getResult() == ResultEnum.FAILED) {
				captureLoginFailure(csTransactionRequest, cif, deviceID, channelType);
				throw new AppException(error);
			} else if(etgResponse.getDecision() == DecisionEnum.DENY) {
				captureLoginFailure(csTransactionRequest, cif, deviceID, channelType);
				throw new AppException(error);
			} else if(etgResponse.getDecision() == DecisionEnum.ALLOW) {
				//Update the Session to verified.
				sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
				csTransactionResponse.setEtgTransactionResponse(etgResponse);
			} else if(etgResponse.getDecision() == DecisionEnum.REFER) {
				// Wrap in resendOTP method, take verifycustomersf.verifyEmiratesIDForRegistration as reference.
				// check the authenticator == AuthenticatorClassEnum.OTP_INTERNAL_GEN_EXTERNAL_DELIVER
				// extract OTP and send otp
				// update ETG with success.
				log.debug("CsTransactionSF.reInitiateTransaction.ETGTransactionResponse :REFER {}");

				csTransactionResponse.setEtgTransactionResponse(etgResponse);
				sendOTPRUnpAuthnticator(csTransactionResponse, session, user, csTransactionRequest, etgResponse);

				Long csTxnActiveTimeout = settingsRepository.getCsTxnActiveTimeout();
				csTransactionResponse.setCsTxnActiveTimeInSeconds(csTxnActiveTimeout);
				csTransactionResponse.getEtgTransactionResponse().clearPIIData();
			}
			mapNameNResponse(csTransactionResponse, cif, user, channelType);
			return csTransactionResponse;
		});
	}

////////////////////////////////////////////
	/**
	 * Update ETG transaction with Callsign.
	 * 
	 * @param transactionID
	 * @return cstran CsInitiateTransactionResponse
	 */
	public CsTransactionResponse updateTransaction(CsTransactionRequest csTransactionRequest) {
		CsTransactionResponse csTransactionResponse = new CsTransactionResponse();
		return execute(csTransactionRequest, csTransactionResponse, req ->  {
			
			SessionInfo session = SessionContext.getSession();
			String cif = session.getUserId();
			String convID = session.getConvID();
			String deviceID = session.getDeviceID();
			User user = session.getUser();
			ChannelType channelType = session.getChannelType();
			
			ETGTransactionRequest etgRequest = csTransactionHelper.getEtgRequest(csTransactionRequest, ContextTypeEnum.AUTHENTICATION);
			log.debug("ETG Request {}", etgRequest);
			ETGTransactionResponse etgResponse = null;
			/*if(session.getChannelType() == ChannelType.BROWSER) {
				etgResponse =  csTransactionHelper.mockEtgResponse(csTransactionRequest, false, true);
			} else {*/
				etgResponse =  csTransactionServiceInvoker.updateTransaction(etgRequest); //csTransactionHelper.mockEtgResponse(csTransactionRequest, false, true);
			//}
			transactionAudit.saveTransactionAuditInfo(prepareAudtiAttributes(csTransactionRequest,etgResponse, "UPDATE-TRANSACTION"));
				
			if(etgResponse.getResult() == ResultEnum.DENIED  || etgResponse.getResult() == ResultEnum.FAILED) {
				setErrorMessage(csTransactionRequest);
				captureLoginFailure(csTransactionRequest, cif, deviceID, channelType);
			} else if(etgResponse.getDecision() == DecisionEnum.DENY) {
				setErrorMessage(csTransactionRequest);
				captureLoginFailure(csTransactionRequest, cif, deviceID, channelType);
			} else if(etgResponse.getDecision() == DecisionEnum.REFER && Objects.nonNull(etgResponse.getRequirementId())
					&& Objects.nonNull(etgResponse.getResultsMap().get(etgResponse.getRequirementId()))
					&& Objects.nonNull(etgResponse.getResultsMap().get(etgResponse.getRequirementId()).getResponse())) {
				sendOTPRUnpAuthnticator(csTransactionResponse, session, user, csTransactionRequest, etgResponse);
			}
			
			csTransactionResponse.setEtgTransactionResponse(etgResponse);
			return csTransactionResponse;
		});
	}

===============================================

-------------------------------
Title: Detailed fetchAlertHistory Method Flow with updateLastAccessAlertCenter and Table Interaction

Caller->fetchAlertHistory: Invoke fetchAlertHistory()
fetchAlertHistory->SessionContext: getUser()
SessionContext-->fetchAlertHistory: User
alt User's Mobile Number is Available
    fetchAlertHistory->ciRepository.getAlertHistory: Invoke getAlertHistory(mobileNo, email)
    ciRepository.getAlertHistory->Database: Execute GET_ALERT_HISTORY query
    Database-->ciRepository.getAlertHistory: ResultSet (rs)
    loop Process each row in ResultSet
        ciRepository.getAlertHistory->ciRepository.getAlertHistory: Create AlertDetail object
    end
    ciRepository.getAlertHistory-->fetchAlertHistory: List<AlertDetail>
else
    fetchAlertHistory->fetchAlertHistoryResponse: Initialize Empty Alert List
end
fetchAlertHistory->fetchAlertHistoryResponse: setAlertHistory(alertDtls)
alt Alert Details Not Empty
    fetchAlertHistory->fetchAlertHistoryResponse: Get First AlertDetail
    fetchAlertHistory->SessionContext: getChannelType()
    SessionContext-->fetchAlertHistory: ChannelType
    alt ChannelType is BROWSER
        fetchAlertHistory->userChannelRepository.updateLastAccessAlertCenter: Update Last Access Alert (cif, channelType, alertDetail.getIdMessage())
        userChannelRepository.updateLastAccessAlertCenter->execute: Prepare Statement for USR_CHNL_IB_LASTACCESS_ALERTCENTER
        execute->PreparedStatement: ps.setString(1, idMessage)
        execute->PreparedStatement: ps.setString(2, cif)
        execute->PreparedStatement: ps.setString(3, channelID)
        execute->Database: Execute Update Query on user_channel table
        Database-->execute: Success
        execute-->userChannelRepository.updateLastAccessAlertCenter: Success
    end
end
fetchAlertHistory->Caller: Return fetchAlertHistoryResponse


@SuppressWarnings({ "unchecked", "rawtypes" })
	public List<AlertDetail> getAlertHistory(String mobileNo, String email) {
		return (List) executeQueryForList(CIQueryConstants.GET_ALERT_HISTORY, ps -> {
			ps.setString(1, mobileNo);
			ps.setString(2, email);
			ps.setInt(3, MAX_ROW);
		} , rs -> {
			AlertDetail alertDetail = new AlertDetail();
			int i = 0;
			alertDetail.setDate(rs.getString(++i));
			alertDetail.setAlertType(rs.getString(++i));
			alertDetail.setAddress(rs.getString(++i));
			alertDetail.setAlertMessage(rs.getString(++i));
			alertDetail.setIdMessage(rs.getString(++i));
			return alertDetail;
		});
	}



String GET_ALERT_HISTORY = "SELECT to_char(datcreated) AS vdate, idnotifier, address, message, idmessage  FROM alert_esb_queue where address in (?,?) AND idalert IN ('IBMB_PROFILE_ALERT','IBMB_NOTIFICATION_ALERT') AND ROWNUM <= ? ORDER BY datcreated DESC";

public Integer updateLastAccessAlertCenter(final String cif, final String channelID, final String idMessage) {
		return execute(USR_CHNL_IB_LASTACCESS_ALERTCENTER, ps->{
			int i = 1;
			ps.setString(i, idMessage);
			ps.setString(++i, cif);		
			ps.setString(++i, channelID);
		});
	
	}

private static final String USR_CHNL_IB_LASTACCESS_ALERTCENTER = "UPDATE user_channel SET last_access_alertCenter = ? WHERE cif=? AND channel_id=?";

public FetchAlertHistoryResponse fetchAlertHistory() {
		FetchAlertHistoryResponse apiResponse = new FetchAlertHistoryResponse();
		return execute(null, apiResponse, req -> {
			User user = SessionContext.getSession().getUser();
			log.info("fetchAlertHistory for user:{}", user);
			FetchAlertHistoryResponse fetchAlertHistoryResponse = new FetchAlertHistoryResponse();
			List<AlertDetail> alertDtls = null;
			AlertDetail alertDetail = null;

			if (StringUtils.isNotBlank(user.getMobileNo())) {
				alertDtls = ciRepository.getAlertHistory(user.getMobileNo(),
						(user.getEmail() == null ? AppConstants.NA : user.getEmail()));
			} else {
				alertDtls = new ArrayList<AlertDetail>();
			}

			fetchAlertHistoryResponse.setAlertHistory(alertDtls);
			// PBG-199 Update lastAccess_alertCenter in user channel
			if (Objects.nonNull(alertDtls) && !alertDtls.isEmpty()) {
				alertDetail = alertDtls.get(0);
				log.info("inside alert details - {}", alertDetail.getIdMessage());
			}
			String cif = user.getCif();
			ChannelType channelType = SessionContext.getSession().getChannelType();
			if (ChannelType.BROWSER == channelType && Objects.nonNull(alertDetail)) {
				log.info("in alert history to update last alert access for cif:{} and channelType:{}", cif,
						channelType.name());
				userChannelRepository.updateLastAccessAlertCenter(cif, channelType.name(), alertDetail.getIdMessage());
				log.info("Last access for alerts has been updated in user channel");
			}
			return fetchAlertHistoryResponse;
		});
	}

Prerequisite

Within UAE (IPP, IPI) and Within FAB transfers initiated via FAB Mobile/Online banking post successful implementation of this feature.

Acceptance Criteria:

Case 1 Post successful Within FAB transfers, FAB Mobile /Online banking trigger email notification to customer with transfer advice as an attachment.

Case 2 Post successful Within UAE (IPP, IPI) transfers, FAB Mobile /Online banking trigger email notification to customer with transfer advice as an attachment.

Case 3 Customer can access the transfer advice for Within UAE (IPP, IPI) and Within FAB via email notifications.

Case 4 Transfer advice sent to customer's registered email address will be password protected file. We will use the same encryption maintained for account eStatement / stamped statement in production to open the file. (Last 4 digits of the account followed by the 4 digits representing the day and month of birthday)

New E-mail content: To be finalized (pending with business)

Attachment Name:

i) WithinUAE_TransferAdvice [In case if transfer initiated is Within UAE]

ii) WithinFAB_TransferAdvice [In case if transfer initiated is Within FAB]

Attachments

/**
	 * Method for Generate the Iban letter
	 * 
	 * @param an instance of {@link IBANGeneratorReqeust}
	 * @return {@link String}
	 */
	public IBANGeneratorResponse generateIban(final IBANGeneratorReqeust ibanGeneratorReqeust) {

		log.info("LetterSF::generateIban()");
		
		IBANGeneratorResponse apiResponse = new IBANGeneratorResponse();
		IBANAuditRequest ibanAuditRequest = new IBANAuditRequest();
		String customerName = getCustomerName(ibanGeneratorReqeust.getSourceAccount());
		SessionInfo sessionInfo = SessionContext.getSession();
		ibanAuditRequest.setCin(sessionInfo.getUser().getCin());
		ibanAuditRequest.setCif(sessionInfo.getUser().getCif());
		ibanAuditRequest.setCustomerName(customerName);
		
		return execute(ibanGeneratorReqeust, apiResponse, request -> {
			if (isValidIbanRequest(request)) {
				DocumentRequest documentRequest = new DocumentRequest();
				
				// Validate if transaction is authenticated by callsign or not.
				AuthData authResponse = authenticationSF.verifyAuthKey(request);
				if(authResponse.getResult().isSuccess()) {
					documentRequest.setContentItemExchange(contentItemExchangeBuilder(request.getSourceAccount()));
					documentRequest.setDataFields(dataFieldMapper(request, customerName));
					documentRequest.setFileName("IBAN_LETTER_"+ibanGeneratorReqeust.getSourceAccount().substring(ibanGeneratorReqeust.getSourceAccount().length()-4));
					boolean sitFlag = StringUtils.equals(sessionInfo.getEnvironment(), AppConstants.SIT);
					String result =  ibmbMSServiceInvoker.invokePost(documentRequest, sitFlag?ServiceURLs.DOCUMENT_GENERATE_SIT:ServiceURLs.DOCUMENT_GENERATE);
					if (StringUtils.isNotBlank(result)) {
						IBANFileAttachment attachment =JsonUtils.convertToObject(IBANFileAttachment.class, result);
						apiResponse.setFileAttachment(attachment);
						ibanAuditRequest.setStatus(AppConstants.SUCCESS);
						publishIBANEvent(ibanAuditRequest);
						recordIBANAuditDetails(ibanAuditRequest);
						return apiResponse;
					} else {
						ibanAuditRequest.setStatus(AppConstants.FAILURE);
						publishIBANEvent(ibanAuditRequest);
						recordIBANAuditDetails(ibanAuditRequest);
						throw new AppException(ErrorCodes.SYS_TECHNICAL_ERROR);
					}
				}
				ibanAuditRequest.setStatus(AppConstants.FAILURE);
				apiResponse.setResult(authResponse.getResult());
				publishIBANEvent(ibanAuditRequest);
				recordIBANAuditDetails(ibanAuditRequest);
				return apiResponse;
			} else {
				log.info("IBANGeneratorReqeust is not valid");
				ibanAuditRequest.setStatus(AppConstants.FAILURE);
				publishIBANEvent(ibanAuditRequest);
				recordIBANAuditDetails(ibanAuditRequest);
				throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
			}
		});
	}


public APIResponse executeTransfer(final ExecuteTransferRequest transferRequest) {
		APIResponse apiResponse = new APIResponse();
		return execute(transferRequest, apiResponse, req -> {
			EdirhamCardDetailAPIResponse edirhamCardDetails = null;
			if(StringUtils.isBlank(transferRequest.getTxnRef()) || 
					(StringUtils.isNotBlank(transferRequest.getTransferDescription())&&!transferRequest.getTransferDescription().matches(AppConstants.ALPHANUMERIC_SPACES_DOT_COLON_BRACKETS_HYPHEN_COMMA_PLUS))){
				throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
			}
			
			//In case of back dated transfer, we are overriding that back date to current date.
			if((!StringUtils.isBlank(transferRequest.getTransferDate()) 
					&& DateTimeHelper.INSTANCE.isDatelessThenCurrentDate(transferRequest.getTransferDate(), AppConstants.DATE_DDMMYYYY))){
				transferRequest.setTransferDate(DateTimeHelper.INSTANCE.formatDate(new Date(), AppConstants.DATE_DDMMYYYY));
			} 
			if(transferRequest.getAutopay()!=null && !StringUtils.isBlank(transferRequest.getAutopay().getStartDate())
					&& DateTimeHelper.INSTANCE.isDatelessThenCurrentDate(transferRequest.getAutopay().getStartDate(), AppConstants.DATE_DDMMYYYY)){
				transferRequest.getAutopay().setStartDate(DateTimeHelper.INSTANCE.formatDate(new Date(), AppConstants.DATE_DDMMYYYY));
			}
			
			if(transferRequest.getAmount() < 1){ //if(transferRequest.getAmount() <= 0){ 
				// do not ALLOW such request
				throw new AppException(ErrorCodes.MINIMUM_AMOUNT);
			}else if(FundTransferTypes.INTERNATIONAL_FUNDS_TRANSFER == transferRequest.getFundTransferType()) {
				if(Objects.nonNull(transferRequest.getBeneficiary()) && AppConstants.LOCAL_CURRENCY.equals(transferRequest.getBeneficiary().getCurrency())) {
					throw new AppException(ErrorCodes.AED_CURRENCY_NOT_ALLOWED_INTERNAIONAL_TRANSFER);
				}
			}
			List<Product> debitSources = getFundingSources(transferRequest);
			if (Objects.nonNull(debitSources) && debitSources.stream().noneMatch(
					product -> product.getProdRef().equals(transferRequest.getSourceProductRef()))) {
				log.info("Fund Transfer not allowed for Debit Act: {}", transferRequest.getSourceProductRef());
				apiResponse.setError(ErrorCodes.SYS_INVALID_REQUEST);
				return apiResponse;
			}


			boolean bothAcctSame = isSourceNDestAccSame(transferRequest);
			if (bothAcctSame) {
				throw new AppException(ErrorCodes.SOURCE_DEST_ACCT_SAME);
			}
			if(transferRequest.getFundTransferType() == FundTransferTypes.EDIRHAM_TOPUP) {
				edirhamCardDetails = new EdirhamCardDetailAPIResponse();
				getEdirhamCardDetails(transferRequest,edirhamCardDetails);
			}
			checkLimit(transferRequest,edirhamCardDetails);
			/*
			 * if(!checkLimit(transferRequest)){
			 * apiResponse.setError(ErrorCodes.LIMIT_EXCEEDED); return
			 * apiResponse; }
			 */
			if (Objects.isNull(transferRequest.getAccountingUnitIdentifier())) {
				String accountUnitIdentifer = ciRepository.getAccountUnitIdentifier(transferRequest.getSourceProductRef());
				transferRequest.setAccountingUnitIdentifier(accountUnitIdentifer);
			}

			SessionInfo sessionInfo = SessionContext.getSession();
			AuthData authResponse = verify(transferRequest);

			if (authResponse.getResult().isSuccess()) {
				ExecutePaymentResponse paymentResponse = null;

				// Check payitaccount number before transaction	

				if (Objects.nonNull(transferRequest) && Objects.nonNull(transferRequest.getFundTransferType())
						&& transferRequest.getFundTransferType() == FundTransferTypes.PAYIT_WALLET_TOPUP) {
					String accNoOrCCNo = transferRequest.getBeneficiary().getRemitInfo();
					PayitLimitRequest payitLimitRequest = new PayitLimitRequest();
					payitLimitRequest.setMobileNumber(accNoOrCCNo);
					payitLimitRequest.setTransactionId(sessionInfo.getXref());
					PayItValidationResponse payItValidationResponse = payitServiceInvoker
							.fetchOtherCharge(payitLimitRequest);
					log.info("Validating payit accout number before making transaction account1:{} and account2:{}"
							, payItValidationResponse.getAccountDetails().getAccountNumber(), 
							transferRequest.getBeneficiary().getAcctOrCardNo());
					if (!payItValidationResponse.getAccountDetails().getAccountNumber()
							.equals(transferRequest.getBeneficiary().getAcctOrCardNo())) {
						log.info("Account is not correct");
						throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
					}

				}
				if (transferRequest.getFundTransferType() == FundTransferTypes.IPO_SUBSCRIPTION) {
					if(!customerSF.validateAccountBelongsToCif(transferRequest.getSourceProductRef())) {
						log.info("Account Number doesn't belongs to the logged in customer");
						throw new AppException(ErrorCodes.SYS_DEFAULT_ERROR);
					}
					
					List<IPODetails> ipoCompanies = ipoRepository.getIPOCompanies();
					IPODetails ipoCompany = ipoCompanies.stream()
							.filter(company -> company.getIpoId().equalsIgnoreCase(
									transferRequest.getIpoSubscribeDetails().getIpoDetails().getIpoId()))
							.findAny().orElse(null);
					if (Objects.nonNull(ipoCompany)) {
						transferRequest.getIpoSubscribeDetails().setIpoDetails(ipoCompany);
					}
					if ("AE0010007".equalsIgnoreCase(transferRequest.getAccountingUnitIdentifier()))
						transferRequest.setReceiverProductRef(
								transferRequest.getIpoSubscribeDetails().getIpoDetails().getIslCollectionAcc());
					else {
						transferRequest.setReceiverProductRef(
								transferRequest.getIpoSubscribeDetails().getIpoDetails().getConvCollectionAcc());
					}
					// adding investor details again in the request
					overideInvestorDeatils(transferRequest);
				}
				if (transferRequest.getFundTransferType() == FundTransferTypes.INSURANCE_PAYMENT) {
					if(Objects.nonNull(transferRequest.getSourceProductType()) && transferRequest.getSourceProductType() == ProductTypes.ACCOUNT 
							&& !customerSF.validateAccountBelongsToCif(transferRequest.getSourceProductRef())) {
						log.info("Account Number doesn't belongs to the logged in customer");
						throw new AppException(ErrorCodes.SYS_DEFAULT_ERROR);
					}
					InsuranceDetails details = transferRequest.getInsuranceDetails();

					InsuranceDbAuditResponse dbAuditResponse = insuranceAuditSF.getInsuranceDbAudit(details.getJourneyReferenceId(), 
							StringUtils.equals(SessionContext.getSession().getEnvironment(), AppConstants.SIT));
					
					double amount = Double.parseDouble(dbAuditResponse.getTotalPremium());
					log.info("Amount from api: {}",amount);
					log.info("Amount from request: {}",transferRequest.getAmount());
					if(amount != transferRequest.getAmount()) {
						throw new AppException(ErrorCodes.INSURANCE_PAYMENT_AMOUNT_MISMATCH);
					}
					FabSerialNoResponse response = insuranceSF.getFabSerialNo(details.getPlanType());
					log.info("Plan type for fab serial no. {}", details.getPlanType());
					if(response.getResult().getStatus().equals("success")) {
						details.setFabSerialNo(response.getSno());
					}else {
						throw new AppException(ErrorCodes.SYS_TECHNICAL_ERROR);
					}
					details.setCustomerSource(T24CompanyCodes.findByCompanyCode(transferRequest.getAccountingUnitIdentifier()).getDescription());
					transferRequest.setInsuranceDetails(details);
					String receiverRef = settingsRepository.getAppSettingValue(details.getBrandCode()).getValue();
					transferRequest.setReceiverProductRef(receiverRef);
					transferRequest.setAccountingUnitIdentifier(ciRepository.getAccountUnitIdentifier(receiverRef));
					
				}
				//PBG:1863 MCSEND INDIA Update bene details
				
				if(transferRequest.getFundTransferType() == FundTransferTypes.INSTANT_FUNDS_TRANSFER && Objects.nonNull(transferRequest.getIsReceiverNameUpdated()) &&
						transferRequest.getIsReceiverNameUpdated() && Objects.nonNull(transferRequest.getBeneficiary())) {
					log.debug("Inside Bene update");
					CreateUpdateBeneficiaryRequest updateBeneficiaryRequest = createAutopay(transferRequest, false, false);
					updateBeneficiaryRequest.setIsMcSendBeneDetailUpdate(true);
					updateBeneficiaryRequest.setAutopayEnabled(false);
					updateBeneficiaryRequest.setBeneId(transferRequest.getBeneficiary().getId());
					createUpdateBeneficiaryServiceInvoker.update(updateBeneficiaryRequest);
					log.debug("Bene update done");

				}
				

				// Check if transfer date is future date then create SI with onetime frequency
				overrideBeneficiaryObj(transferRequest, sessionInfo.getUserId());
				

				//PRM-686
				//For old version of mobile app's prior to version 1.0.11, 
				//beneficiary bank address wasn't mandatory due to which transaction was getting reversed for FAB remit transaction
				//Block requests if beneficiary bank address isn't passed
				if(transferRequest.getFundTransferType() == FundTransferTypes.BANK_TO_BANK_FUNDS_TRANSFER){
					//Modify paymentDescription to replace with default purpose code for FAB Remit
					transferRequest.setTransferDescription(AppConstants.DEFAULT_SWIFT_PURPOSE_CODE);

					if(StringUtils.isBlank(transferRequest.getBeneficiary().getBankAddress1()) 
							|| StringUtils.isBlank(transferRequest.getBeneficiary().getBankAddress2())){
						throw new AppException(ErrorCodes.BENE_ADDRESS_NA);
					}
				}

				String destinationCurrency = getTransferCurrency(transferRequest);

				//Rule validation for card as funding source.
				if(Objects.nonNull(transferRequest.getSourceProductType()) && transferRequest.getSourceProductType() == ProductTypes.CARD) {
					final CardFundingSourceRule cardRule = staticDataRepository.getCreditCardAsFundingSourceRule(req.getFundTransferType().name());
					if(Objects.nonNull(cardRule)) {
						//check the rules
						if(!isValidCardTransfer(transferRequest, destinationCurrency, cardRule)) {
							throw new AppException(ErrorCodes.OPERATION_NOT_ALLOWED);
						}
					}
				} else {
					/*final List<AccountFundingSourceRule> accountRuleList = staticDataRepository.getAccountAsFundingSourceRule(req.getFundTransferType().name());
					if(Objects.nonNull(accountRuleList)) {
						AccountFundingSourceRule aedAcctRule = accountRuleList.stream().filter(rule -> rule.getTransferCurrency().equals(transferRequest.getSourceCurrency())).findFirst().get();
						AccountFundingSourceRule fcyAcctRule = accountRuleList.stream().filter(rule -> !rule.getTransferCurrency().equals(transferRequest.getSourceCurrency())).findFirst().get();
						log.info("aedAcctRule : {}",aedAcctRule);
						log.info("fcyAcctRule : {}",fcyAcctRule);*/

					/*if(transferRequest.getSourceCurrency().equals(aedAcctRule.getTransferCurrency())) {
							if(!isValidAccountTransfer(transferRequest, destinationCurrency, aedAcctRule)) {
								throw new AppException(ErrorCodes.OPERATION_NOT_ALLOWED);
							}
							} else if(!isValidAccountTransfer(transferRequest, destinationCurrency, fcyAcctRule)) {
								throw new AppException(ErrorCodes.OPERATION_NOT_ALLOWED);
							}
						}*/
					//}

					//TODO: Account funding source rule to be applied.
					if(transferRequest.getFundTransferType() == FundTransferTypes.WITHIN_BANK_FUNDS_TRANSFER) {
						final String creditAccountNo = Objects.nonNull(transferRequest.getBeneficiary())
								? StringUtils.isNotBlank(transferRequest.getBeneficiary().getAcctOrCardNo()) ? transferRequest.getBeneficiary().getAcctOrCardNo() : transferRequest.getReceiverProductRef()
										: transferRequest.getReceiverProductRef();

								//	log.info("getReceiverProductType="+transferRequest.getReceiverProductType().name());

								//	log.info("ProductTypes_CARD="+ProductTypes.CARD.name());

								if(Objects.nonNull(transferRequest.getReceiverProductType()) && transferRequest.getReceiverProductType().name().equals(ProductTypes.CARD.name())) {
									//	log.info("Inside Card check");
									if(StringUtils.isNotBlank(creditAccountNo) && Pattern.matches(AppConstants.CARD_REGEX, creditAccountNo) 
											&& StringUtils.isNotBlank(transferRequest.getSourceCurrency()) && !transferRequest.getSourceCurrency().equals(LOCAL_CURRENCY)) {
										throw new AppException(ErrorCodes.NONAED_ACCT_TO_CARD); 
									}
								}
								/**	if(StringUtils.isNotBlank(creditAccountNo) && Pattern.matches(AppConstants.CARD_REGEX, creditAccountNo) 
								&& StringUtils.isNotBlank(transferRequest.getSourceCurrency()) && !transferRequest.getSourceCurrency().equals(LOCAL_CURRENCY)) {
							throw new AppException(ErrorCodes.NONAED_ACCT_TO_CARD); 
						}	**/
					}
				}
				//7510 Defect changes
				if(transferRequest.getFundTransferType() == FundTransferTypes.WITHIN_BANK_FUNDS_TRANSFER) {
					String creditAccountNo = Objects.nonNull(transferRequest.getBeneficiary())
							? StringUtils.isNotBlank(transferRequest.getBeneficiary().getAcctOrCardNo()) ? transferRequest.getBeneficiary().getAcctOrCardNo() : transferRequest.getReceiverProductRef()
									: transferRequest.getReceiverProductRef();
							AccountDetails prdDtls = ciRepository.fetchBeneficiaryProductDetail(creditAccountNo);

							if(Objects.nonNull(prdDtls) && StringUtils.isNotBlank(prdDtls.getCompany()) && T24CompanyCodes.ISB.name().equals(prdDtls.getCompany())) {
								throw new AppException(ErrorCodes.BENE_ISLAMIC_FAB_ACC);
							}
				}
				if(Objects.nonNull(transferRequest.getSourceProductType()) && transferRequest.getSourceProductType() == ProductTypes.ACCOUNT
						&& transferRequest.getFundTransferType() != FundTransferTypes.OWN_ACCT_FUNDS_TRANSFER) {
					AccountDetails prdDtls = ciRepository.fetchBeneficiaryProductDetail(transferRequest.getSourceProductRef());
					if(Objects.nonNull(prdDtls) && StringUtils.isNotBlank(prdDtls.getCompany()) && T24CompanyCodes.ISB.name().equals(prdDtls.getCompany())) {
						throw new AppException(ErrorCodes.BENE_ISLAMIC_FAB_ACC);
					}
				}

				// only for own account transfer, convert the card ref to cardnumber.
				if((transferRequest.getFundTransferType() == FundTransferTypes.OWN_ACCT_FUNDS_TRANSFER
						|| transferRequest.getFundTransferType() == FundTransferTypes.CARD_PAYMENT_BY_ACCOUNT)
						&& Objects.nonNull(transferRequest.getReceiverProductType()) &&
						transferRequest.getReceiverProductType().compareTo(ProductTypes.CARD) == 0) {
					transferRequest.setReceiverProductRef(TextUtils.INSTANCE.getCardNumber(transferRequest.getReceiverProductRef()));
				}

				if(transferRequest.getFundTransferType() == FundTransferTypes.WITHIN_UAE_FUNDS_TRANSFER) {
					boolean isCityofBirthPresent = Objects.nonNull(transferRequest.getCityOfBirth()) && StringUtils.isNotBlank(transferRequest.getCityOfBirth());
					log.info("isCityofBirthPresent : {}",isCityofBirthPresent);
					transferRequest.setIPIRequest(transferServicesHelper.isIpiTransfer(transferRequest.getAmount(), transferRequest.getBeneficiary().getAcctOrCardNo(), transferRequest.getTransferCurrency(), transferRequest.getFundTransferType()));
					//IPP Fundr transfer
					transferRequest.setIPPRequest(transferServicesHelper.isIppTransfer(transferRequest.getAmount(),
							transferRequest.getBeneficiary().getAcctOrCardNo(), transferRequest.getTransferCurrency(),
							transferRequest.getFundTransferType()) && isCityofBirthPresent);
					log.info("IPP Rule flag in FundTransferSF : " + transferRequest.isIPPRequest());
					//PRM 8208 added fix to default charges for IPI and IPP
					if(transferRequest.isIPIRequest() || transferRequest.isIPPRequest()) {
						transferRequest.setChargeOption(ChargeType.SHA.name());
					}
					
					log.info("IPI Rule flag : " + transferRequest.isIPIRequest());
					
					//FMDB-117871
					
					if(transferRequest.getVersion() > 1) {
						if(Objects.nonNull(transferRequest.getBeneficiary()) 
								&& AMEX_BENE_SWIFTCODE.equalsIgnoreCase(transferRequest.getBeneficiary().getSwiftCode())
								&& !AppConstants.AED.equalsIgnoreCase(transferRequest.getTransferCurrency())							
								)
							throw new AppException(ErrorCodes.AMEX_BENE_INVALID_CURRENCY);
					}
				}


				boolean isCoolingPeriodApplicable = false;
				if(Objects.nonNull(transferRequest.getBeneficiary()) && StringUtils.isNotBlank(transferRequest.getBeneficiary().getStatus())) {
					if(ACTIVE.equals(transferRequest.getBeneficiary().getStatus())) {
						// Applicable for MB and IB
						isCoolingPeriodApplicable = false;
					} else {
						isCoolingPeriodApplicable = true;
					}
				} else {
					// Applicable for IB when Save and Pay flow
					int transferCoolingPeriod = settingsRepository.getTransferCoolingPeriod(transferRequest.getFundTransferType());
					if(transferCoolingPeriod > 0) {
						isCoolingPeriodApplicable = true;
					}
					log.info("Beneficiary is not Active and CoolingPeriod:{} and Create Beneficiary Flag: {}", isCoolingPeriodApplicable, transferRequest.getCreateBeneficiary());
				}
				boolean isFutureDatedTransfer = DateTimeHelper.INSTANCE.isFutureDate(transferRequest.getTransferDate(), DATE_DDMMYYYY);
				log.info("Fund Transfer: transferDate:{} and isFutureDated:{}, isCoolingPeriod:{}", transferRequest.getTransferDate(), isFutureDatedTransfer, isCoolingPeriodApplicable);
				
				if(transferRequest.getFundTransferType() == FundTransferTypes.IPO_SUBSCRIPTION || transferRequest.getFundTransferType() == FundTransferTypes.INSURANCE_PAYMENT) {
					isFutureDatedTransfer = false;
					isCoolingPeriodApplicable = false;
				}
				if (isFutureDatedTransfer || isCoolingPeriodApplicable /* && Objects.nonNull(transferRequest.getCreateBeneficiary()) && transferRequest.getCreateBeneficiary()*/ ) {
					//Modify paymentDescription to append purpose code
					//TICR-142: Purpose code changes
					if (FundTransferTypes.INTERNATIONAL_FUNDS_TRANSFER
							.compareTo(transferRequest.getFundTransferType()) == 0
							&& AppConstants.CURRENCY_INR.equalsIgnoreCase(destinationCurrency)) {
						String purposeCode = getPurposeCodeForSwiftInr(transferRequest);
						String txnPurposeCode = "/" + purposeCode + "/";
						transferRequest
						.setTransferDescription(txnPurposeCode + transferRequest.getTransferDescription());
					}
					final CreateUpdateBeneficiaryRequest beneficiaryRequest = createAutopay(transferRequest, isFutureDatedTransfer, isCoolingPeriodApplicable);
					CreateUpdateBeneficiaryResponse beneficiaryResponse;
					try {
						beneficiaryResponse = beneficiarySF.invokeCreateBeneficiary(beneficiaryRequest);
					}catch(AppException e) {
						if(ErrorCodes.SYS_TECHNICAL_ERROR.getCode().equalsIgnoreCase(e.getErrorCode().getCode()))
							throw new AppException(ErrorCodes.SYS_TECHNICAL_ERROR_002);
						throw e;
					}catch(Exception e) {
						log.error(e.getMessage());
						throw new AppException(ErrorCodes.SYS_TECHNICAL_ERROR_002);
					}
					if(beneficiaryResponse.getResult().isSuccess() && !isCoolingPeriodApplicable){
						// SUCCESS MESSAGE FOR AUTO BENEFICIARY
						Map<String, Object> msgArgs = new HashMap<>();
						msgArgs.put("nickName", StringUtils.trimToEmpty(beneficiaryRequest.getNickName()));
						msgArgs.put("txnDateTime", DateTimeHelper.INSTANCE.getCurrentDateForMessage(null));
						msgArgs.put("txnDesc", beneficiaryRequest.getTransferType().getTransferDesc());
						msgArgs.put("destAcc", TextUtils.INSTANCE.acctOrCardLast4Digits(beneficiaryRequest.getAccountOrCardNo()));
						msgArgs.put("destProductType", "Account/Card No.");
						msgArgs.put("transferCurrency", beneficiaryRequest.getTransferCurrency());
						msgArgs.put("startDate", transferRequest.getTransferDate());
						msgArgs.put("frequency", beneficiaryRequest.getAutopay().getFrequency());
						msgArgs.put("transferAmount", Double.toString(beneficiaryRequest.getAutoPayAmount()));

						if(FundTransferTypes.PAYIT_WALLET_TOPUP.compareTo(transferRequest.getFundTransferType()) == 0) {
							msgArgs.put("destAcc", TextUtils.INSTANCE.acctOrCardLast4Digits(beneficiaryRequest.getRemitInfo()));
							notificationService.processNotification(ContentID.PAYIT_SI_TRANSFER_ONETIME, sessionInfo, msgArgs);
						}else if(FundTransferTypes.EDIRHAM_TOPUP.compareTo(transferRequest.getFundTransferType()) == 0) {
							notificationService.processNotification(ContentID.EDIRHAM_SI_TRANSFER_ONETIME, sessionInfo, msgArgs);
						} 
						// **** FMDB-1143 DF Card Payment notification for onetime future dated SI setup
						else if(FundTransferTypes.DF_CARD_PAYMENT.compareTo(transferRequest.getFundTransferType()) == 0) {
							notificationService.processNotification(ContentID.DF_CARD_PAYMENT_SI_TRANSFER_ONETIME, sessionInfo, msgArgs);
						} 
						else {
							notificationService.processNotification(ContentID.SI_TRANSFER_ONETIME, sessionInfo, msgArgs);
						}
						/*notificationService.processNotification(ContentID.SI_TRANSFER_ONETIME,
								transferRequest.getFundTransferType().getTransferDesc(), sessionInfo,
								transferRequest.getFundTransferType().getTransferDesc(), beneficiaryRequest.getNickName(),
								beneficiaryRequest.getAccountOrCardNo(), Double.toString(beneficiaryRequest.getAutoPayAmount()),
								DateTimeHelper.INSTANCE.formatDate(transferRequest.getTransferDate(), DATE_DDMMYYYY , DATE_DDMMMYYYYHHMM),
								beneficiaryRequest.getTransferCurrency());*/
					} 
					/*else if(isCoolingPeriodApplicable) {
						int transferCoolingPeriod = settingsRepository.getTransferCoolingPeriod(beneficiaryRequest.getTransferType());
						if(transferCoolingPeriod > 0){
							// SMS/Email specific to cooling period
							Map<String, Object> msgArgs = new HashMap<>();
							msgArgs.put("nickName", StringUtils.trimToEmpty(beneficiaryRequest.getNickName()));
							msgArgs.put("txnDateTime", DateTimeHelper.INSTANCE.getCurrentDateForMessage(null));
							msgArgs.put("txnDesc",  beneficiaryRequest.getTransferType().getTransferDesc());
							msgArgs.put("destAcc", TextUtils.INSTANCE.acctOrCardLast4Digits(beneficiaryRequest.getAccountOrCardNo()));
							msgArgs.put("coolingPeriod", TextUtils.INSTANCE.getCoolingPeriod(transferCoolingPeriod));
							ContentID content = ContentID.getSuccessContentId(beneficiaryRequest.getTransferType().name(), BENEF_ADD, COOLING_PERIOD_SUCCESS);
							// TODO: BENEF_ADD notification message need to be changed to Fund transfer schedule message.
							notificationService.processNotification(content, SessionContext.getSession(), msgArgs);
						}
					}*/
					paymentResponse = new ExecutePaymentResponse();
					if (AppConstants.ERROR.equalsIgnoreCase(beneficiaryResponse.getResult().getStatus())
							&& ErrorCodes.SYS001_BENEFICIARY.getCode().equalsIgnoreCase(beneficiaryResponse.getResult().getErrorInfo().getCode()))
						beneficiaryResponse.getResult().setFailure(ErrorCodes.SYS001_REQUEST);
					paymentResponse.setResult(beneficiaryResponse.getResult());
				} else {
					log.info("Execute Fund Transfer:{}", transferRequest.getFundTransferType());
					//Validate sender and receiver count
					if(FundTransferTypes.SMS_CASH.compareTo(transferRequest.getFundTransferType()) == 0) {
						checkSmsCashLimit(transferRequest);
					} else if(FundTransferTypes.INTERNATIONAL_FUNDS_TRANSFER.compareTo(transferRequest.getFundTransferType()) == 0) {
						// Server side dual validation to verify again
						//validateAndOverrideSwiftOrRtCode(transferRequest);
						overrideSwiftOrRtCode(transferRequest);
						// Apply override routing code rules
						if(StringUtils.isNotBlank(transferRequest.getBeneficiary().getRoutingCode())) {
							String routingCode = applyOverrideRoutingRule(transferRequest.getBeneficiary().getRoutingCode(), transferRequest.getBeneficiary().getBankName());
							transferRequest.getBeneficiary().setRoutingCode(routingCode);	
						}

						if(LOCAL_CURRENCY.equals(destinationCurrency)) {
							transferRequest.getBeneficiary().setCorrBankBicCode(settingsRepository.getSetting(NOSTRO_ACCOUNT+ UNDERSCORE + LOCAL_CURRENCY));
						} else {
							List<CorrespondentBankDetails> correnpondentBankDetailList = fundTransferRepo.getCorrenpondentBankDetails(transferRequest.getBeneficiary().getCountry().getShortCode(), destinationCurrency, transferRequest.getBeneficiary().getSwiftCode());
							if(Objects.isNull(correnpondentBankDetailList) || correnpondentBankDetailList.isEmpty()) {
								log.error("Correspondent bank details not mapped for country:{} , and currency:{} ",transferRequest.getBeneficiary().getCountry().getShortCode() , destinationCurrency);
								apiResponse.setError(ErrorCodes.INT_TRANSFER_BANK_NOT_MAPPED,transferRequest.getBeneficiary().getCountry().getShortCode() , destinationCurrency );
								return apiResponse;
							}
							if (correnpondentBankDetailList.size() > 1) {
								overrideCorresBankDetails(transferRequest, correnpondentBankDetailList);
							} else {
								transferRequest.getBeneficiary().setCorrBankBicCode(PREFIX_SWIFT + correnpondentBankDetailList.get(0).getBicCode());
							}	
						}

						//Modify paymentDescription to append purpose code
						//TICR-142: Purpose code changes
						if (FundTransferTypes.INTERNATIONAL_FUNDS_TRANSFER
								.compareTo(transferRequest.getFundTransferType()) == 0
								&& destinationCurrency.equalsIgnoreCase(AppConstants.CURRENCY_INR)) {
							String purposeCode = getPurposeCodeForSwiftInr(transferRequest);
							String txnPurposeCode = "/" + purposeCode + "/";
							transferRequest
							.setTransferDescription(txnPurposeCode + transferRequest.getTransferDescription());
						}
					} else if(FundTransferTypes.WITHIN_UAE_FUNDS_TRANSFER.compareTo(transferRequest.getFundTransferType()) == 0) {
						if(!LOCAL_CURRENCY.equalsIgnoreCase(transferRequest.getTransferCurrency())) {
							List<CorrespondentBankDetails> correnpondentBankDetailList = fundTransferRepo.getCorrenpondentBankDetails(AppConstants.COUNTRY_AE, transferRequest.getTransferCurrency(), transferRequest.getBeneficiary().getSwiftCode());
							if(Objects.isNull(correnpondentBankDetailList) || correnpondentBankDetailList.isEmpty()) {
								log.error("Correspondent bank details not mapped for country:{} , and currency:{} ",AppConstants.COUNTRY_AE , transferRequest.getTransferCurrency());
								apiResponse.setError(ErrorCodes.INT_TRANSFER_BANK_NOT_MAPPED, AppConstants.COUNTRY_AE , transferRequest.getTransferCurrency() );
								return apiResponse;
							}
							if (correnpondentBankDetailList.size() > 1) {
								overrideCorresBankDetails(transferRequest, correnpondentBankDetailList);
							} else {
								transferRequest.getBeneficiary().setCorrBankBicCode(PREFIX_SWIFT + correnpondentBankDetailList.get(0).getBicCode());
							}
						}

					}

					// PBG:1613 Adding charges in amount and modifyring transfer object
					if (FundTransferTypes.EDIRHAM_TOPUP.compareTo(transferRequest.getFundTransferType()) == 0) {
						setChargeInAmount(transferRequest, edirhamCardDetails);
					}
					//Reporting changes - when SAVE and PAY.
					if (Objects.nonNull(transferRequest.getCreateBeneficiary()) && transferRequest.getCreateBeneficiary()) {
						transferRequest.getBeneficiary().setCreatedOn(new Date());
						transferRequest.getBeneficiary().setCreatedChannel(sessionInfo.getChannelName());
					}

					enrichReceiverProductType(transferRequest); // to identify receiver is card or account for within FAB

					/*		if(transferRequest.getFundTransferType() == FundTransferTypes.WITHIN_UAE_FUNDS_TRANSFER) {
						transferRequest.setIPIRequest(ipiTransferHelper.isIpiTransfer(transferRequest.getAmount(), transferRequest.getBeneficiary().getAcctOrCardNo(), transferRequest.getTransferCurrency(), transferRequest.getFundTransferType()));	
					}*/
					paymentResponse = transferServiceInvoker.executeFundTransfer(transferRequest);
					if (paymentResponse.getResult().isSuccess()) {
						if(transferRequest.getFundTransferType() == FundTransferTypes.EDIRHAM_TOPUP) {
							ValidatePPCTopupDataAreaRequest edirhamProcessPPCTopupRequest = new ValidatePPCTopupDataAreaRequest();
							enrichPocessE11TopupRequest(edirhamProcessPPCTopupRequest,transferRequest);
							ValidatePPCTopupResposne edirhamTopupResponse = edirhamServiceInvoker.validatePPCTopup(edirhamProcessPPCTopupRequest);
							if(!(Objects.nonNull(edirhamTopupResponse) && Objects.nonNull(edirhamTopupResponse.getProcessPPCTopUpRes())
									&& Objects.nonNull(edirhamTopupResponse.getProcessPPCTopUpRes().getDataAreaProcessPPCTopUpRes())
									&& Objects.nonNull(edirhamTopupResponse.getProcessPPCTopUpRes().getDataAreaProcessPPCTopUpRes().getChangeStatus())
									&& Objects.nonNull(edirhamTopupResponse.getProcessPPCTopUpRes().getDataAreaProcessPPCTopUpRes().getChangeStatus().getReasonCode())
									&& (edirhamTopupResponse.getProcessPPCTopUpRes().getDataAreaProcessPPCTopUpRes().getChangeStatus().getReasonCode()==0))){
								log.info("Process PPC Top up failed, calling transaction reversal"+paymentResponse);
								transferServiceInvoker.executeCancelPaymentForEdirham(paymentResponse);
								paymentResponse.setError(ErrorCodes.TRANSFER_FAILED_FOR_EDIRHAM);
								return paymentResponse;
							}
							//5307 changes
						} else if(transferRequest.getFundTransferType() == FundTransferTypes.IPO_SUBSCRIPTION) {
							log.info("inside IPO subscription");
							try {
								IPOSubscriptionAudit ipoAudit = new IPOSubscriptionAudit();
								IPOSubscriptionDataAreaRequest ipoSubsRequest = new IPOSubscriptionDataAreaRequest();
								enrichIPOSubscriptionDataAreaRequest(ipoSubsRequest, transferRequest, paymentResponse);
								insertIPOTransferAudit(transferRequest, paymentResponse, null, INITIATED);
								IPOSubscriptionAPIResponse ipoSubscriptionResponse = ipoServiceInvoker
										.ipoSubscription(ipoSubsRequest);

								// check payment staus
								if (ipoSubscriptionResponse.getResult().isSuccess()
										&& Objects.nonNull(ipoSubscriptionResponse.getDataArea()) && Objects.nonNull(
												ipoSubscriptionResponse.getDataArea().getApplicationNumber())) {
									paymentResponse.setApplicationNumber(
											ipoSubscriptionResponse.getDataArea().getApplicationNumber());
									ipoRepository.updateIpoAudit(ipoSubscriptionResponse.getDataArea().getApplicationNumber(), AppConstants.SUCCESS_CAPS);

								} else {
									log.info("Getting error from IPO Subscription service" + paymentResponse);
									transferServiceInvoker.executeCancelPaymentForEdirham(paymentResponse);
									ipoRepository.updateIpoAudit(null, AppConstants.FAILED);
									paymentResponse.setError(ErrorCodes.IPO_SUBMISSION_FAILED);
								}

							} catch (Exception e) {
								log.info("Exception occured from IPO Subscription service");
								transferServiceInvoker.executeCancelPaymentForEdirham(paymentResponse);
								ipoRepository.updateIpoAudit(null, AppConstants.FAILED);
								paymentResponse.setError(ErrorCodes.IPO_SUBMISSION_FAILED);
							}
						}else if(transferRequest.getFundTransferType() == FundTransferTypes.INSURANCE_PAYMENT) {
							String narration = transferRequest.getInsuranceDetails().getFabSerialNo() + "/" + transferRequest.getInsuranceDetails().getBrandCode() + "/MB";
							updateInsuranceDbAudit(transferRequest, paymentResponse, InsuranceAppStatus.PAYMENT_T24_SUCCESS, narration, null);
							IssuePolicyRequest issuePolicyRequest = new IssuePolicyRequest();
							issuePolicyRequest.setJourneyReferenceId(transferRequest.getInsuranceDetails().getJourneyReferenceId());
							issuePolicyRequest.setTransactionStatus("SUCCESS");
							issuePolicyRequest.setModeOfPayment(transferRequest.getSourceProductType().name());
							issuePolicyRequest.setTransactionNarration(narration);
							InsuranceDetailsResponse response = convertIssuePolicyResponse(insuranceSF.issuePolicy(issuePolicyRequest));
							if("FAILURE".equalsIgnoreCase(response.getStatus()) || "error".equalsIgnoreCase(response.getStatus())) {
								transferServiceInvoker.reverseInsurancePayment(transferRequest, paymentResponse);
								updateInsuranceDbAudit(transferRequest, paymentResponse, InsuranceAppStatus.PAYMENT_CONFM_PARTNER_FAILED, narration, "FAILED");
								paymentResponse.setError(ErrorCodes.SYS_DEFAULT_ERROR);
							}else if("IN_PROGRESS".equalsIgnoreCase(response.getStatus())) {
								updateInsuranceDbAudit(transferRequest, paymentResponse, null, narration, "IN_PROGRESS");
								paymentResponse.setError(ErrorCodes.TRV_INS_POLICY_IN_PROGRESS);
								notifyPaymentSuccess(transferRequest, paymentResponse, sessionInfo);
							}
							paymentResponse.setInsuranceDetails(response);
						}
					}
				}
				final String cin = sessionInfo.getUser().getCin();
				if (paymentResponse.getResult().isSuccess()) {

					// CALL ACCRUAL API FOR REMITTANCE
					try
					{
						String enableCollinsionFlag = settingsRepository.getSetting(AppConstants.ENABLE_COLLINSION);
						if(Objects.nonNull(enableCollinsionFlag) && "TRUE".equalsIgnoreCase(enableCollinsionFlag)) {
							log.info(" Collinson is enabled...Calling accrual api");
							callAccrualAPI(transferRequest, paymentResponse);
							log.info("Accrual api call ends ");
						}
					}catch(Exception exception)					{
						log.info("Error while calling accural{}",exception);
					}

					super.deleteTxnSession(transferRequest);
					// SUCCESS MESSAGE FOR TRANSFER ONLY IF THE TRANSFER DATE IS NOT FUTURE DATED
					if (!isFutureDatedTransfer && !isCoolingPeriodApplicable) {
						//mqNotifier.refreshCustomerPositionCache(cin);
						String key = AppConstants.CUSTOMER_POS_KEY + cin;
						cacheHelper.removeCustomerPositionCache(key);

						/*if(transferRequest.getFundTransferType() == FundTransferTypes.CARD_PAYMENT_BY_ACCOUNT ||
								(Objects.nonNull(transferRequest.getSourceProductType()) && transferRequest.getSourceProductType() == ProductTypes.CARD)){
							mqNotifier.refreshCustomerPositionCache(cin, AppConstants.CUST_POSITION_CARD);
						} else if(Objects.nonNull(transferRequest.getSourceProductType()) && transferRequest.getSourceProductType() == ProductTypes.ACCOUNT) {
							mqNotifier.refreshCustomerPositionCache(cin, AppConstants.CUST_POSITION_ACCOUNT);
						}*/
						// Override transaction currency in response after receiving the response from T24
						if(StringUtils.isNotBlank(transferRequest.getSourceCurrency()) && Objects.nonNull(paymentResponse.getBalanceForFundingSource())) {
							paymentResponse.getBalanceForFundingSource().setCurrency(transferRequest.getSourceCurrency());
						}
						if(StringUtils.isNotBlank(transferRequest.getReceiverCurrency()) && Objects.nonNull(paymentResponse.getBalanceForCreditAccount())) {
							paymentResponse.getBalanceForCreditAccount().setCurrency(destinationCurrency);
						}

						//INSERTING IN TRANSFER DETAILS FOR AUDIT
						/*try{
							fundTransferRepo.insertTransferDetails(transferRequest,paymentResponse);
						} catch (Exception e){
							log.error("Error while inserting transfer details in audit table:{}", e);
						}*/ //Migrated to Mongo
						notifyPaymentSuccess(transferRequest, paymentResponse, sessionInfo);

						try {
							final TransactionAudit txnAudit = enrichTransferAudit(transferRequest, paymentResponse,
									sessionInfo);
							//changed as part of Mongo to Oracle migration
							//transferPaymentAuditSF.captureRequest(TRANSFER, sessionInfo.getUserId(), txnAudit);
							transferPaymentAuditSF.captureTxnAuditRequest(TRANSFER, sessionInfo.getUserId(), txnAudit);

							if (Objects.nonNull(txnAudit) && Objects.nonNull(txnAudit.getTransferType())
									&& (FundTransferTypes.INSTANT_FUNDS_TRANSFER
											.compareTo(txnAudit.getTransferType()) == 0
											|| Objects.nonNull(txnAudit) && Objects.nonNull(txnAudit.getTransferType())
											&& FundTransferTypes.WALLET_TRANSFER
											.compareTo(txnAudit.getTransferType()) == 0
											|| Objects.nonNull(txnAudit) && Objects.nonNull(txnAudit.getTransferType())
											&& FundTransferTypes.INTERNATIONAL_FUNDS_TRANSFER
											.compareTo(txnAudit.getTransferType()) == 0
											|| Objects.nonNull(txnAudit) && Objects.nonNull(txnAudit.getTransferType())
											&& FundTransferTypes.BANK_TO_BANK_FUNDS_TRANSFER
											.compareTo(txnAudit.getTransferType()) == 0)) {

//								transferPaymentAuditSF.captureRequestForInstantAndWalletTransfer(
//										INSTANT_AND_WALLET_TRANSFER, sessionInfo.getUserId(), txnAudit);
								transferPaymentAuditSF.captureTxnAuditRequest(INSTANT_AND_WALLET_TRANSFER, sessionInfo.getUserId(), txnAudit);
							} else if (FundTransferTypes.INTERNATIONAL_FUNDS_TRANSFER
									.compareTo(transferRequest.getFundTransferType()) == 0
									|| FundTransferTypes.BANK_TO_BANK_FUNDS_TRANSFER
									.compareTo(transferRequest.getFundTransferType()) == 0) {
								enrichB2BandInternationAudit(transferRequest, txnAudit);

								log.info("FundTransferType::TransactionAudit after enrichB2BandInternationAudit : ");

//								transferPaymentAuditSF.captureRequestForInstantAndWalletTransfer(
//										INSTANT_AND_WALLET_TRANSFER, sessionInfo.getUserId(), txnAudit);
								transferPaymentAuditSF.captureTxnAuditRequest(INSTANT_AND_WALLET_TRANSFER, sessionInfo.getUserId(), txnAudit);
							}
						} catch (Exception ex) {
							log.error("Error while udpating txn session : ", ex);
						}

					}

					// CREATE BENEFICIARY
					if (Objects.nonNull(transferRequest.getCreateBeneficiary()) && transferRequest.getCreateBeneficiary()) {
						CreateUpdateBeneficiaryResponse benefCreation  = creteBeneficiaryAndNotify(transferRequest, sessionInfo, isCoolingPeriodApplicable);
						if(Objects.nonNull(benefCreation)) return benefCreation;
					} else if(Objects.nonNull(transferRequest.getBeneficiary())) {
						updateBeneficiaryDetails(transferRequest, destinationCurrency);
					}

					// CREATE AUTO BENEFICIARY
					if (Objects.nonNull(transferRequest.getCreateAutopay()) && transferRequest.getCreateAutopay()) {
						CreateUpdateBeneficiaryResponse recurringTransfer  = createRecurringTransferAndNotify(transferRequest, sessionInfo, isCoolingPeriodApplicable);
						if(Objects.nonNull(recurringTransfer)) return recurringTransfer;
					}
				}
				// Start of PRM-4775_IBMB_DUPLICATE_TRANSFER_ISSUE fix
				if(AppConstants.ERROR.equalsIgnoreCase(paymentResponse.getResult().getStatus())) {
					if(Objects.nonNull(paymentResponse.getResult().getErrorInfo()) &&"TRANSFER_FAILED".equalsIgnoreCase(paymentResponse.getResult().getErrorInfo().getCode()))
					{
						log.info(" inside the TRANSFER_FAILED scenario");
						super.deleteTxnSession(transferRequest);
						//mqNotifier.refreshCustomerPositionCache(sessionInfo.getUser().getCin());
						String key = AppConstants.CUSTOMER_POS_KEY + cin;
						cacheHelper.removeCustomerPositionCache(key);
					}	
				  }
				//End of PRM-4775_IBMB_DUPLICATE_TRANSFER_ISSUE fix
				
				if(FundTransferTypes.EDIRHAM_TOPUP.compareTo(transferRequest.getFundTransferType()) == 0 && Objects.nonNull(paymentResponse) &&
						Objects.nonNull(paymentResponse.getResult()) && Objects.nonNull(paymentResponse.getResult().getErrorInfo())&&
						Objects.nonNull(paymentResponse.getResult().getErrorInfo().getCode()) &&
						paymentResponse.getResult().getErrorInfo().getCode().equalsIgnoreCase(ErrorCodes.TRANSFER_FAILED.getCode())) {
					paymentResponse.setError(ErrorCodes.TRANSFER_FAILED_FOR_EDIRHAM);
				}
				if(FundTransferTypes.IPO_SUBSCRIPTION.compareTo(transferRequest.getFundTransferType()) == 0 && Objects.nonNull(paymentResponse) &&
						Objects.nonNull(paymentResponse.getResult()) && Objects.nonNull(paymentResponse.getResult().getErrorInfo())&&
						Objects.nonNull(paymentResponse.getResult().getErrorInfo().getCode()) &&
						paymentResponse.getResult().getErrorInfo().getCode().equalsIgnoreCase(ErrorCodes.TRANSFER_FAILED.getCode())) {
					insertIPOTransferAudit(transferRequest, paymentResponse,
							 null,AppConstants.FAILED);	
					paymentResponse.setError(ErrorCodes.IPO_SUBMISSION_FAILED);
				}
				if(FundTransferTypes.INSURANCE_PAYMENT.compareTo(transferRequest.getFundTransferType()) == 0 && Objects.nonNull(paymentResponse) &&
						Objects.nonNull(paymentResponse.getResult()) && Objects.nonNull(paymentResponse.getResult().getErrorInfo())&&
						Objects.nonNull(paymentResponse.getResult().getErrorInfo().getCode()) &&
						paymentResponse.getResult().getErrorInfo().getCode().equalsIgnoreCase(ErrorCodes.TRANSFER_FAILED.getCode())) {
					
					IssuePolicyRequest issuePolicyRequest = new IssuePolicyRequest();
					issuePolicyRequest.setJourneyReferenceId(transferRequest.getInsuranceDetails().getJourneyReferenceId());
					issuePolicyRequest.setTransactionStatus("FAILURE");
					issuePolicyRequest.setModeOfPayment(transferRequest.getSourceProductType().name());
					String narration = transferRequest.getInsuranceDetails().getFabSerialNo() + "/" + transferRequest.getInsuranceDetails().getBrandCode() + "/MB";
					issuePolicyRequest.setTransactionNarration(narration);
					updateInsuranceDbAudit(transferRequest, paymentResponse, InsuranceAppStatus.PAYMENT_T24_FAILED, narration, null);
					if (paymentResponse != null && paymentResponse.getResult() != null
							&& paymentResponse.getResult().getErrorInfo() != null) {
						issuePolicyRequest.setErrorResponseMessages(paymentResponse.getResult().getErrorInfo().getDesc());
					}

					paymentResponse.setInsuranceDetails(convertIssuePolicyResponse(insuranceSF.issuePolicy(issuePolicyRequest)));
					paymentResponse.setError(ErrorCodes.INSURANCE_PAYMENT_FAILED);
				}
				if(isFutureDatedTransfer) {
					paymentResponse.setNextExecutionDate(transferRequest.getTransferDate());
				} else if(Objects.nonNull(transferRequest.getCreateAutopay()) && transferRequest.getCreateAutopay()) {
					Date paymentDate = new Date();
					if(StringUtils.isNotBlank(transferRequest.getTransferDate())) {
						paymentDate = DateTimeHelper.INSTANCE.formatDate(transferRequest.getTransferDate(), DATE_DDMMYYYY);
					} 
					paymentResponse.setNextExecutionDate(DateTimeHelper.INSTANCE.getNextRunOnDate(paymentDate, Frequency.getFrequency(transferRequest.getAutopay().getFrequency()), null)); 
				}
				return paymentResponse;
			}
			
			return authResponse;
		});
	}


Initial State

Transfer Advice for transactions are only available for Swift / International Transfers

Target State: 

In addition to Swift/ Intenational payments, the advice will also be provided to  Within Bank and within UAE transfers.

Solution steps:

1)User submits the transaction

2) Transaction is completed successfully

3) PDF generation logic should be triggered, and the pdf created will be sent as an attachment in the notification email (existing notification email will be used to send the attachment and minor modification in the email content will be there). The template required will be put in content_item table.

4) /document/v1/generate: This service is to be modified and used for PDF generation. For password protection, an optional field with the password value will be sent in request and logic needs to be added to read the variable. If the variable has password value, then password protection with the mentioned password need to be implemented on the generated pdf file. If not, then BAU logic (without password protection) will be used.

When sending the email for sending advice post successful transactions, all the details of transaction can obtained from java beans. 

 Mappings

 

Field in Advice	Object	Attribute
Amount	com.fab.pb.services.paymentNtransfers.requests.ExecuteTransferRequest	amount
Charge Including VAT	com.fab.pb.services.paymentNtransfers.responses.FetchFTChargeResponse	com.fab.pb.models.List<Charge> chargeList  -- charge and tax amount of the first element . Add both.
Transaction date	com.fab.pb.services.paymentNtransfers.requests.ExecuteTransferRequest	transferDate | Alt : date at which the transaction is executed
Transaction Reference	com.fab.pb.services.paymentNtransfers.responses.ExecutePaymentResponse	transactionRefNo (FTNumber needs to be shown)
Transfer Description 	com.fab.pb.services.paymentNtransfers.requests.ExecuteTransferRequest	transferDescription



From : Sender 	com.fab.pb.models. User	User user = SessionContext.getSession().getUser()

get details from this object for name . Use 'name' and 'salutation' fields
Sender account number/card number	com.fab.pb.services.paymentNtransfers.requests.ExecuteTransferRequest	sourceProductRef
From Bank 	
will always default to 'First Abu Dhabi Bank'



Beneficiary	
com.fab.pb.services.paymentNtransfers.requests.ExecuteTransferRequest --> com.fab.pb.models.bo.Beneficiary
Beneficiary Name	com.fab.pb.models.bo.Beneficiary	name
Beneficiary IBAN/Card number	com.fab.pb.models.bo.Beneficiary	acctOrCardNo
Beneficiary bank	com.fab.pb.models.bo.Beneficiary	bankName
  

The attachment in pdf format should be password protected (similar to stamped statements: Last 4 digits of the account followed by the 4 digits representing the day and month of birthday) before sending as it has secure client information.



Additionally email content needs to be updated as mentioned in story.

import software.amazon.awscdk.Duration;
import software.amazon.awscdk.Stack;
import software.amazon.awscdk.StackProps;
import software.amazon.awscdk.services.ec2.*;
import software.amazon.awscdk.services.events.targets.LambdaFunction;
import software.amazon.awscdk.services.iam.IRole;
import software.amazon.awscdk.services.iam.Role;
import software.amazon.awscdk.services.kms.IKey;
import software.amazon.awscdk.services.kms.Key;
import software.amazon.awscdk.services.lambda.*;
import software.amazon.awscdk.services.lambda.destinations.S3EventSource;
import software.amazon.awscdk.services.lambda.notifications.NotificationKeyFilter;
import software.amazon.awscdk.services.s3.Bucket;
import software.amazon.awscdk.services.s3.IBucket;
import software.amazon.awscdk.services.s3.notifications.LambdaDestination;
import software.amazon.awscdk.services.s3.events.S3EventSource;
import software.amazon.awscdk.services.s3.eventsource.NotificationKeyFilter;
import software.constructs.Construct;

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

public class SanctionCountryReportS3LambdaStack extends Stack {

    public SanctionCountryReportS3LambdaStack(final Construct scope, final String id) {
        this(scope, id, null);
    }

    public SanctionCountryReportS3LambdaStack(final Construct scope, final String id, final StackProps props) {
        super(scope, id, props);

        CfnParameter envParameter = new CfnParameter(this, "env",
                CfnParameterProps.builder().defaultValue("local").build());
        CfnParameter regionParameter = new CfnParameter(this, "region",
                CfnParameterProps.builder().defaultValue("me-central-1").build());
        CfnParameter accountIdParameter = new CfnParameter(this, "account",
                CfnParameterProps.builder().defaultValue("517606038493").build());
        CfnParameter kmsAccountIdParameter = new CfnParameter(this, "kms-account",
                CfnParameterProps.builder().defaultValue("644749578616").build());

        CfnParameter vpcIdParameter = new CfnParameter(this, "vpcId",
                CfnParameterProps.builder().type("AWS::EC2::VPC::Id").build());
        CfnParameter appSubnetIdsParameter = new CfnParameter(this, "appSubnetIds",
                CfnParameterProps.builder().type("List<AWS::EC2::Subnet::Id>").build());

        CfnParameter xksKeyIdParameter = new CfnParameter(this, "xksKeyId",
                CfnParameterProps.builder().defaultValue("cc63e70e-6095-42fa-9fa0-a7c20a726de9").build());

        CfnParameter s3BucketParameter = new CfnParameter(this, "s3Bucket",
                CfnParameterProps.builder().defaultValue("ibmb-gfri-reports").build());

        CfnParameter s3bucketPathParameter = new CfnParameter(this, "bucketPath",
                CfnParameterProps.builder().defaultValue("negative-country-phase0/input/").build());

        // Lambda Configuration parameters
        CfnParameter memorySizeParameter = new CfnParameter(this, "memorySize",
                CfnParameterProps.builder().type("Number").defaultValue("128").build());
        CfnParameter lambdaTimeoutParameter = new CfnParameter(this, "timeout-seconds",
                CfnParameterProps.builder().type("Number").defaultValue("60").build());
        CfnParameter deploymentBucketParameter = new CfnParameter(this, "deployment-bucket",
                CfnParameterProps.builder().defaultValue("ibmb-ms-deployment-dev-uae").build());
        CfnParameter deploymentFileParameter = new CfnParameter(this, "deployment-file-name", CfnParameterProps
                .builder().defaultValue("lambda/deployment/sanction-country-report_v1.zip").build());
        CfnParameter layerVersionParameter = new CfnParameter(this, "python-layer-version",
                CfnParameterProps.builder().defaultValue("20").build());

        // Environment variables for Lambda function
        CfnParameter certificatePasswordParameter = new CfnParameter(this, "certificate-password",
                CfnParameterProps.builder().defaultValue("xxxxx").build());
        CfnParameter toAddressParameter = new CfnParameter(this, "to-address",
                CfnParameterProps.builder().defaultValue("vishal.jagtap@bankfab.com").build());
        CfnParameter fetchCinCifByRefIdServiceUrlParameter = new CfnParameter(this, "fetch-cin-cif-service-url", CfnParameterProps.builder()
                .defaultValue("https://api-sit.digital-ibmb-dev.aeapps.bankfab.com/pbdb/v1/customer/cust-id-info").build());
        CfnParameter sendEmailServiceUrlParameter = new CfnParameter(this, "send-email-service-url", CfnParameterProps.builder()
                .defaultValue("https://kproxy-uat.pcdigital-dev.aeapps.bankfab.com/NotificationService/nsapi/email/sendemail").build());
        CfnParameter getCustDetailsServiceUrlParameter = new CfnParameter(this, "get_customer_details", CfnParameterProps.builder()
                .defaultValue("https://dpuat.bankfab.com:2038/customeronboarding/v2/customer-details").build());

        String env = envParameter.getValueAsString();
        String region = regionParameter.getValueAsString();
        String account = accountIdParameter.getValueAsString();
        String kmsAccount = kmsAccountIdParameter.getValueAsString();
        String s3Arn = "arn:aws:s3:::" + s3BucketParameter.getValueAsString();
        String s3BucketPath = s3bucketPathParameter.getValueAsString();

        String vpcId = vpcIdParameter.getValueAsString();
        List<String> subnetIds = appSubnetIdsParameter.getValueAsList();

        String xksKeyId = xksKeyIdParameter.getValueAsString();

        Number memorySize = memorySizeParameter.getValueAsNumber();
        Number lambdaTimeout = lambdaTimeoutParameter.getValueAsNumber();
        String deploymentBucketName = deploymentBucketParameter.getValueAsString();
        String deploymentFileKey = deploymentFileParameter.getValueAsString();
        String layerVersion = layerVersionParameter.getValueAsString();

        String certificatePassword = certificatePasswordParameter.getValueAsString();
        String toAddress = toAddressParameter.getValueAsString();
        String fetchCinCifByRefIdServiceUrl = fetchCinCifByRefIdServiceUrlParameter.getValueAsString();
        String sendEmailServiceUrl = sendEmailServiceUrlParameter.getValueAsString();
        String getCustomerDetailsUrl = getCustDetailsServiceUrlParameter.getValueAsString();

        Map<String, String> lambdaEnvVariableMap = getEnvVariableMap(env, certificatePassword,
                toAddress, fetchCinCifByRefIdServiceUrl, sendEmailServiceUrl, getCustomerDetailsUrl);

        IKey kmsKey = Key.fromKeyArn(this, "kmsKey", "arn:aws:kms:" + region + ":" + kmsAccount + ":key/" + xksKeyId);

        ILayerVersion lambdaLayerVersion = LayerVersion.fromLayerVersionArn(this, "lambda-py-layer",
                "arn:aws:lambda:" + region + ":" + account + ":layer:lambda-py-layer:" + layerVersion);

        IBucket ibucket = Bucket.fromBucketArn(this, "negative-country-report-bucket", s3Arn);

        IRole scReportRole = Role.fromRoleName(this, "scReportRoleId", "sc-report-role-iam-lambda-" + env);

        Function sanctionCountryReportFunction = sanctionCountryReportFunction(id, env, vpcId, subnetIds,
                memorySize, lambdaTimeout, deploymentBucketName, deploymentFileKey, lambdaLayerVersion, kmsKey,
                scReportRole, lambdaEnvVariableMap);

        // Grant Lambda function read access to the S3 bucket
        ibucket.grantRead(sanctionCountryReportFunction);

        // Add an event notification for when an object is created in the S3 bucket
        ibucket.addEventNotification(S3EventSource.OBJECT_CREATED, new LambdaDestination(sanctionCountryReportFunction),
                NotificationKeyFilter.builder()
                        .prefix(s3BucketPath)
                        .suffix(".csv")
                        .build());
    }

    private Function sanctionCountryReportFunction(String id, String env, String vpcId, List<String> subnetIds,
                                                   Number memorySize, Number lambdaTimeout, String deploymentBucketName, String deploymentFileKey,
                                                   ILayerVersion lambdaLayerVersion, IKey xksKey, IRole sanctionCountryReportRole, Map<String, String> lambdaEnvVariableMap) {

        return new Function(this, "sanction-country-report", FunctionProps.builder()
                .functionName("Sanction-Country-Report-" + env)
                .runtime(Runtime.PYTHON_3_9)
                .role(sanctionCountryReportRole)
                .environmentEncryption(xksKey)
                .code(Code.fromBucket(Bucket.fromBucketName(this, "function_deploymnet_bucket", deploymentBucketName),
                        deploymentFileKey))
                .handler("lambda.handler")
                .memorySize(memorySize)
                .timeout(Duration.seconds(lambdaTimeout))
                .environment(lambdaEnvVariableMap)
                .layers(Collections.singletonList(lambdaLayerVersion))
                .currentVersionOptions(VersionOptions.builder().description("v1")
                        .removalPolicy(RemovalPolicy.RETAIN).build())
                .vpc(Vpc.fromVpcAttributes(this, id,
                        VpcAttributes.builder().vpcId(vpcId).availabilityZones(getAvailabilityZones()).build()))
                .vpcSubnets(SubnetSelection.builder().subnets(getAppSubnetList(subnetIds)).build()).build());
    }

    public Map<String, String> getEnvVariableMap(String env, String certificatePassword,
                                                 String toAddress, String fetchCinCifByRefIdServiceUrl, String sendEmailServiceUrl, String getCustomerDetailsUrl) {
        Map<String, String> map = new HashMap<>();
        String path = "/var/task/ssl/".concat(env);

        map.put("CERT_PASSWORD", certificatePassword);
        map.put("CLIENT_CERT", path.concat("/client.crt"));
        map.put("SERVER_KEY", path.concat("/client.key"));
        map.put("CA_CERT", path.concat("/certificate.pem"));
        map.put("TO_ADDRESS", toAddress);
        map.put("FETCH_CIN_CIF_BY_REFID_URL", fetchCinCifByRefIdServiceUrl);
        map.put("SEND_EMAIL_SERVICE_URL", sendEmailServiceUrl);
        map.put("GET_CUSTOMER_DETAILS", getCustomerDetailsUrl);

        return map;
    }

    private List<ISubnet> getAppSubnetList(List<String> subnetIds) {
        List<ISubnet> subnetList = new ArrayList<>();
        AtomicInteger counter = new AtomicInteger(0);
        subnetIds.forEach(
                subnet -> subnetList.add(Subnet.fromSubnetId(this, "subnet" + counter.incrementAndGet(), subnet)));
        return subnetList;
    }

}


-------------------------------------------

public class SanctionCountryReportS3LambdaStack extends Stack {

	public SanctionCountryReportS3LambdaStack(final Construct scope, final String id) {
		this(scope, id, null);
	}

	public SanctionCountryReportS3LambdaStack(final Construct scope, final String id, final StackProps props) {
		super(scope, id, props);

		CfnParameter envParameter = new CfnParameter(this, "env",
				CfnParameterProps.builder().defaultValue("local").build());
		CfnParameter regionParameter = new CfnParameter(this, "region",
				CfnParameterProps.builder().defaultValue("me-central-1").build());
		CfnParameter accountIdParameter = new CfnParameter(this, "account",
				CfnParameterProps.builder().defaultValue("517606038493").build());
		CfnParameter kmsAccountIdParameter = new CfnParameter(this, "kms-account", 
        		CfnParameterProps.builder().defaultValue("644749578616").build());
		
		CfnParameter vpcIdParameter = new CfnParameter(this, "vpcId",
				CfnParameterProps.builder().type("AWS::EC2::VPC::Id").build());
		CfnParameter appSubnetIdsParameter = new CfnParameter(this, "appSubnetIds",
				CfnParameterProps.builder().type("List<AWS::EC2::Subnet::Id>").build());

		CfnParameter xksKeyIdParameter = new CfnParameter(this, "xksKeyId",
				CfnParameterProps.builder().defaultValue("cc63e70e-6095-42fa-9fa0-a7c20a726de9").build());
		
		CfnParameter s3BucketParameter = new CfnParameter(this, "s3Bucket",
				CfnParameterProps.builder().defaultValue("ibmb-gfri-reports").build());
		
		CfnParameter s3bucketPathParameter = new CfnParameter(this, "bucketPath",
				CfnParameterProps.builder().defaultValue("negative-country-phase0/input/").build());

		// Lambda Configuration parameters
		CfnParameter memorySizeParameter = new CfnParameter(this, "memorySize",
				CfnParameterProps.builder().type("Number").defaultValue("128").build());
		CfnParameter lambdaTimeoutParameter = new CfnParameter(this, "timeout-seconds",
				CfnParameterProps.builder().type("Number").defaultValue("60").build());
		CfnParameter deploymentBucketParameter = new CfnParameter(this, "deployment-bucket",
				CfnParameterProps.builder().defaultValue("ibmb-ms-deployment-dev-uae").build());
		CfnParameter deploymentFileParameter = new CfnParameter(this, "deployment-file-name", CfnParameterProps
				.builder().defaultValue("lambda/deployment/sanction-country-report_v1.zip").build());
		CfnParameter layerVersionParameter = new CfnParameter(this, "python-layer-version",
				CfnParameterProps.builder().defaultValue("20").build());
		
		// Environment variables for Lambda function
		CfnParameter certificatePasswordParameter = new CfnParameter(this, "certificate-password",
				CfnParameterProps.builder().defaultValue("xxxxx").build());
		CfnParameter toAddressParameter = new CfnParameter(this, "to-address",
				CfnParameterProps.builder().defaultValue("vishal.jagtap@bankfab.com").build());
		CfnParameter fetchCinCifByRefIdServiceUrlParameter = new CfnParameter(this, "fetch-cin-cif-service-url", CfnParameterProps.builder()
				.defaultValue("https://api-sit.digital-ibmb-dev.aeapps.bankfab.com/pbdb/v1/customer/cust-id-info").build());
		CfnParameter sendEmailServiceUrlParameter = new CfnParameter(this, "send-email-service-url", CfnParameterProps.builder()
				.defaultValue("https://kproxy-uat.pcdigital-dev.aeapps.bankfab.com/NotificationService/nsapi/email/sendemail").build());
		CfnParameter getCustDetailsServiceUrlParameter = new CfnParameter(this, "get_customer_details", CfnParameterProps.builder()
				.defaultValue("https://dpuat.bankfab.com:2038/customeronboarding/v2/customer-details").build());
		
		String env = envParameter.getValueAsString();
		String region = regionParameter.getValueAsString();
		String account = accountIdParameter.getValueAsString();
		String kmsAccount = kmsAccountIdParameter.getValueAsString();
		String s3Arn = "arn:aws:s3:::" + s3BucketParameter.getValueAsString();
		String s3BucketPath = s3bucketPathParameter.getValueAsString();

		String vpcId = vpcIdParameter.getValueAsString();
		List<String> subnetIds = appSubnetIdsParameter.getValueAsList();
		
		String xksKeyId = xksKeyIdParameter.getValueAsString();
		
		Number memorySize = memorySizeParameter.getValueAsNumber();
		Number lambdaTimeout = lambdaTimeoutParameter.getValueAsNumber();
		String deploymentBucketName = deploymentBucketParameter.getValueAsString();
		String deploymentFileKey = deploymentFileParameter.getValueAsString();
		String layerVersion = layerVersionParameter.getValueAsString();
		
		String certificatePassword = certificatePasswordParameter.getValueAsString();
		String toAddress = toAddressParameter.getValueAsString();
		String fetchCinCifByRefIdServiceUrl = fetchCinCifByRefIdServiceUrlParameter.getValueAsString();
		String sendEmailServiceUrl = sendEmailServiceUrlParameter.getValueAsString();
		String getCustomerDetailsUrl  = getCustDetailsServiceUrlParameter.getValueAsString();
		
		Map<String, String> lambdaEnvVariableMap = getEnvVariableMap(env, certificatePassword,
				toAddress, fetchCinCifByRefIdServiceUrl, sendEmailServiceUrl, getCustomerDetailsUrl);
		
		@NotNull
		IKey kmsKey = Key.fromKeyArn(this, "kmsKey", "arn:aws:kms:" + region + ":" + kmsAccount + ":key/" + xksKeyId);

		ILayerVersion lambdaLayerVersion = LayerVersion.fromLayerVersionArn(this, "lambda-py-layer",
				"arn:aws:lambda:" + region + ":" + account + ":layer:lambda-py-layer:" + layerVersion);

		IBucket ibucket = Bucket.fromBucketArn(this, "negative-country-report-bucket", s3Arn);
		
		@NotNull
		IRole scReportRole = Role.fromRoleName(this, "scReportRoleId", "sc-report-role-iam-lambda-"+env); 
		
		Function sanctionCountryReportFunction = sanctionCountryReportFunction(id, env, vpcId, subnetIds,
				memorySize, lambdaTimeout, deploymentBucketName, deploymentFileKey, lambdaLayerVersion, kmsKey,
				scReportRole, lambdaEnvVariableMap);

		ibucket.grantRead(sanctionCountryReportFunction);
 		ibucket.addObjectCreatedNotification(new LambdaDestination(sanctionCountryReportFunction), NotificationKeyFilter.builder()
				.prefix(s3BucketPath)
				.suffix(".csv")
				.build());
	}

	private Function sanctionCountryReportFunction(String id, String env, String vpcId, List<String> subnetIds,
			Number memorySize, Number lambdaTimeout, String deploymentBucketName, String deploymentFileKey,
			@NotNull ILayerVersion lambdaLayerVersion, @NotNull IKey xksKey, @NotNull IRole sanctionCountryReportRole, Map<String, String> lambdaEnvVariableMap) {

		return new Function(this, "sanction-country-report", FunctionProps.builder()
				.functionName("Sanction-Country-Report-" + env)
				.runtime(software.amazon.awscdk.services.lambda.Runtime.PYTHON_3_9)
				.role(sanctionCountryReportRole)
				.environmentEncryption(xksKey)
				.code(Code.fromBucket(Bucket.fromBucketName(this, "function_deploymnet_bucket", deploymentBucketName),
						deploymentFileKey))
				.handler("lambda.handler")
				.memorySize(memorySize)
				.timeout(Duration.seconds(lambdaTimeout))
				.environment(lambdaEnvVariableMap)
				.layers(List.of(lambdaLayerVersion))
				.currentVersionOptions(VersionOptions.builder().description("v1")
						.removalPolicy(RemovalPolicy.RETAIN).build())
				.vpc(Vpc.fromVpcAttributes(this, id,
						VpcAttributes.builder().vpcId(vpcId).availabilityZones(getAvailabilityZones()).build()))
				.vpcSubnets(SubnetSelection.builder().subnets(getAppSubnetList(subnetIds)).build()).build());
	}

	/**
	 * @param env
	 * @param certificatePassword
	 * @param validateCustomerProfileUrl
	 * @param documentUploadUrl
	 * @param confirmCustomerRegistrationUrl
	 * @return
	 */
	
	public Map<String, String> getEnvVariableMap(String env, String certificatePassword,
			String toAddress, String fetchCinCifByRefIdServiceUrl, String sendEmailServiceUrl, String getCustomerDetailsUrl) {
		Map<String, String> map = new HashMap<>();
		String path = "/var/task/ssl/".concat(env);
		
		map.put("CERT_PASSWORD", certificatePassword);
		map.put("CLIENT_CERT", path.concat("/client.crt"));
		map.put("SERVER_KEY", path.concat("/client.key"));
		map.put("CA_CERT", path.concat("/certificate.pem"));
		map.put("TO_ADDRESS", toAddress);
		map.put("FETCH_CIN_CIF_BY_REFID_URL", fetchCinCifByRefIdServiceUrl);
		map.put("SEND_EMAIL_SERVICE_URL", sendEmailServiceUrl);
		map.put("GET_CUSTOMER_DETAILS", getCustomerDetailsUrl);
		
		return map;
	}

	private List<@NotNull ISubnet> getAppSubnetList(List<String> subnetIds) {
		List<ISubnet> subnetList = new ArrayList<>();
		AtomicInteger counter = new AtomicInteger(0);
		subnetIds.forEach(
				subnet -> subnetList.add(Subnet.fromSubnetId(this, "subnet" + counter.incrementAndGet(), subnet)));
		return subnetList;
	}

}



#!/usr/bin/env python3
import os
import json
import csv
import base64
import uuid
import io
from datetime import datetime
from urllib.parse import unquote
import pbcore.logger as logger
import pbcore.header as header
import pbcore.sslcontext as sslcont
import pbcore.aws.secretstore as secretstore
import boto3  # Updated: Use boto3 for S3

# Initialize the S3 client using boto3
s3_client = boto3.client('s3')  # Updated: Use boto3 client for S3 operations


# Defining Constant variables
COMMA_DELIMETER = ','

# Creation of SSL Context for SSL certificate verification using pbcore's sslcontext.
if(LAMBDA_FUNCTION is not None):
    ssl_context = sslcont.get_ssl_context()
else:
    ssl_context = sslcont.get_ssl_context_local('uat')
    
# CSV column mapping with Object fields
csv_column_mapping = {
    'customerId': 'CIN', 
    'cif': 'CIF', 
    'fullName': 'CM Name', 
    'target': 'Target Code', 
    'segment': 'Business Segment', 
    'accountOfficer': 'Branch', 
    'relationshipManager': 'RM', 
    'nationality': 'Nationality', 
    'login_attempts': 'Total Login Attempts', 
    'no_of_days': 'Login Period (no. of Days)'
}

# Lambda handler
def handler(event, content):
    logger.info(f"Event received from S3: {event}")
    s3_bucket = event['Records'][0]['s3']['bucket']['name']
    s3_key = event['Records'][0]['s3']['object']['key']
    s3_key = unquote(s3_key)
    logger.info(f"Unquote S3 key: {s3_key}")

    # Fetch the file from S3 using boto3
    response = s3_client.get_object(Bucket=s3_bucket, Key=s3_key)  # Updated: Fetch file from S3 using boto3
    csv_content = response['Body'].read().decode('utf-8')

    # Process the CSV content
    processor(io.StringIO(csv_content), s3_key)

# Method to read CSV data and calculate login attempts and number of days
def read_csv(csv_data):
    user_activity_dict = {}
    data = []
    reader = csv.reader(csv_data)
    header = next(reader, None)
    data.append(header)

    for row in reader:
        if row:
            rawTime = row[2].split('.')
            row[2] = ' ' + rawTime[0] + ''
        data.append(row)
        user_id = row[0].strip()
        if user_id not in user_activity_dict:
            unique_transaction_date = set()
            unique_transaction_date.add(row[2].strip().split(' ')[0])
            user_activity_dict[user_id] = {
                'transaction_date': unique_transaction_date, 
                'no_of_days': 0, 
                'login_attempts': 0
            }
            transaction_type = row[5].strip()
            if transaction_type.lower().find('login') != -1:
                user_activity_dict[user_id]['no_of_days'] += 1
                user_activity_dict[user_id]['login_attempts'] += 1
        else:
            transaction_date = user_activity_dict[user_id]['transaction_date']
            transaction_type = row[5].strip()
            if transaction_type.lower().find('login') != -1:
                if row[2].strip().split(' ')[0] not in transaction_date:
                    transaction_date.add(row[2].strip().split(' ')[0])
                    user_activity_dict[user_id]['no_of_days'] += 1
                    user_activity_dict[user_id]['login_attempts'] += 1
                else:
                    user_activity_dict[user_id]['login_attempts'] += 1

    with open('/tmp/output.csv', 'w', newline='') as outputFile:
        writer = csv.writer(outputFile)
        writer.writerows(data)
    logger.info("CSV file is copied to the temp location")
    return user_activity_dict

# Method to update user activity dictionary with customer data
def update_user_activity_dict(user_details, user_activity_dict):
    userlist = user_details.get('userList', [])
    userlist_map = {next(iter(item.keys())): next(iter(item.values())) for item in userlist}

    for map_values in userlist_map:
        values = user_activity_dict[map_values]
        values["customerId"] = userlist_map[map_values]["customerId"]
        values["cif"] = userlist_map[map_values]["cif"]
        json_response = get_customer_data(userlist_map[map_values]["customerId"])

        try:
            values["fullName"] = json_response["dataArea"]["fullName"]
            values["target"] = json_response["dataArea"]["additionalCustomerInfo"]["target"]
            values["segment"] = json_response["dataArea"]["additionalCustomerInfo"]["segment"]
            values["accountOfficer"] = json_response["dataArea"]["additionalCustomerInfo"]["accountOfficer"]
            values["relationshipManager"] = json_response["dataArea"]["additionalCustomerInfo"]["relationshipManager"]
            values["nationality"] = json_response["dataArea"]["nationality"]
        except:
            logger.error(f"Error in parsing JSON response: {json_response}")

# Method to write updated CSV content back to temp location        
def write_csv(temp_file_location, user_activity_dict):
    with open(temp_file_location, 'r') as file:
        csv_data = list(csv.DictReader(file))

        for row in csv_data:
            row_key = row.get('USER_NAME')
            values = user_activity_dict.get(row_key)
            if values:
                for json_key, csv_column in csv_column_mapping.items():
                    row[csv_column] = values.get(json_key, row.get(csv_column))

    fieldnames = [
        'USER_NAME', 'USER_ID', 'TIMESTAMP', 'TRANSACTION_ID',
        'IP_ADDRESS', 'TRANSACTION_TYPE', 'COUNTRY', 'CIN', 'CIF',
        'CM Name', 'Target Code', 'Business Segment', 'Branch', 'RM',
        'Nationality', 'Total Login Attempts', 'Login Period (no. of Days)'
    ]

    with open(temp_file_location, 'w', newline='') as outputFile:
        writer = csv.DictWriter(outputFile, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(csv_data)
    logger.info("Updated CSV file written to temp location")

# Method to send email with CSV attachment
def send_mail(csv_data_in_bytes, s3_file_name):
    if csv_data_in_bytes is not None:
        currectDate = datetime.now().date()
        email_subject = "Sanctioned country report_" + currectDate.strftime("%Y-%m-%d")
        split_array = s3_file_name.split('/')
        s3_file_name=split_array[-1]
        s3_file_name = s3_file_name.replace(':','_')
        url = os.environ['SEND_EMAIL_SERVICE_URL']

        headers = header.update_headers({
            'XREF': str(uuid.uuid4()),
            'CHANNELID': 'AWS',
            'content-type': 'application/json'
        })

        to_address_list = os.environ['TO_ADDRESS'].split(COMMA_DELIMETER)

        data = {
            "sourceSystem": "FAB",
            "requestID": str(uuid.uuid4()),
            "fromAddress": "noreply@bankfab.com",
            "entityName": "FAB",
            "toAddress": to_address_list,
            "emailSubject": email_subject,
            "emailBodyContent": "",
            "emailBodyContentType": "TEXT",
            "attachment": [{
                "attachementBytes": str(csv_data_in_bytes.decode("utf-8")),
                "mimeType": "application/csv",
                "fileName": s3_file_name
            }]
        }

        data = json.dumps(data)

        response = boto3.client('lambda').invoke(  # Updated: Use boto3 for Lambda invocation
            FunctionName=url,
            InvocationType='RequestResponse',
            Payload=json.dumps(data)
        )
        if response['StatusCode'] == 200:
            logger.info("Email sent successfully")
        else:
            logger.error(f"Failed to send email. Status code: {response['StatusCode']}")
    else:
        logger.error("csv_data_in_bytes is null")

# Method to fetch user details
def fetch_user_details(transaction_ids):
    url = os.environ['FETCH_CIN_CIF_BY_REFID_URL']

    headers = header.update_headers({
        'XREF': str(uuid.uuid4()),
        'CHANNELID': 'IB',
        'content-type': 'application/json'
    })

    data = json.dumps(transaction_ids)

    response = boto3.client('lambda').invoke(  # Updated: Use boto3 for Lambda invocation
        FunctionName=url,
        InvocationType='RequestResponse',
        Payload=json.dumps(data)
    )

    if response['StatusCode'] == 200:
        logger.info("User details fetched successfully")
        return response['Payload'].read().decode('utf-8')
    else:
        logger.error(f"Failed to fetch user details. Status code: {response['StatusCode']}")
        return None

# Processor method
def processor(csv_data, s3_file_name):
    user_activity_dict = read_csv(csv_data)
    temp_file_location = "/tmp/output.csv"

    user_ids_list = list(user_activity_dict.keys())
    json_response = fetch_user_details(user_ids_list)

    if json_response:
        update_user_activity_dict(json.loads(json_response), user_activity_dict)
        write_csv(temp_file_location, user_activity_dict)
        file_in_bytes = convert_attachment_in_bytes(temp_file_location)
        send_mail(file_in_bytes, s3_file_name)
    else:
        logger.error("JSON response is null")

if __name__ == '__main__':
    input = r"C:\Users\O25420\Docs\python\test1r.csv"
    processor(input)

------*************************************
#!/usr/bin/env python3
import os
import json
import service.CustomerProfile as customer_profile
import service.EFRService as efr_service
import pbcore.logger as logger
import pbcore.header as header
import pbcore.sslcontext as sslcont
import pbcore.aws.secretstore as secretstore
from enums.EventAction import EventAction
import service.APIGatewayService as api_gateway_service
from enums.EventStatus import EventStatus
import helper.StpValidation as stp_validation
import helper.BpmsProcessor as bpms_processor

LAMBDA_FUNCTION = os.environ.get("AWS_LAMBDA_FUNCTION_NAME")
ENV = os.environ.get("ENVIRONMENT")

'''
    Creation of SSL Context for ssl certificate verification.
    for aws lambda use getsslcontext to get certificates
    for local testing use getsslcontextlocal(environmentname) to get certificate

    Get INTERNAL_GATEWAY_KEY from secret store
'''
if(LAMBDA_FUNCTION is not None):
    ssl_context = sslcont.get_ssl_context()
    INTERNAL_API_KEY = secretstore.get_secret_value('AWS_IBMB_INTERNAL_API_GATEWAY_KEY_'+ ENV)
else:
    ssl_context = sslcont.get_ssl_context_local('uat')
    INTERNAL_API_KEY = 'j60AqcESvkfSDad5NMyy80Xl6fSq0HR6Fvlowjw6'


'''
    Lambda handler for processing the records for kyc upload processor with EFR.
'''
def handler(event,context):
    if event:
        batch_item_failures = []
        sqs_batch_response = {}
        logger.info(f"event received from SQS : {event}")
        sqs_message = event.get("Records")
        if sqs_message is not None and len(sqs_message) > 0:
            for message in sqs_message:
                message_id = message["messageId"]
                #### extracting body from sqs event
                message_body = message["body"]
                message_body = json.loads(message_body)
                final_message_body = message_body["Message"]  
                ##### converting message body to json
                final_message_body = json.loads(final_message_body)
                message_headers = final_message_body["headers"]
                message_data = final_message_body["data"]
                message_headers = header.update_headers(message_headers, message_data)
                logger_data = logger.prepare_logger_data(message_headers, message_data)
                logger.info(f"message id : {message_id}", **logger_data)
                logger.info(f"headers received from SQS: {message_headers}", **logger_data)
                logger.info(f"Data received from SQS: {message_data}", **logger_data)
                try:
                    service_orchestrator(message_data, message_headers, logger_data)
                except Exception as e:
                    logger.error(f'An unexpected error occurred : {e}', **logger_data)
                    batch_item_failures.append({"itemIdentifier": message_id})
            sqs_batch_response["batchItemFailures"] = batch_item_failures
            logger.info(f"sqsBatchResponse: {sqs_batch_response}", **logger_data)
            return sqs_batch_response

'''
    Method to orchestrate Service for EFR and DMS upload
'''
def service_orchestrator(message_data, message_headers, logger_data):
    efr_get_data_response = efr_service.get_efr_data_by_conv_id(message_data, message_headers, logger_data, ssl_context, INTERNAL_API_KEY)
    get_customer_data_from_t24 = customer_profile.get_customer_details_from_t24(message_data, message_headers, logger_data, ssl_context)
    efr_status = message_data.get("efrStatus")
    logger.info(f"EFR Status Code : {efr_status}", **logger_data)
    stp_flag, processed_flag = "N", "N"
    if efr_status == 'EFR_DOCUMENT_UPLOAD_COMPLETED':
        logger.info(f"efrJourneyStatus is : {efr_status}", **logger_data)
        validate_data_for_stp_flow_flag = stp_validation.validate_data_for_stp_flow(efr_get_data_response, get_customer_data_from_t24, logger_data)
        logger.info(f"In case validate data for stp flow is: {validate_data_for_stp_flow_flag}", **logger_data)
        if validate_data_for_stp_flow_flag:
            stp_flag = "Y" 
            api_gateway_service.publish_events_async(message_data, message_headers, logger_data, ssl_context, INTERNAL_API_KEY, EventAction.EFR_DATA_VALIDATION.name, EventStatus.SUCCESS.name, None, None) 
            update_customer_details = customer_profile.update_t24_customer_details(message_data, efr_get_data_response, get_customer_data_from_t24, message_headers, logger_data, ssl_context)
            logger.info(f"Update T24 Customer Details Status : {update_customer_details}", **logger_data)
            # check the status of update customer details service call
            if (update_customer_details == "UPDATE_SUCCESS" 
                or update_customer_details ==  "NO_CUSTOMER_UPDATE"): 
                logger.info(f"After Update Customer Details able to Proceed Processed Flow", **logger_data)
                processed_flag = "Y"
                logger.info(f" STP: {stp_flag}, Processed : {processed_flag}. Get Updated T24 customer Data for {update_customer_details} ", **logger_data)
                bpms_processor.trigger_stp_bpms_posting(stp_flag, processed_flag, efr_get_data_response, get_customer_data_from_t24, message_data, message_headers, logger_data, ssl_context)
            elif isinstance(update_customer_details, dict) :
                logger.info(f" STP: {stp_flag}, Processed : {processed_flag}. Updating T24 customer Data got failed and returned error Code & Description, {update_customer_details}", **logger_data)
                processed_flag = "N"
                bpms_processor.trigger_stp_non_processed_bpms_posting(stp_flag, processed_flag, efr_get_data_response, get_customer_data_from_t24, message_data, message_headers, update_customer_details, logger_data, ssl_context)
            else:
                logger.info(f" STP: {stp_flag}, Processed : {processed_flag}. Updating T24 customer Data got failed and return Error Exception {update_customer_details}", **logger_data)
                # edge case need to clarify
                processed_flag = "N"
                bpms_processor.trigger_stp_non_processed_bpms_posting(stp_flag, processed_flag, efr_get_data_response, get_customer_data_from_t24, message_data, message_headers, None, logger_data, ssl_context)
        #### invoke Notification Service
        else:
           api_gateway_service.publish_events_async(message_data, message_headers, logger_data, ssl_context, INTERNAL_API_KEY, EventAction.EFR_DATA_VALIDATION.name, EventStatus.FAILURE.name, None, None) 
           logger.info(f" STP: {stp_flag}, Processed : {processed_flag}. In case validate data for stp flow is: {validate_data_for_stp_flow_flag}", **logger_data)
           bpms_processor.trigger_non_stp_bpms_posting(stp_flag, processed_flag, efr_get_data_response, get_customer_data_from_t24,message_data, message_headers, logger_data, ssl_context)
    elif efr_status == 'EFR_FAILURE':
        logger.info(f" STP: {stp_flag}, Processed : {processed_flag}. In case EFR Failure", **logger_data)
        bpms_processor.trigger_non_stp_bpms_posting(stp_flag, processed_flag, efr_get_data_response, get_customer_data_from_t24,message_data, message_headers, logger_data, ssl_context)


# if __name__ == '__main__':
#     #event = {'Records': [{'messageId': 'bca38d1e-91a0-4559-9e03-bacd54e2365b', 'receiptHandle': 'AQEBiNg5NYVJVOitF73rWHhUsUTqT0WQgPmMFB38GoKg9UO3LYFxOiXQUp3IdATo38aplxaaiPhGAslrpMWvf1aywJIeaYd/t+UKLyTcweAWM52d9nTeyPf1y2VUq/3Gm4sLXq+y9wxS0PAFHpXf1pWVGkyutKzhO9PxKVWXxO802BKX20UHaA54Myey4bhYsB9jcFbzTb9vOZLDvNMy3Pf2U8K74sUABH8XWgXXr8g9wmpkRzpq3Tk5yHDzv7IK5J9QtLylbEDF/x6X13h6epaYvsEJGpif/CR3AjGRFMKZluHvpCzMgfcIr2Qn0LA1oqfnLAVuK0tBth5VBs0jfuoKOo/VrNFfk8bis6Z+E/eKoM19sJ8U1bj3NLlpyFSu/l4tAtMbMBvt1c7j4CgSpIqLtoee3f9axI8QdVOyMI2v4GU=', 'body': '{\n  "data" : {\r\n    "queueName": "efr-document-upload-uat",\r\n    "convId": "9a583974260e4ca1910bf3bad2e57b02",\r\n    "customerId": "565656",\r\n    "journey": "KYC_UPLOAD",\r\n    "efrJourneyStatus": "SUCCESS",\r\n    "requestedBy": "efr-documnet-upload"\r\n},\n  "headers": {\n        "Accept": "*\\/*" ,\n        "Accept-Encoding": "gzip, deflate, br" ,\n        "Content-Type": "application\\/json" ,\n        "Cookie": "BIGipServervim6a8s0WbVja\\/7YOr9aUg=!VfgFFE 450OTwYtoDqTKsUPsC0Fa4ZR6HMF6dWGJ1zyumrEsQR w3VMX4gewkHOSsutwkgOiaBEzM9A=" ,\n        "Host": "internalretailapi-uat.bankfab.com" ,\n        "Postman-Token": "e4517c87-8496-419a-8d79-64d84418f2a7" ,\n        "User-Agent": "PostmanRuntime\\/7.26.5" ,\n        "x-amzn-cipher-suite": "ECDHE-RSA-AES128-GCM-SHA256" ,\n        "x-amzn-tls-version": "TLSv1.2" ,\n        "x-amzn-vpc-id": "vpc-05bb082fa47361dc5" ,\n        "x-amzn-vpce-config": "1" ,\n        "x-amzn-vpce-id": "vpce-09f935921e24d61d6" ,\n        "x-api-key": "j60AqcESvkfSDad5NMyy80Xl6fSq0HR6Fvlowjw6" ,\n        "x-apigw-api-id": "5n9ib4nxlk" ,\n        "X-Forwarded-For": "10.125.21.105, 172.28.184.78" \n      }\n}', 'attributes': {'ApproximateReceiveCount': '1', 'AWSTraceHeader': 'Root=1-65c6048b-a0f4297b0faa2514efd82c4c', 'SentTimestamp': '1707476108046', 'SenderId': 'AROAXRA5ZLPO6PSCNEQFQ:BackplaneAssumeRoleSession', 'ApproximateFirstReceiveTimestamp': '1707476113046'}, 'messageAttributes': {}, 'md5OfBody': '60bb8acdc77b0127a34d8a86e51d0b80', 'eventSource': 'aws:sqs', 'eventSourceARN': 'arn:aws:sqs:me-central-1:517606038493:efr-document-upload-uat', 'awsRegion': 'me-central-1'}]}
#     event = {'Records': [{'messageId': '1aed51bd-6d0d-49c8-ba93-19a63382e898', 'receiptHandle': 'AQEBXici3zjgwINuGp3ipDB9MRW8LcE82NT6Wf6IH2LwZu75hl1hZkTrB+z7nx6YzJ0DSBTS1ZLkpHKny7cS5XNzUPmrZjJc9vP769qto4+2KFQM5VOKPIwJ8iSom/BMtkZ4gFMg4HFNU88PrzJYAKzhlQQIauwN02FJbdKwl6JWYSKJEj1DEiDMLCxWH52KJiNQMDXfxZxxv9Eol4N9OQiFQ+WjYXlZ1n8t7fIVLvvC2WEJrSWEXMMl/fEauxZWlPf9MYzBzVspSSwg7MWO3jtQsIoMm4mUP0TqbMcqhlANIrXNGyRrwPPEpV2SYvzHNiHA7P5Rir+5egXTw4KYpWc+uIRSlkMiY3bgSaBXAsvhyMorTeACc+3TKGqMoSlegozzflRzlKCdt59Gx9WtBSgEzg==', 'body': '{\n  "Type" : "Notification",\n  "MessageId" : "52b07294-6c2e-5192-a4a1-2cd46afa61ce",\n  "TopicArn" : "arn:aws:sns:me-central-1:517606038493:efr-journey-status-uat",\n  "Message" : "{\\n  \\"data\\" : {\\n    \\"topicName\\": \\"efr-journey-status-uat\\",\\n    \\"convId\\": \\"6119ee087afb4dddbfa98ea2f88fceae\\",\\n    \\"customerId\\": \\"6047331\\",\\n    \\"journey\\": \\"KYC_UPLOAD\\",\\n    \\"efrStatus\\": \\"EFR_DOCUMENT_UPLOAD_COMPLETED\\",\\n    \\"requestedBy\\": \\"EFR_DOCUMENT_UPLOAD-uat\\"\\n},\\n  \\"headers\\": {\\n        \\"Accept\\": \\"*\\\\/*\\" ,\\n        \\"Accept-Encoding\\": \\"gzip, deflate\\" ,\\n        \\"CHANNELID\\": \\"MOB\\" ,\\n        \\"Content-Type\\": \\"application\\\\/json\\" ,\\n        \\"Host\\": \\"internalretailapi-uat.bankfab.com\\" ,\\n        \\"User-Agent\\": \\"python-httpx\\\\/0.24.1\\" ,\\n        \\"x-amzn-cipher-suite\\": \\"ECDHE-RSA-AES128-GCM-SHA256\\" ,\\n        \\"x-amzn-tls-version\\": \\"TLSv1.2\\" ,\\n        \\"x-amzn-vpc-id\\": \\"vpc-05bb082fa47361dc5\\" ,\\n        \\"x-amzn-vpce-config\\": \\"1\\" ,\\n        \\"x-amzn-vpce-id\\": \\"vpce-09f935921e24d61d6\\" ,\\n        \\"x-api-key\\": \\"j60AqcESvkfSDad5NMyy80Xl6fSq0HR6Fvlowjw6\\" ,\\n        \\"x-apigw-api-id\\": \\"5n9ib4nxlk\\" ,\\n        \\"X-Forwarded-For\\": \\"10.74.8.71, 172.28.184.78\\" ,\\n        \\"XREF\\": \\"9a583974260e4ca1910bf3bad2e57b0223462908\\" \\n      }\\n}",\n  "Timestamp" : "2024-02-09T10:55:16.626Z",\n  "SignatureVersion" : "1",\n  "Signature" : "Hxp4yjSVT6QwkGO3rUNLK+mbOxapOSRzUcKijcDlZUI+SEqiamxzg1ApJAbarYFcU47CTVIp62ielp6oTKg/4/pEGlgUnYcImPAEFiFSM9LB+cBaQCSty+pSFEB3zu+ikgRGlan0yob4eMouDKydsgi+iepmZK7DBphmaLjvM9m1kRuvGhpgyuYP0jFHnwyPdPYB6JIEE+XWw+dJJCm7I02Dmv2lhPZwAfNk4XyyAtkCLfuBpU+oeisNfXkSJNoTJGu8Pl0wvszP1oH51pmfyJbaxrbXPBII3J0bFtYwLIS/HBLBWbXR0JIAZQ8cSkkArIL4faDcXCxqWTmy8CLJwQ==",\n  "SigningCertURL" : "https://sns.me-central-1.amazonaws.com/SimpleNotificationService-4feda397066d7d9e786590d8f4f17d7b.pem",\n  "UnsubscribeURL" : "https://sns.me-central-1.amazonaws.com/?Action=Unsubscribe&SubscriptionArn=arn:aws:sns:me-central-1:517606038493:efr-journey-status-uat:405d2cf0-60ba-448d-b0e1-1c7a96944758"\n}', 'attributes': {'ApproximateReceiveCount': '1', 'AWSTraceHeader': 'Root=1-65c60494-7cb0f7abcb364b4922a4f761', 'SentTimestamp': '1707476116759', 'SenderId': 'AIDAXDF67A73FC5KNYUHY', 'ApproximateFirstReceiveTimestamp': '1707476121759'}, 'messageAttributes': {}, 'md5OfBody': 'f073409ea8f86138d405387d0b4a7dd4', 'eventSource': 'aws:sqs', 'eventSourceARN': 'arn:aws:sqs:me-central-1:517606038493:kyc-upload-uat', 'awsRegion': 'me-central-1'}]}
#     # stp_flag  = "N"
#     # processed_flag = "N"
#     # message_headers = {"LANGUAGE": "EN", "XREF":"IEE3DEA38E35C42018BD1AD8835E7", "CHANNELID":"MOB"}
#     # message_data = { "topicName": "efr-journey-status-uat", "convId": "9a583974260e4ca1910bf3bad2e57b02", "customerId": "6047342", "journey": "KYC_UPLOAD", "efrStatus": "EFR_DOCUMENT_UPLOAD_COMPLETED", "requestedBy": "efr-document-upload_uat", "sessionId": "d28551386bc24e5885d4ed7a579c58ff", "deviceID": "3f1667a0-cec7-44e3-8bcc-35d626e45087" }
#     # message_headers = header.update_headers(message_headers, message_data)
#     # logger_data = logger.prepare_logger_data(message_headers, message_data)
# #     efr_get_data_response = efr_service.get_efr_data_by_conv_id(message_data, message_headers, logger_data, ssl_context, INTERNAL_API_KEY)
# #     # get_customer_updated_data_from_t24 = { "applicationArea": { "correlationId": "A55969627811e4ee5833fefde9ef9aa655750758524680", "countryOfOrigin": "AE", "senderId": "MOB", "transactionId": "A55969627811e4ee5833fefde9ef9aa655750758524680", "transactionDateTime": "2024-03-05T12:40:26:523Z", "language": "EN", "creationDateTime": "05/Mar/2024 12:40:26", "requiredExecutionDate": "05/Mar/2024 12:40:26" }, "responseStatus": { "status": "SUCCESS" }, "dataArea": { "fullName": "Adhithyan Jyothy Jyothy Gopinathan Nair Subhadra Amma", "prefix": "MR", "birthDate": "1994-06-28", "gender": "M", "ltGender": "F", "nationality": "IN", "emirate": "AUH", "country": "ABU DHABI, UAE", "maritalStatus": "", "isResident": "Y", "shortName": "Adhithyan Jyothy Jyothy Gopinathan", "customerIdentifier": "6045770", "customerType": "Individual", "customerOpenDate": "2024-01-04", "accountingUnitIdentifier": "AE0010001", "mothersMaidenName": "Lakshmi", "placeOfBirth": "IN", "amlSegment": "LM", "segment": "", "isStaff": False, "employment": { "employerName": "", "employerName2": "ADCOM", "monthlySalary": "30000.00", "employmentStatus": "Employed" }, "additionalCustomerInfo": { "segment": "02", "customerRateSegment": "Mass", "target": "30", "accountOfficer": "178", "language": "1", "startDate": "2024-01-04", "nameOnCard": "ADHITHYAN JYOTHY JYOT", "sector": "4000", "profession": "CLINIC MANAGER", "subSegment": "6201", "relationshipManager": "FGB2353", "vatCategory": "004", "constitution": "", "otherOfficer": [ "", "" ], "country": [ "20", "" ], "customerResidence": [ "AE", "" ], "ownerName": [ "", "" ], "ownerNationality": [ "", "" ], "percentOwner": [ "", "" ], "riskCategory": "", "riskAgreement": "", "relationCustomer": [ "", "" ], "relationCode": [ "", "" ], "reverseRelationCode": [ "", "" ], "customerEducationalBackground": "", "customerAgeClassification": "MAJOR", "powerOfAttorneyFlag": "" }, "kycInfo": { "kycFlag": "FULL", "kycDate": "2024-02-06", "kycExpiryDate": "2027-02-06", "isKYCUsingEID": False }, "identity": [ { "identityType": "EMI", "identityNumber": "784199498780198", "identityExpiryDate": "2024-10-10" }, { "identityType": "VIS", "identityNumber": "20120199366198", "identityExpiryDate": "2024-09-12" }, { "identityType": "PAS", "identityNumber": "P3965511", "identityExpiryDate": "2029-08-27" } ], "address": [ { "addressLine1": "22334455", "addressLine2": "ALFARABI STREET AL AIN", "city": "ABU DHABI, UAE", "country": "20", "postalCode": "" } ], "contacts": [ { "contactType": "PERSONAL", "mobileNumber": "0506256555", "email": "madhura.deshpande3@bankfab.com" }, { "contactType": "OFFICE" } ], "accounts": [ { "accountIdentifier": "1781006045770001", "accountTitle": "PRASANNA KUMAR VELLORE SELVAKUMAR", "postingRestriction": "", "customerIdentifier": "6045770", "currency": "AED", "isActive": True, "branchCode": "178", "powerOfAttorney": "" }, { "accountIdentifier": "1786006045770002", "accountTitle": "ADHITHYAN JYOTHY JYOTHY GOPINATHAN", "postingRestriction": "", "customerIdentifier": "6045770", "currency": "AED", "isActive": True, "branchCode": "178", "powerOfAttorney": "" } ], "FATCA": { "isPoliticalExposed": "NO"   , "isUSPersonForTaxPurpose": False, "socialSecurityNumber": "", "isTaxResidentOtherCountry": False, "isResidentOfOtherJurisdiction": "", "declarationIndicator": False, "reasonForDeclarationDisagree": "", "status": "", "isReportable": False, "otherNationalities": [ "", "" ], "nationality": [ "IN", "" ], "placeOfBirth": "Chittoor", "taxResidencies": [ { "countryJurisdictionOfTaxResident": "AE", "taxIdentificationNumber": "", "reasonIfTINNotAvailable": "A", "comments": "" }, { "countryJurisdictionOfTaxResident": "", "taxIdentificationNumber": "", "reasonIfTINNotAvailable": "", "comments": "" } ] } } }
# #     # get_customer_data_from_t24 = customer_profile.get_customer_details_from_t24(message_data, message_headers, logger_data, ssl_context)
#     # event = {'Records': [{'messageId': 'e3adbe49-5fa8-4541-949e-1aefddf057f7', 'receiptHandle': 'AQEBS4w73FODe0r4kJbZzM6ZNCsGd2fz1ZVPbWOq5vpJyvw9FLiZX3OQTlj0WU1hYlV4CbMKj8GtD3sriPW/DH56yuNavADYM64AsVisCvUht1n+YEqhqEFmebog/MWBTPu714Cu6f+G41sWg6VO0Upl97x0oo/IQ/QCdGH3iIa24oNSsDCgPKRJnvLuYblqVuXZ1QGpNa+qYlWXdn2/46DnS7Rt0U1g4DJNj3NMWaRIDe5TP7lpuYSJkGaRIwdAQ6ZI4st/LhH7eZ4HgQil9XIMvwvXZMuKaTt5Y1ff8zqfLOXCRzy0SgQTSwd1Wtn6QBLGnQDIy+9xoox90vE6RAuJRdwmYFHs2xXBmNRFpklvqpDcFgH0aZn28HXOqaXGbK2MAEjjNhju+lMKEeyYK33tCtPjVuzL9VUEHifbdQzqbxc=', 'body': '{\n  "data" : {\r\n    "queueName": "efr-document-upload-uat",\r\n    "convId": "9a583974260e4ca1910bf3bad2e57b02",\r\n    "customerId": "6046253",\r\n    "journey": "KYC_UPLOAD",\r\n    "efrJourneyStatus": "SUCCESS",\r\n  "sessionId": "12345678",\r\n "deviceID": "1234567",\r\n   "requestedBy": "efr-documnet-upload"\r\n},\n  "headers": {\n        "Accept": "*\\/*" ,\n        "Accept-Encoding": "gzip, deflate, br" ,\n        "CHANNELID": "MOB" ,\n        "Content-Type": "application\\/json" ,\n        "Cookie": "BIGipServervim6a8s0WbVja\\/7YOr9aUg=!oQ81yzQgR F09pkqkmW0s8UFcCcwuwgKTGvsZV 8XCDf0fzMrSlBbCzj3akFLwdTouDC9N6z2bhGD34=" ,\n        "Host": "internalretailapi-uat.bankfab.com" ,\n        "Postman-Token": "5daca6f6-5fbb-404f-a1ea-2c2bfe463d50" ,\n        "User-Agent": "PostmanRuntime\\/7.26.5" ,\n        "x-amzn-cipher-suite": "ECDHE-RSA-AES128-GCM-SHA256" ,\n        "x-amzn-tls-version": "TLSv1.2" ,\n        "x-amzn-vpc-id": "vpc-05bb082fa47361dc5" ,\n        "x-amzn-vpce-config": "1" ,\n        "x-amzn-vpce-id": "vpce-09f935921e24d61d6" ,\n        "x-api-key": "j60AqcESvkfSDad5NMyy80Xl6fSq0HR6Fvlowjw6" ,\n        "x-apigw-api-id": "5n9ib4nxlk" ,\n        "X-Forwarded-For": "10.125.21.100, 172.28.184.78" ,\n        "XREF": "234567898765432" \n      }\n}', 'attributes': {'ApproximateReceiveCount': '7', 'AWSTraceHeader': 'Root=1-65b8e280-afd5a06880a7dd392e9b1ac7', 'SentTimestamp': '1706615425132', 'SenderId': 'AROAXRA5ZLPOZ4TGJQV3G:BackplaneAssumeRoleSession', 'ApproximateFirstReceiveTimestamp': '1706615430132'}, 'messageAttributes': {}, 'md5OfBody': '0d5f8a9517fd72bb857692eeb8e99e04', 'eventSource': 'aws:sqs', 'eventSourceARN': 'arn:aws:sqs:me-central-1:517606038493:efr-document-upload-uat', 'awsRegion': 'me-central-1'}]}
#     res = handler(event, None)
# #     # res = bpms_service.posting_kyc_update(stp_flag, processed_flag, efr_get_data_response, get_customer_data_from_t24, message_data, message_headers, logger_data, ssl_context, None)
# #     print(efr_get_data_response)
# #     # get_customer_updated_data_from_t24 = {"applicationArea":{"correlationId": "I63C0D7A10B384DFC99AF0E01270278584262481102911","countryOfOrigin": "AE","senderId": "MOB","transactionId": "I63C0D7A10B384DFC99AF0E01270278584262481102911","transactionDateTime": "2024-02-29T06:29:02:061Z","language": "EN","creationDateTime": "29/Feb/2024 06:29:02","requiredExecutionDate": "29/Feb/2024 06:29:02"},"responseStatus": {"status": "SUCCESS"},"dataArea": {"fullName": "PRASANNA KUMAR","prefix": "MR","birthDate": "1983-06-24","gender": "M","ltGender": "M","nationality": "IN","emirate": "AUH","country": "ABU DHABI, UAE","maritalStatus": "","isResident": "Y","shortName": "PRASANNA KUMAR VEL SELVAKUMA","customerIdentifier": "6046679","customerType": "Individual","customerOpenDate": "2024-02-26","accountingUnitIdentifier": "AE0010001","mothersMaidenName": "Sujathasiri","placeOfBirth": "IN","amlSegment": "L","segment": "","isStaff": False,"employment": {"employerName": "","employerName2": "AGA","monthlySalary": "30000.00","employmentStatus": "Employed"},"additionalCustomerInfo": {"segment": "","customerRateSegment": "Mass","target": "30","accountOfficer": "178","language": "1","startDate": "2024-02-26","nameOnCard": "","sector": "4000","profession": "Computer Engineer","subSegment": "6201","relationshipManager": "FGB2353","vatCategory": "004","constitution": "","otherOfficer": [""],"country": ["UAE"],"customerResidence": ["AE"],"ownerName": [""],"ownerNationality": [""],"percentOwner": [""],"riskCategory": "","riskAgreement": "","relationCustomer": [""],"relationCode": [""],"reverseRelationCode": [""],"customerEducationalBackground": "","customerAgeClassification": "MAJOR","powerOfAttorneyFlag": ""},"kycInfo": {"kycFlag": "FULL","kycDate": "2024-02-26","kycExpiryDate": "2029-02-26","isKYCUsingEID": False},"identity": [{"identityType": "EMI","identityNumber": "","identityExpiryDate": "2025-04-26"},{"identityType": "VIS","identityNumber": "20120199366198","identityExpiryDate": "2025-09-12"},{"identityType": "PAS","identityNumber": "TC5306","identityExpiryDate": "2029-08-26"}],"address": [{"addressLine1": "22334455","addressLine2": "ALFARABI STREET AL AIN","city": "ABU DHABI, UAE","country": "UAE","postalCode": ""}],"contacts": [{"contactType": "PERSONAL","mobileNumber": "0506256536","email": "sanjiv.kadam@bankfab.com"},{"contactType": "OFFICE"}],"accounts": [{"accountIdentifier": "1786006046679001","accountTitle": "PRASANNA KUMAR VEL SELVAKUMAR","postingRestriction": "","customerIdentifier": "6046679","currency": "AED","isActive": True,"branchCode": "178","powerOfAttorney": ""}],"FATCA": {"isPoliticalExposed": "NO","pepPosition": "None","isUSPersonForTaxPurpose": False,"socialSecurityNumber": "","isTaxResidentOtherCountry": False,"isResidentOfOtherJurisdiction": "","declarationIndicator": False,"reasonForDeclarationDisagree": "","status": "","isReportable": False,"otherNationalities": [""],"nationality": ["IN"],"placeOfBirth": "Chittoor","taxResidencies": [{"countryJurisdictionOfTaxResident": "AE","taxIdentificationNumber": "","reasonIfTINNotAvailable": "A","comments": ""}]}}}
# #     # efr_get_data_response = {"convId": "fed6ac255f554bff8f46a704e44d8612","journey": "KYC_UPLOAD","creationTime": "29-02-2024 10:28:22.415","frontCardScan": "/Z","backCardScan": "//Z","mrz": {"line1": "ILARE1290903011784198783609609\r","line2": "8702230M2504269IND<<<<<<<<<<<7\r","line3": "SELVAKUMARCCPRASANNA<KUMARCVEL","valid": False},"details": {"docIssuingAuthority": "ARE","docNumber": "129090301","docCode": "IL","primaryIdentifier": "SELVAKUMARCCPRASANNA KUMARCVEL","secondaryIdentifiers": "SELVAKUMARCCPRASANNA KUMARCVEL","dateOfBirth": "870223","docExpiryDate": "250426","visualExpiryDate": "250426","gender": "M","nationality": "IND","nationalityIso2": "IN","registrantNumber": "784198783609609"},"cardLayoutType": "2","ttl": 1709360902,"onboardCustomerResponse": {"report": "=","identityCardDetails": {"docType": 0,"docIssuingAuthority": "ARE","docNumber": "129090301","docCode": "IL","primaryIdentifier": "SELVAKUMARCCPRASANNA KUMARCVEL","secondaryIdentifiers": "SELVAKUMARCCPRASANNA KUMARCVEL","dateOfBirth": "1987-02-23","docExpiryDate": "2025-04-26","gender": "M","nationality": "IND","registrantNumber": "784198783609609"}},"efrValidateCustomerProfileResponse": {"data": {"pdfCertificate": "z","jsonReport": {"reportIssueDate": "2024-02-29T10:28:42.9712577+04:00","reportExpiryDate": "2025-02-28T10:28:42.9712601+04:00","identityCardDetails": {"cardCode": "IL","registrantNumber": "784198783609609","cardNumber": "129090301","issueDate": "2023-04-27T00:00:00","expiryDate": "2025-04-26T00:00:00"},"passportDetails": {"passportType": 1,"passportNumber": "TC5306","passportCountryCode": "IND","issuingAuthority": "IND","issueDate": "2019-08-27T00:00:00","expiryDate": "2029-08-26T00:00:00"},"residencyDetails": {"residencyType": {"code": "2","arabicDescription": "","englishDescription": "Residence"},"residencyNumber": "201/2019/9/366198","issuePlace": "IND","issueDate": "2023-09-13T00:00:00","expiryDate": "2025-09-12T00:00:00"},"personalDetails": {"fullName": "Prasanna Kumar Vel Selvakumar","birthDate": "1987-02-23T00:00:00","nationality": {"code": "IND","arabicDescription": " ","englishDescription": "INDIA"},"maritalStatus": {"code": "1","arabicDescription": "","englishDescription": "SINGLE"},"gender": {"code": "M","arabicDescription": "","englishDescription": "MALE"},"familyBookNumber": "0","placeOfBirth": "India","motherName": "Sujathasiri"},"professionalDetails": {"qualificationLevel": {"code": "6","arabicDescription": "","englishDescription": "MASTER"},"occupation": {"code": "1118","englishDescription": "Computer Engineer"},"fieldOfstudyEnglish": {}},"addressDetails": {"addressType": "LOCAL","phoneNumber": "02-123-8888","mobilePhoneNumber": "050-123-8888","emailAddress": "22334455","buildingName": "Falcon Tower","location": {"code": "1","arabicDescription": "ABU DHABI"},"emirate": {"code": "1","arabicDescription": "ABU DHABI"},"city": {"code": "2","englishDescription": "AL AIN"},"area": {"code": "550","arabicDescription": " ","englishDescription": "AL AIN"},"street": {"code": "24567","arabicDescription": " ","englishDescription": "AL-FARABI STREET"},"country": {},"pOBox": "22334455"},"sponsorDetails": {"sponsorType": {"code": "9","arabicDescription": "  /  ","englishDescription": "Govt / semi-Govt sponsor"},"name": "ABC CARE LLC","number": "2345767","registrantNumber": "784198421865951","nationalityCode": "IND"}}}},"documentIds": {"EID_EFR_REPORT": "090364178011a34b","EID_FRONT_PAGE": "090364178011a346","EID_EFR_CERTIFICATE": "090364178011a34c","EID_BACK_PAGE": "090364178011a347"}}
# #     # value = validate_data_for_stp_flow(efr_get_data_response=efr_get_data_response,
# #     #                            get_customer_data_from_t24=get_customer_updated_data_from_t24,
# #     #                            logger_data=logger_data)
# #     # print (f"end result : {value}")



import boto3
import csv
import httpx
import json 
import base64
import ssl
import uuid
import logging
import os
import io
from base64 import b64decode
from datetime import datetime
from urllib.parse import unquote

logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Fectching details from env variables
CERT_PASSWORD = os.environ['CERT_PASSWORD']
CLIENT_CERT =  os.environ['CLIENT_CERT']
SERVER_KEY = os.environ['SERVER_KEY']
CA_CERT = os.environ['CA_CERT']

# Defining Constant variables
COMMA_DELIMETER = ','


# Decrypt code should run once and variables stored outside of the function
# handler so that these are decrypted once per container
logger.info(os.environ['AWS_LAMBDA_FUNCTION_NAME'])
PASSWORD = boto3.client('kms').decrypt(
    CiphertextBlob=b64decode(CERT_PASSWORD),
    EncryptionContext={'LambdaFunctionName': os.environ['AWS_LAMBDA_FUNCTION_NAME']}
)['Plaintext'].decode('utf-8')


# PASSWORD = 'p@ssw0rd'
# CLIENT_CERT =  r'C:\Users\O27038\Python\efr-validate-customer-profile\ssl\sit\client.crt'
# SERVER_KEY = r'C:\Users\O27038\Python\efr-validate-customer-profile\ssl\sit\client.key'
# CA_CERT = r'C:\Users\O27038\Python\efr-validate-customer-profile\ssl\sit\certificate.pem'

'''
Creation of SSL Context for ssl certificate verification.
'''
sslcontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
sslcontext.verify_mode = ssl.CERT_REQUIRED
sslcontext.check_hostname = True
sslcontext.load_verify_locations(cafile=CA_CERT)
sslcontext.load_cert_chain(CLIENT_CERT,SERVER_KEY,PASSWORD)

s3_client = boto3.client('s3')

# CSV column mapping with Object fields
csv_column_mapping = {'customerId' :'CIN' , 'cif' :  'CIF', 'fullName' : 'CM Name', 'target' : 'Target Code', 'segment' : 'Business Segment', 'accountOfficer' : 'Branch', 'relationshipManager' : 'RM', 'nationality' : 'Nationality', 'login_attempts':'Total Login Attempts', 'no_of_days':'Login Period (no. of Days)'}


# Lambda handler
def handler(event,content):
    logger.info(f"event received from S3 : {event}")
    s3_bucket = event['Records'][0]['s3']['bucket']['name']
    s3_key = event['Records'][0]['s3']['object']['key']
    s3_key = unquote(s3_key)
    logger.info(f"Unquote S3 key : {s3_key}")
    response = s3_client.get_object(Bucket=s3_bucket,Key=s3_key)
    csv_content = response['Body'].read().decode('utf-8')
    processor(io.StringIO(csv_content), s3_key)

# Method to read S3 file content and calulate login attempts and number of days
# also this method will right S3 file content on temp location
def read_csv(csv_data):
    user_activity_dict = {}
    data = []
    reader = csv.reader(csv_data)
    header = next(reader,None)
    data.append(header)
    for row in reader:
        if row:
            rawTime = row[2].split('.')
            row[2]= ' '+ rawTime[0] +''
        data.append(row)
        user_id = row[0].strip()
        if user_id not in user_activity_dict:
            unique_transaction_date = set()
            unique_transaction_date.add(row[2].strip().split(' ')[0])
            user_activity_dict[user_id] = {'transaction_date' : unique_transaction_date, 'no_of_days' : 0, 'login_attempts' : 0}
            transaction_type = row[5].strip()
            if transaction_type.lower().find('login') != -1:
                user_activity_dict[user_id]['no_of_days'] = user_activity_dict[user_id]['no_of_days'] + 1
                user_activity_dict[user_id]['login_attempts'] = user_activity_dict[user_id]['login_attempts'] + 1
        else:
            transaction_date = user_activity_dict[user_id]['transaction_date']
            transaction_type = row[5].strip()
            if transaction_type.lower().find('login') != -1:
                if row[2].strip().split(' ')[0] not in transaction_date:
                    transaction_date.add(row[2].strip().split(' ')[0])
                    user_activity_dict[user_id]['no_of_days'] = user_activity_dict[user_id]['no_of_days'] + 1
                    user_activity_dict[user_id]['login_attempts'] = user_activity_dict[user_id]['login_attempts'] + 1
                else:
                    user_activity_dict[user_id]['login_attempts'] = user_activity_dict[user_id]['login_attempts'] + 1        
    with open('/tmp/output.csv','w',newline='') as outputFile:
        writer = csv.writer(outputFile)
        writer.writerows(data)
    logger.info("CSV files is copied at temp location")
    return user_activity_dict


# Method is used to prepare dictionary for user details.
# key is user_name and value is complete details related to column
def update_user_activity_dict(user_details,dict):
    userlist = user_details.get('userList',[])
    userlist_map = {next(iter(item.keys())):next(iter(item.values())) for item in userlist}
    for map_values in userlist_map:
        values = dict[map_values]
        values["customerId"] = userlist_map[map_values]["customerId"]
        values["cif"] = userlist_map[map_values]["cif"]
        json_reponse = get_customer_data(userlist_map[map_values]["customerId"])
        try:
            values["fullName"] = json_reponse["dataArea"]["fullName"]
            values["target"] = json_reponse["dataArea"]["additionalCustomerInfo"]["target"]
            values["segment"] = json_reponse["dataArea"]["additionalCustomerInfo"]["segment"]
            values["accountOfficer"] = json_reponse["dataArea"]["additionalCustomerInfo"]["accountOfficer"]
            values["relationshipManager"] = json_reponse["dataArea"]["additionalCustomerInfo"]["relationshipManager"]
            values["nationality"] = json_reponse["dataArea"]["nationality"]
        except:
            logger.info(f"Error in parsing JSON response : {json_reponse}")


# Method is used to update CSV content and write data back to temp location        
def write_csv(temp_file_location, user_activity_dict):
    with open(temp_file_location,'r') as file:
        csv_data =  list(csv.DictReader(file))
        for row in csv_data:
            row_key = row.get('USER_NAME')
            values = user_activity_dict.get(row_key)
            if values:
                for json_key,csv_column in csv_column_mapping.items():
                    row[csv_column] = values.get(json_key,row.get(csv_column))          
    fieldnames = ['USER_NAME','USER_ID','TIMESTAMP','TRANSACTION_ID','IP_ADDRESS','TRANSACTION_TYPE','COUNTRY', 'CIN' , 'CIF' , 'CM Name' , 'Target Code' , 'Business Segment' , 'Branch' , 'RM' , 'Nationality' , 'Total Login Attempts' , 'Login Period (no. of Days)']
    with open(temp_file_location,'w',newline='') as outputFile:
        writer = csv.DictWriter(outputFile,fieldnames=fieldnames)
        writer.writeheader()
        logger.info(f"file open as writer {csv_data}")
        writer.writerows(csv_data)


# Method is used to send email
def send_mail(csv_data_in_bytes, s3_file_name):
    if csv_data_in_bytes is not None:
        currectDate = datetime.now().date()
        email_subject = "Sanctioned country report_" + currectDate.strftime("%Y-%m-%d")
        split_array = s3_file_name.split('/')
        s3_file_name=split_array[-1]
        s3_file_name = s3_file_name.replace(':','_')
        url = os.environ['SEND_EMAIL_SERVICE_URL']
        headers = {'XREF': str(uuid.uuid4()), 'CHANNELID': 'AWS', 'content-type': 'application/json'}

        # Split the TO_ADDRESS environment variable into a list of email addresses
        to_address_list = os.environ['TO_ADDRESS'].split(COMMA_DELIMETER)

        data = {
            "sourceSystem": "FAB",
            "requestID": str(uuid.uuid4()),
            "fromAddress": "noreply@bankfab.com",
            "entityName": "FAB",
            "toAddress": to_address_list,
            "emailSubject": email_subject,
            "emailBodyContent": "",
            "emailBodyContentType": "TEXT",
            "attachment": [{
                "attachementBytes": str(csv_data_in_bytes.decode("utf-8")),
                "mimeType": "application/csv",
                "fileName": s3_file_name
            }]
        }

        data = json.dumps(data)
        response = httpx.post(url, headers=headers, data=data, verify=sslcontext)
        if response.status_code == 200:
            logger.info("Email sent successfully")
        else:
            logger.info(f"Failed to send email. Status code: {response.status_code}")
        logger.info(f'Email API Response: {response.text}')
    else:
        logger.info("csv_data_in_bytes is null.")
    

def convert_attachment_Inbytes(file_path):
    new_csv = None
    with open(file_path,'r') as file:
        new_csv = base64.b64encode(file.read().encode('utf-8'))
    return new_csv

# Method is used to fetch CIN and CIF based on reference id
def fetch_user_Details(transactionIds):
    url= os.environ['FETCH_CIN_CIF_BY_REFID_URL']
    headers = {'XREF': str(uuid.uuid4()), 'CHANNELID': 'IB','content-type':'application/json'}
    data = json.dumps(transactionIds)
    response = httpx.post(url,headers=headers, data=data, verify = False)
    logger.info("Fetching details from DB.")
    if response.status_code == 200:
        logger.info("PB db response received.")
        return response.text
    else:
        logger.info(f"error response : {response.status_code}")
        return None


# Method to fetch customer data based on CIN
def get_customer_data(cin):
    url= os.environ['GET_CUSTOMER_DETAILS']
    xref = str(uuid.uuid4())
    headers = {'XREF': xref, 'CHANNELID': 'IB','LANGUAGE':'EN'}
    currectDate = datetime.now()
    data = {
    "applicationArea": {
        "countryOfOrigin": "AE",
        "creationDateTime": str(currectDate),
        "requiredExecutionDate": str(currectDate),
        "senderId": "IB",
        "transactionDateTime": str(currectDate),
        "transactionId": xref,
        "language": "EN"
    },
    "dataArea": {
        "customerIdentifier": cin,
        "accountingUnitIdentifier": "AE0010001"
    }
    }
    data = json.dumps(data)
    response = httpx.post(url,headers=headers, data=data, verify = sslcontext)
    json_reponse = response.json()
    if response.status_code == 200:
        logger.info(f"Customer detail response received for CIN : {cin}")
        return json_reponse
    else:
        logger.info(f"Customer detail Error response received for CIN : {cin}")
        return None

def processor(csv_data, s3_file_name):
    user_activity_dict = read_csv(csv_data)
    temp_file_location = "/tmp/output.csv"
    userIdsList = list(user_activity_dict.keys())
    json_reponse = fetch_user_Details(userIdsList)
    if json_reponse is not None:
        update_user_activity_dict(json.loads(json_reponse),user_activity_dict)
        write_csv(temp_file_location, user_activity_dict)
        file_Inbytes = convert_attachment_Inbytes(temp_file_location)
        send_mail(file_Inbytes, s3_file_name)
    else:
        logger.info(f'Json response is null.')

if __name__ == '__main__':
    input = r"C:\Users\O25420\Docs\python\test1r.csv"
    processor(input)



title accesscontrol/cred/v3/verify Flow

User ->> System: Verify Login Request (v3)
System ->> SessionContext: Get Session Details (cif, deviceID, convID)
SessionContext -->> System: Session Details
System ->> ChannelInfoRepository: Fetch Channel Info (cif, channelType)
ChannelInfoRepository -->> System: Channel Info
System ->> ChannelValidator: Validate Channel Info
ChannelValidator -->> System: Validation Success

alt Browser Login
    System ->> UserChannelRepository: Get User Channel (cif, channelType)
    UserChannelRepository -->> System: User Channel
    System ->> PwdHelper: Match Password
    PwdHelper -->> System: Password Matched
    System ->> mqNotifier: Refresh Customer Position Cache
end

alt Mobile Login
    System ->> UserChannelRepository: Get User Channel by User ID and Device ID
    UserChannelRepository -->> System: User Channel
    System ->> PwdHelper: Match Password
    PwdHelper -->> System: Password Matched

    alt Status is ACTIVE_PENDING_LOGIN
        System ->> UserChannel: Update Status to ACTIVE
        System ->> UserChannelRepository: Save Updated User Channel
    end
end

System ->> RiskSF: Evaluate Risk for Login
RiskSF -->> System: Risk Evaluation Response

alt Risk Allowed
    System ->> SessionRepository: Update Verification Status
    SessionRepository -->> System: Verification Success
end

System -->> User: Return Success Response


/////////////////////////////////////
title accesscontrol/cred/v4/verify Flow

User ->> System: Verify Login Request (v4)
System ->> SessionContext: Get Session Details (cif, deviceID, convID)
SessionContext -->> System: Session Details
System ->> ChannelInfoRepository: Fetch Channel Info (cif, channelType)
ChannelInfoRepository -->> System: Channel Info
System ->> ChannelValidator: Validate Channel Info
ChannelValidator -->> System: Validation Success

System ->> UserChannelRepository: Get User Channel by User ID and Device ID
UserChannelRepository -->> System: User Channel

System ->> CsTransactionSF: Send OTP Transaction Request
CsTransactionSF -->> System: OTP Transaction Response

alt OTP Success and Allow
    System ->> UserChannel: Check Status
    alt Status is ACTIVE_PENDING_LOGIN and Mobile
        System ->> UserChannel: Update Status to ACTIVE  // Fix added in v4
        System ->> UserChannelRepository: Save Updated User Channel  // Fix added in v4
    end
    System ->> SessionRepository: Update Verification Status
    SessionRepository -->> System: Verification Success
end

alt OTP Failure
    System ->> VerifyUserLoginSF: Update Channel and Access Info (Failure)
    System ->> AppException: Throw Error (OTP Failed)
end

System -->> User: Return VerifyUserLoginResponse (Success/Failure)

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Key Differences Highlighted in the Sequence Diagrams:
Channel-Specific Logic:

v3: Differentiates clearly between BROWSER and MOBILE login. For browsers, it refreshes customer position and may bypass certain checks. For mobile, it has explicit logic to handle ACTIVE_PENDING_LOGIN to ACTIVE status updates.
v4: No differentiation between browser and mobile channels in terms of customer position refresh or custom channel-specific logic. The primary focus is on handling OTP verification for all channels.
Password Matching:

v3: Contains explicit logic for password matching depending on the user's channel (e.g., browser or mobile).
v4: Does not have explicit password matching logic; the method relies heavily on the OTP transaction to validate the user's login.
Risk Evaluation:

v3: Includes risk evaluation, using a separate service (RiskSF) to decide if the login should proceed or require additional verification.
v4: Simplifies risk management by relying on the OTP transaction's outcome (CsTransactionSF). If the OTP is validated, the login proceeds; otherwise, it fails.
Fix to Handle ACTIVE_PENDING_LOGIN Status:

v3: Always checks if a mobile user's status is ACTIVE_PENDING_LOGIN and updates it to ACTIVE upon successful login.
v4: Originally missed this status update logic, but the fix introduces a check for ACTIVE_PENDING_LOGIN and updates it to ACTIVE after a successful OTP validation for mobile users.
OTP-Based Transaction Handling:

v3: Does not emphasize OTP transactions as much as v4, relying more on password validation and risk evaluation.
v4: Relies heavily on the OTP transaction's result (CsTransactionSF), making OTP validation the central part of the login process.
Summary:
The diagrams highlight the different approaches between v3 and v4 in handling login verification. v3 has more custom logic for channel-specific scenarios and password handling, while v4 is more streamlined, focusing primarily on OTP validation. The fix in v4 ensures that the status update from ACTIVE_PENDING_LOGIN to ACTIVE is properly handled, similar to how it was done in v3.

-----------------------------------------------
title Verify Login Flow (accesscontrol/cred/v3/verify)

User ->> System: Verify Login Request
System ->> SessionContext: Get session details (cif, deviceID, convID)
SessionContext -->> System: Session details
System ->> ChannelInfoRepository: Fetch Channel Info (cif, channelType)
ChannelInfoRepository -->> System: Channel Info
System ->> ChannelValidator: Validate Channel Info
ChannelValidator -->> System: Validation Success

alt Browser Login
    System ->> UserChannelRepository: Get User Channel (cif, channelType)
    UserChannelRepository -->> System: User Channel
    System ->> PwdHelper: Match Password
    PwdHelper -->> System: Password Match Status
end

alt Mobile Login
    System ->> UserChannelRepository: Get User Channel by User ID and Device ID
    UserChannelRepository -->> System: User Channel
    System ->> PwdHelper: Match Password
    PwdHelper -->> System: Password Match Status
end

alt Password Matched
    System ->> UserChannel: Check if Status is ACTIVE_PENDING_LOGIN
    UserChannel -->> System: Status ACTIVE_PENDING_LOGIN
    System ->> UserChannel: Update Status to ACTIVE
    System ->> UserChannelRepository: Update User Channel
    UserChannelRepository -->> System: Update Success
end

System ->> SessionRepository: Update Verification Status
SessionRepository -->> System: Update Success
System -->> User: Return Success Response


Explanation of the Diagram:
1.	User Interaction: The user initiates the process by sending a login verification request to the system.
2.	Fetching Details: The system retrieves necessary session and channel information, then validates it.
3.	Password Matching: Depending on whether the user is logging in via a browser or mobile device, the system checks the stored password against the one provided.
4.	Handling Mobile Login: If the user is logging in via a mobile device and their status is ACTIVE_PENDING_LOGIN, the system updates their status to ACTIVE.
5.	Session Update and Response: After successful verification, the system updates the session status and sends a success response back to the user.
This should give you a clearer picture of how the verify method processes login verification requests!


title Verify Login Flow (accesscontrol/cred/v4/verify)

User ->> System: Verify Login Request
System ->> SessionContext: Get session details (cif, deviceID, convID)
SessionContext -->> System: Session details
System ->> ChannelInfoRepository: Fetch Channel Info (cif, channelType)
ChannelInfoRepository -->> System: Channel Info

alt Channel Info Missing
    System ->> AppException: Throw Error (Invalid Condition)
end

System ->> ChannelValidator: Validate Channel Info
ChannelValidator -->> System: Validation Success
System ->> ChannelValidator: Verify Device ID Match
ChannelValidator -->> System: Device Match Success

System ->> UserChannelRepository: Fetch User Channel by CIF and Device ID
UserChannelRepository -->> System: User Channel

System ->> CsTransactionSF: Send OTP Transaction Request
CsTransactionSF -->> System: OTP Transaction Response

alt Transaction Success and Allow
    System ->> VerifyUserLoginResponse: Enrich Success Response
    System ->> SessionRepository: Update Session Status
    SessionRepository -->> System: Update Success
end

alt Transaction Failure
    System ->> VerifyUserLoginSF: Update Channel and Access Info (Failure)
    System ->> AppException: Throw Error (Transaction Failed)
end

System -->> User: Return VerifyUserLoginResponse (Success/Failure)

1.	User Interaction: The user starts the process by sending a login verification request.
2.	Fetching Details: The system fetches session details (CIF, device ID, conversation ID) and validates the users channel and device.
3.	Handling Missing Data: If the channel info is missing, an error is thrown, and the process stops.
4.	Processing OTP Transaction: The system processes the OTP transaction and checks if its successful.
5.	Success Flow: If the transaction is allowed, the system enriches the response and updates the session status.
6.	Failure Flow: If the transaction fails, the system updates the channel with failure status and throws an error.
7.	Returning the Response: Finally, the system returns the result of the login process, indicating success or failure.
This step-by-step breakdown and flow diagram should give you a clearer understanding of how the verify method processes the login request in version 4.

Let's explain the fix for accesscontrol/cred/v4/verify step by step and draw the corresponding sequence diagram, highlighting the fix.
Step-by-Step Explanation of the Fix
Problem Recap:
	In accesscontrol/cred/v3/verify, the system changes the users channel status from ACTIVE_PENDING_LOGIN to ACTIVE after a successful login for mobile users.
	However, in accesscontrol/cred/v4/verify, this status change logic is missing. So, users in the ACTIVE_PENDING_LOGIN state dont get their status updated to ACTIVE after logging in, causing issues like not being able to delink devices.
Fix Description:
To fix this, we need to introduce the missing logic from v3 to v4. This will ensure that after a successful login, the users channel status is updated from ACTIVE_PENDING_LOGIN to ACTIVE.
Step-by-Step Flow of the Fix:
1.	Check for Success:
o	After verifying the OTP transaction (transactionWithOtp.getResult().isSuccess()), we check if the decision from the OTP service is ALLOW. This indicates a successful login.
2.	Add the Status Update Logic:
o	If the login is successful and the user's userChannel status is ACTIVE_PENDING_LOGIN (which indicates the user had initiated a PIN reset or similar flow), we update the users status to ACTIVE.
3.	Persist the Change:
o	After updating the status, we save the updated userChannel back into the repository so that the status change is reflected in the database.
4.	Continue the Normal Flow:
o	The method proceeds with enriching the login response and updating the session verification status as it normally would after a successful login.
title Verify Login Flow with Fix (accesscontrol/cred/v4/verify)

User ->> System: Verify Login Request
System ->> SessionContext: Get session details (cif, deviceID, convID)
SessionContext -->> System: Session details
System ->> ChannelInfoRepository: Fetch Channel Info (cif, channelType)
ChannelInfoRepository -->> System: Channel Info

alt Channel Info Missing
    System ->> AppException: Throw Error (Invalid Condition)
end

System ->> ChannelValidator: Validate Channel Info
ChannelValidator -->> System: Validation Success
System ->> ChannelValidator: Verify Device ID Match
ChannelValidator -->> System: Device Match Success

System ->> UserChannelRepository: Fetch User Channel by CIF and Device ID
UserChannelRepository -->> System: User Channel

System ->> CsTransactionSF: Send OTP Transaction Request
CsTransactionSF -->> System: OTP Transaction Response

alt Transaction Success and Allow
    System ->> VerifyUserLoginResponse: Enrich Success Response
    
    alt UserChannel Status is ACTIVE_PENDING_LOGIN and Mobile
        System ->> UserChannel: Update Status to ACTIVE  // <-- Fix
        System ->> UserChannelRepository: Save Updated UserChannel  // <-- Fix
        UserChannelRepository -->> System: Update Success  // <-- Fix
    end

    System ->> SessionRepository: Update Session Status
    SessionRepository -->> System: Update Success
end

alt Transaction Failure
    System ->> VerifyUserLoginSF: Update Channel and Access Info (Failure)
    System ->> AppException: Throw Error (Transaction Failed)
end

System -->> User: Return VerifyUserLoginResponse (Success/Failure)

Explanation of the Diagram:
1.	Normal Flow:
o	The flow begins with the user sending a login verification request. The system fetches the session details, channel information, and user channel data, followed by validating the device and channel information.
2.	Processing OTP Transaction:
o	The system processes the OTP transaction and checks if the result is successful.
3.	Fix Applied:
o	After a successful OTP transaction, the system checks if the users status is ACTIVE_PENDING_LOGIN and if the user is logging in from a mobile device.
o	If both conditions are met, the system updates the users channel status to ACTIVE and saves this change to the database.
4.	Final Steps:
o	The system proceeds with enriching the login response, updating the session verification status, and returning a success response to the user.
Conclusion:
The fix ensures that when a mobile user logs in successfully, their channel status is updated from ACTIVE_PENDING_LOGIN to ACTIVE. This prevents issues such as the user not being able to delink their device later. The fix follows the existing flow and only adds a check and an update when required.


Solution 
public VerifyUserLoginResponse verify(VerifyUserLoginRequest request) {
    VerifyUserLoginResponse response = new VerifyUserLoginResponse();
    return execute(request, response, req ->{
        log.info("Verify callsign transaction is success or not.");
        
        SessionInfo session = SessionContext.getSession();
        String cif = session.getUserId();
        String deviceID = session.getDeviceID();
        String convID = session.getConvID();
        ChannelType channelType = session.getChannelType();
        log.info("verify call Cif:{}, Origin:{}, ChannelType:{}, convID:{}", cif, session.getUser()==null? null: session.getUser().getUserOrigin(), channelType, convID);
        
        ChannelInfo channelInfo  = channelInfoRepository.fetchChannelInfoByChannelUserId(channelType.name(), cif);
        if (Objects.isNull(channelInfo)){
            log.error("Inconsistent data.. User data exists in USER_CHANNEL but not in CHANNEL_INFO table. for CIF:{} and channel:{}", cif, channelType);
            throw new AppException(ErrorCodes.SYS_INVALID_CONDITION,false);
        }
        channelValidator.validateChannelInfo(channelInfo, channelType);
        channelValidator.verifyCifDeviceMatch(request.getDeviceID(), cif, deviceID);
        
        UserChannel userChannel = userChannelRepository.fetchUserChannelByUserIDAndDeviceIDActive(cif, deviceID);
        
        CsTransactionResponse transactionWithOtp = csTransactionSF.transactionWithOtp(request.getCsTransactionRequest());
        mapCSResponse(response, transactionWithOtp);
        
        if(transactionWithOtp.getResult().isSuccess() &&
                transactionWithOtp.getEtgTransactionResponse().getDecision() == DecisionEnum.ALLOW) {
            log.info("Transaction verification is successful with callsign.. enrich verify response...");
            String cin = session.getUser().getCin();
            enrichSuccessResponse(request, response, cif, cin, deviceID, convID, channelType, channelInfo, userChannel);
            
            // Add logic to update userChannel status from ACTIVE_PENDING_LOGIN to ACTIVE
            if (ChannelStatus.ACTIVE_PENDING_LOGIN == userChannel.getStatus() && channelType == ChannelType.MOBILE) {
                log.info("Bypassing RBA call for only Mobile device and ACTIVE_PENDING_LOGIN status");
                userChannel.setStatus(ChannelStatus.ACTIVE);
                userChannelRepository.updateUserChannel(userChannel);
            }
            
        } else {
            if(!transactionWithOtp.getResult().isSuccess()) {
                verifyUserLoginSF.updateChannelAndAccessInfo(false, userChannel, channelInfo);
                throw new AppException(ErrorCodes.valueOf(transactionWithOtp.getResult().getErrorInfo().getCode()));
            }
        }
        return response;
    });
}



To ensure that the fix works correctly and doesn't introduce new issues, you can perform a series of positive and negative test cases. Here's a breakdown of the use cases to validate both positive and negative testing after applying the fix to accesscontrol/cred/v4/verify.
Positive Test Cases:
1.	Successful Mobile Login with ACTIVE_PENDING_LOGIN Status:
o	Scenario: A user with ACTIVE_PENDING_LOGIN status logs in from a mobile device.
o	Expected Outcome: The user's channel status should be updated to ACTIVE, and the login should succeed. The user should be able to see their device in the managed device list and perform delinking if necessary.
2.	Successful Mobile Login with ACTIVE Status:
o	Scenario: A user with an ACTIVE status logs in from a mobile device.
o	Expected Outcome: The login should succeed without any changes to the status. The user should have normal access to all functionalities.
3.	Successful Browser Login with ACTIVE_PENDING_LOGIN Status:
o	Scenario: A user with ACTIVE_PENDING_LOGIN status logs in from a browser.
o	Expected Outcome: The user's channel status should not change (remain ACTIVE_PENDING_LOGIN), and the login should succeed.
4.	Successful Browser Login with ACTIVE Status:
o	Scenario: A user with an ACTIVE status logs in from a browser.
o	Expected Outcome: The login should succeed without any changes to the status. The user should have normal access to all functionalities.
5.	Successful OTP Transaction:
o	Scenario: A user initiates a login process that requires OTP validation, and the OTP is successfully validated.
o	Expected Outcome: The login process completes successfully, and any necessary status updates occur as per the fix.
Negative Test Cases:
1.	Failed Login Due to Incorrect Password:
o	Scenario: A user with ACTIVE_PENDING_LOGIN status tries to log in from a mobile device but enters an incorrect password.
o	Expected Outcome: The login should fail, and the user's channel status should remain ACTIVE_PENDING_LOGIN.
2.	Failed OTP Transaction:
o	Scenario: A user initiates a login process that requires OTP validation, but the OTP transaction fails (e.g., OTP is incorrect or expired).
o	Expected Outcome: The login process should fail, the users channel status should not change, and an appropriate error message should be returned.
3.	Login with Invalid Channel Information:
o	Scenario: The users channel information in the database is corrupted or missing.
o	Expected Outcome: The login process should throw an AppException with the appropriate error code indicating invalid channel information.
4.	Login with Device Mismatch:
o	Scenario: A user tries to log in from a device that does not match the stored device ID in their UserChannel.
o	Expected Outcome: The login should fail, and the user's channel status should remain unchanged.
5.	Login Attempt After Session Expiry:
o	Scenario: A user tries to log in after their session has expired.
o	Expected Outcome: The login should fail, and the system should prompt the user to re-authenticate.
6.	Edge Case - Multiple Login Attempts in Quick Succession:
o	Scenario: A user with ACTIVE_PENDING_LOGIN status attempts to log in from a mobile device multiple times in quick succession, possibly with some attempts failing and some succeeding.
o	Expected Outcome: Only successful login attempts should change the status to ACTIVE. Failed attempts should not alter the status. The system should handle concurrent updates correctly without leaving the user in an inconsistent state.
Validation Criteria:
	Status Update Validation: After each successful mobile login where the user initially had ACTIVE_PENDING_LOGIN status, verify that the status is updated to ACTIVE in the database.
	Response Validation: Ensure that the correct response is sent back to the user, indicating whether the login was successful or not.
	Error Handling: Ensure that errors are correctly handled and that appropriate exceptions are thrown and caught where necessary.
	Data Integrity: Check the integrity of the UserChannel data before and after the login process, ensuring that only the necessary changes are made.
Post-Fix Validation Process:
1.	Unit Testing:
o	Write unit tests for the verify method to cover all the above scenarios. Mock dependencies like UserChannelRepository, CsTransactionSF, etc., to simulate different outcomes.
2.	Integration Testing:
o	Test the full integration of the fix in the real environment with actual data to ensure that the fix works end-to-end without affecting other parts of the application.
3.	User Acceptance Testing (UAT):
o	Conduct UAT with real users or testers to simulate real-world scenarios, especially focusing on mobile login flows with the ACTIVE_PENDING_LOGIN status.
By performing these positive and negative test cases, you can be confident that the fix is correctly implemented and doesn't introduce new issues.





When the customer tries to update /forget the pin in the login page.
We can observer that the user_channel status gets change to ACTIVE_LOGIN_PENDING, 

And when the cm tries to login ,still customer user channel status will be ACTIVE_LOGIN_PENDING and 
when the customer checks in managed device list, The ACTIVE_LOGIN_PENDING device wont be visible to delink.

Due to the SQL query : where the query picks only ACTIVE status devices to delink  
SELECT LAST_LOGIN_SUCCESS,CREATE_DATE,DEVICE_ID,DEVICE FROM ibmbuser.USER_CHANNEL WHERE cif='1003433232' AND channel_id='MOBILE' AND status='ACTIVE';

Previously the logic
in accesscontrol/cred/v3/verify (VerifyUserLoginSF)
We had logic of making the user channel status ACTIVE_LOGIN_PENDING  ACTIVE when the customer logins in successfully.


But in the new implementation ,
accesscontrol/cred/v4/verify( VerifyUserLoginV2SF)
we dont have that logic to make user channel status ACTIVE_LOGIN_PENDING  ACTIVE .

Version 3

   /**
	 * Verify Login Credentials
	 * USAGE: LOGIN,REGISTRATION (LAST STEP)
	 * @param request
	 * @return VerifyUserLoginResponse
	 */
	//@Interceptors(TracingInterceptor.class)
	public VerifyUserLoginResponse verify(VerifyUserLoginRequest request, boolean isPayit) {
		VerifyUserLoginResponse verifyUserLoginResponse = new VerifyUserLoginResponse();
		return  execute(request,verifyUserLoginResponse, req->{
			verifyUserLoginResponse.setCurrentDate(DateTimeHelper.INSTANCE.formatDate(new Date(), AppConstants.DATE_DDMMYYYY));
			SessionInfo session = SessionContext.getSession();
			String cif = session.getUserId();
			String deviceID = session.getDeviceID();
			String convID = session.getConvID();
			ChannelType channelType = session.getChannelType();
			log.info("verify call Cif:{}, Origin:{}, ChannelType:{}, convID:{}", cif, session.getUser()==null? null: session.getUser().getUserOrigin(), channelType, convID);

			ChannelInfo channelInfo  = channelInfoRepository.fetchChannelInfoByChannelUserId(channelType.name(), cif);
			channelValidator.validateChannelInfo(channelInfo, channelType);

			boolean pwdMatched = false;
			UserChannel userChannel = null;
			// String status = null;
			//boolean isCallsignEnabledForPublic = settingsRepository.isCallsignAuthPublicEnabled();
			//boolean isCallsignEnabledForCust = channelInfoRepository.isCallsignAuthEnabled(cif);
			if(ChannelType.BROWSER == channelType) {
				checkTrottle();
				userChannel = getUserChannel(cif, channelType);
				if(Objects.nonNull(userChannel)) {
					// Load Customer position
					mqNotifier.refreshCustomerPositionCache(userChannel.getCin());
				}

				/* Commented below code for PRM-2076
				 * if(ChannelStatus.ACTIVE_PENDING_LOGIN == userChannel.getStatus()) {
					if(session.getUser().getUserOrigin() == UserOrigin.NBAD){
						String username = null;
						if(StringUtils.isNotBlank(userChannel.getUserName())){
							username = userChannel.getUserName();
						}else{
							log.warn("Username is not present in migrated NBAD customer data to authenticate");
							username = request.getUserName();							
						}
						status = nbadUserAuthServiceInvoker.authenticateNbadUser(username, request.getPwd1());
						pwdMatched = AppConstants.SUCCESS.equals(status)?true:false;
						log.info("NBAD PWD status check completed :{}",pwdMatched);
						
					} else if (session.getUser().getUserOrigin() == UserOrigin.FGB){
						String diPwd = channelInfoRepository.fetchDiUserId(cif);
						pwdMatched =  Objects.isNull(userChannel.getPwd()) ? false : PwdHelper.matchDigests(request.getPwd1(), diPwd);
						if(pwdMatched){
							status = AppConstants.SUCCESS;
						}
						log.info("FGB PWD status check completed :{}",pwdMatched);
					}
					
					if(Objects.nonNull(status ) &&AppConstants.SUCCESS.equalsIgnoreCase(status)) {
						verifyUserLoginResponse.setStartPage(FORCE_PASSWORD_UPDATE_FLOW);
						pwdMatched = true;
					}
				} else {*/
					pwdMatched =  Objects.isNull(userChannel.getPwd()) ? false : PwdHelper.match(userChannel.getPwd(), request.getPwd());
				//}
				
				if(pwdMatched){
					checkUsernameConstraints(verifyUserLoginResponse, userChannel);
					preferencesRepository.updateUserAlertPreference(cif, ContentID.LOGIN_SUCCESS.name(), false, EMAIL);
				}
			// Mobile device
			} else {
				//channelValidator.isForceAppUpdateRequired(session);
				userChannel = userChannelRepository.fetchUserChannelByUserIDAndDeviceIDActive(cif, deviceID);
				
				//FMDB-47518-changes
				
				if(Objects.nonNull(userChannel) && Objects.nonNull(request.getPushSettings())) {
						log.info("Populating the Push Settings value");
						userChannel.setPushSettings(request.getPushSettings());
				}
				//FMDB-47518-changes end
				
				channelValidator.verifyCifDeviceMatch(request.getDeviceID(), cif, deviceID);
				boolean isCallsignMigrated = TextUtils.INSTANCE.getBoolean(userChannel.getCallsignMigrate());
				if (isCallsignMigrated) {
					pwdMatched = verifyLoginTransactionWithCs(req, true);
				} else {
					pwdMatched = Objects.isNull(userChannel.getPwd()) ? false : PwdHelper.match(userChannel.getPwd(), request.getPwd());
				}
				if(pwdMatched) {
					preferencesRepository.updateUserAlertPreference(cif, ContentID.LOGIN_SUCCESS.name(), false, EMAIL);
					//SMS should be disabled
					preferencesRepository.updateUserAlertPreference(cif, ContentID.LOGIN_SUCCESS.name(), false, AppConstants.SMS);
				}
			}
			
			if (Objects.isNull(channelInfo)){
				log.error("Inconsistent data.. User data exists in USER_CHANNEL but not in CHANNEL_INFO table. for CIF:{} and channel:{}", cif, channelType);
				throw new AppException(ErrorCodes.SYS_INVALID_CONDITION,false);
			}

			log.info("userChannel {} | deviceID {} | cif {} | pwdMatched {} | convID {} ",userChannel,deviceID,cif ,pwdMatched ,convID);
			boolean isLoginRequestComing4mRegistrationFlow = isLoginRequestComing4mRegistrationFlow(userChannel);
			//updateChannelAndAccessInfo(pwdMatched, userChannel, channelInfo);
			updateChannelAndAccessInfo(pwdMatched, userChannel, channelInfo);
			
			if(!pwdMatched){
				notifyPasswordFailure(userChannel);
				return populateErrorResponse(verifyUserLoginResponse,userChannel);
			} 
			String cin = session.getUser().getCin();
			boolean isLoggedinSuccess = true;
			String refId = updateReferenceId(session.getUser(), channelInfo);
			if (isLoginRequestComing4mRegistrationFlow && ChannelStatus.ACTIVE_PENDING_LOGIN != userChannel.getStatus()) {
				enrichLoginResponse(verifyUserLoginResponse, cif, convID, deviceID, userChannel, channelType, cin, 
						isPayit, request.getVersion(), false);
				verifyUserLoginResponse.setRiskEvaluationAdvice(RiskAction.ALLOW.name());
				verifyUserLoginResponse.setRiskEvaluationDeviceId(null);
				log.info("update customer as verified");
				sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
			// This will come only when Mobile user come from forgot PIN flow to exclude RBA
			} else if (ChannelStatus.ACTIVE_PENDING_LOGIN == userChannel.getStatus() && channelType == ChannelType.MOBILE) {
				log.info("bypassing RBA call for only Mobile device and ACTIVE_PENDING_LOGIN status");
				userChannel.setStatus(ChannelStatus.ACTIVE);
				userChannelRepository.updateUserChannel(userChannel);
				enrichLoginResponse(verifyUserLoginResponse, cif,convID, deviceID, userChannel, channelType, cin,
						isPayit, request.getVersion(), false);
				log.info("update customer as verified");
				sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
			} else {
				/*int deviceCount = channelValidator.noOfCsMobileRegistration(cif);
				if ((!isCallsignEnabledForPublic && !callsignAuthHelper.isPilotCustomerForCallsign(session, channelType,isCallsignEnabledForCust))
						|| (deviceCount == 0 && ChannelType.BROWSER == channelType)) {
					log.info("Checking RBA for convID:{}, channel:{} and CIF:{}", convID, channelType, cif);
					riskSF.evaluateRisk(request, cif, verifyUserLoginResponse, false, channelType);
					if (RiskAction.INCREASEAUTH.name().equals(verifyUserLoginResponse.getRiskEvaluationAdvice())) {
						isLoggedinSuccess = false;
						processRiskAdvice(verifyUserLoginResponse, convID, cif,userChannel);
					} else if (RiskAction.ALLOW.name().equals(verifyUserLoginResponse.getRiskEvaluationAdvice())) {
						enrichLoginResponse(verifyUserLoginResponse, cif,convID, deviceID, userChannel, channelType, cin, isPayit, request.getVersion());
						log.info("update customer as verified");
						sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
					}*/
//				} else {
					log.info("Callsign is enabled skipping RBA rules and initiating request to callsign.");
					isLoggedinSuccess = false;

					/*if (Objects.isNull(request.getCsTransactionRequest()) || 
							(Objects.nonNull(request.getCsTransactionRequest()) 
									&& (StringUtils.isBlank(request.getCsTransactionRequest().getCsTransactionId())
											|| request.getCsTransactionRequest().getTransactionType() == null))) {
						throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
					}*/
					
					boolean isCallsignMigrated = TextUtils.INSTANCE.getBoolean(userChannel.getCallsignMigrate());
					/**
					 * verification for callsign migration
					 */
					if(!isCallsignMigrated) { // Only when the user is not created in callsign, create user
						/**
						 * Create user in scim
						 */
						APIResponse createUserRes = csUserManagementSF.createUser(refId);

						if (!createUserRes.getResult().isSuccess()) {
							throw new AppException(ErrorCodes.CS_CREATE_USER_FAILED);
						}
					}
					
					if(channelType == ChannelType.BROWSER) {
						String val = settingsRepository.getSetting(AppConstants.IB_WHATS_NEW_SCREEN);
						verifyUserLoginResponse.setIbWhatsNewScreen(TextUtils.INSTANCE.getBoolean(val));

						// Initiate Transaction for push notification etg
						CsTransactionResponse etgResponse = csTransactionSF.initiateTransaction(request.getCsTransactionRequest());
						
						if(!etgResponse.getResult().isSuccess()) {
							String message = etgResponse.getEtgTransactionResponse().getMessage();
							log.error("VerifyUserLogin - message : {}", message);
							if (StringUtils.isNotBlank(message)
									&& (message.equals(AppConstants.REG_MOBILE_CHANNEL_LOCKED)
											|| message.equals(AppConstants.RESET_MOBILE_CHANNEL_LOCKED)
											|| message.equals(AppConstants.LOGIN_MOBILE_CHANNEL_LOCKED))) {
								csTransactionHelper.processErrorBasedOnMessage(message);
							} else {
								throw new AppException(ErrorCodes.CS_TRANSACTION_INITIATE_FAILED);
							}
						}
						
						/*CsTransactionRequest csTransactionRequest = request.getCsTransactionRequest();
						csTransactionRequest.setAuthenticator(etgResponse.getEtgTransactionResponse().getAuthenticator());
						csTransactionRequest.setRequirementsCombination(etgResponse.getEtgTransactionResponse().getRequirementsCombination());
						csTransactionRequest.setRequirementId(etgResponse.getEtgTransactionResponse().getRequirementId());
						
						csTransactionRequest.setSuccessResultMap(true);
						log.info("VerifyUserLoginSF.verify. verifying login request with context : {}",csTransactionRequest);
						CsTransactionResponse etgUpdateResponse = csTransactionSF.updateTransaction(csTransactionRequest);
						
						if(!etgUpdateResponse.getResult().isSuccess()) {
							throw new AppException(ErrorCodes.CS_TRANSACTION_INITIATE_FAILED);
						}*/
						
						if(etgResponse.getEtgTransactionResponse().getDecision() == DecisionEnum.REFER) {
							verifyUserLoginResponse.setCsTxnActiveAllowedAttempts(etgResponse.getCsTxnActiveAllowedAttempts());
							verifyUserLoginResponse.setCsTxnActiveMaxResendAttempts(etgResponse.getCsTxnActiveMaxResendAttempts());
							verifyUserLoginResponse.setCsTxnActiveTimeInSeconds(etgResponse.getCsTxnActiveTimeInSeconds());
						} else if(etgResponse.getEtgTransactionResponse().getDecision() == DecisionEnum.ALLOW) {
							verifyUserLoginResponse.setRiskEvaluationAdvice(AppConstants.ALLOW);
							sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
							enrichLoginResponse(verifyUserLoginResponse, cif, convID, deviceID, userChannel, channelType, cin, 
									isPayit, request.getVersion(), false);
							isLoggedinSuccess = true;
							//Update user channel to callsign migrated to Y.
							if(!isCallsignMigrated) { 
								userChannel.setCallsignMigrate(AppConstants.Y);
								userChannelRepository.updateUserChannel(userChannel);
							}
						}
						
						verifyUserLoginResponse.setEtgTransactionResponse(etgResponse	.getEtgTransactionResponse());
						verifyUserLoginResponse.getEtgTransactionResponse().clearPIIData();
						
						//If ALLOW, set isLoggedinSuccess to true
					} else {
						if(sessionRepository.isOtpREtgVerfied(convID)) {
							isLoggedinSuccess = true;
							enrichLoginResponse(verifyUserLoginResponse, cif, convID, deviceID, userChannel, channelType, cin,
									isPayit, request.getVersion(), false);
						} 
					}
//				}
			}

			enrichPostLoginDetails(verifyUserLoginResponse, session, cif, convID, channelType, userChannel, cin,
					isLoggedinSuccess);
			
			return verifyUserLoginResponse;
		});
	}
   
   

Version 4

   /**
	 * Verify Login Credentials
	 * USAGE: LOGIN (LAST STEP)
	 * @param request
	 * @return VerifyUserLoginResponse
	 */
	public VerifyUserLoginResponse verify(VerifyUserLoginRequest request) {
		VerifyUserLoginResponse response = new VerifyUserLoginResponse();
		return execute(request, response, req ->{
			log.info("Verify callsign transaction is success or not.");
			
			SessionInfo session = SessionContext.getSession();
			String cif = session.getUserId();
			String deviceID = session.getDeviceID();
			String convID = session.getConvID();
			ChannelType channelType = session.getChannelType();
			log.info("verify call Cif:{}, Origin:{}, ChannelType:{}, convID:{}", cif, session.getUser()==null? null: session.getUser().getUserOrigin(), channelType, convID);
			
			ChannelInfo channelInfo  = channelInfoRepository.fetchChannelInfoByChannelUserId(channelType.name(), cif);
			if (Objects.isNull(channelInfo)){
				log.error("Inconsistent data.. User data exists in USER_CHANNEL but not in CHANNEL_INFO table. for CIF:{} and channel:{}", cif, channelType);
				throw new AppException(ErrorCodes.SYS_INVALID_CONDITION,false);
			}
			channelValidator.validateChannelInfo(channelInfo, channelType);
			channelValidator.verifyCifDeviceMatch(request.getDeviceID(), cif, deviceID);
			
			UserChannel userChannel = userChannelRepository.fetchUserChannelByUserIDAndDeviceIDActive(cif, deviceID);
			
			CsTransactionResponse transactionWithOtp = csTransactionSF.transactionWithOtp(request.getCsTransactionRequest());
			mapCSResponse(response, transactionWithOtp);
			
			if(transactionWithOtp.getResult().isSuccess() &&
					transactionWithOtp.getEtgTransactionResponse().getDecision() == DecisionEnum.ALLOW) {
				log.info("Transaction verification is successful with callsign.. enrich verify response...");
				String cin = session.getUser().getCin();
				enrichSuccessResponse(request, response, cif, cin, deviceID, convID, channelType, channelInfo, userChannel);
				
			} else {
				if(!transactionWithOtp.getResult().isSuccess()) {
					verifyUserLoginSF.updateChannelAndAccessInfo(false, userChannel, channelInfo);
					throw new AppException(ErrorCodes.valueOf(transactionWithOtp.getResult().getErrorInfo().getCode()));
				}
			}
			return response;
		}) ;
		
	}

======================

/**
	 * Verify Login Credentials
	 * USAGE: LOGIN,REGISTRATION (LAST STEP)
	 * @param request
	 * @return VerifyUserLoginResponse
	 */
	//@Interceptors(TracingInterceptor.class)
	public VerifyUserLoginResponse verify(VerifyUserLoginRequest request, boolean isPayit) {
		VerifyUserLoginResponse verifyUserLoginResponse = new VerifyUserLoginResponse();
		return  execute(request,verifyUserLoginResponse, req->{
			verifyUserLoginResponse.setCurrentDate(DateTimeHelper.INSTANCE.formatDate(new Date(), AppConstants.DATE_DDMMYYYY));
			SessionInfo session = SessionContext.getSession();
			String cif = session.getUserId();
			String deviceID = session.getDeviceID();
			String convID = session.getConvID();
			ChannelType channelType = session.getChannelType();
			log.info("verify call Cif:{}, Origin:{}, ChannelType:{}, convID:{}", cif, session.getUser()==null? null: session.getUser().getUserOrigin(), channelType, convID);

			ChannelInfo channelInfo  = channelInfoRepository.fetchChannelInfoByChannelUserId(channelType.name(), cif);
			channelValidator.validateChannelInfo(channelInfo, channelType);

			boolean pwdMatched = false;
			UserChannel userChannel = null;
			// String status = null;
			//boolean isCallsignEnabledForPublic = settingsRepository.isCallsignAuthPublicEnabled();
			//boolean isCallsignEnabledForCust = channelInfoRepository.isCallsignAuthEnabled(cif);
			if(ChannelType.BROWSER == channelType) {
				checkTrottle();
				userChannel = getUserChannel(cif, channelType);
				if(Objects.nonNull(userChannel)) {
					// Load Customer position
					mqNotifier.refreshCustomerPositionCache(userChannel.getCin());
				}

				/* Commented below code for PRM-2076
				 * if(ChannelStatus.ACTIVE_PENDING_LOGIN == userChannel.getStatus()) {
					if(session.getUser().getUserOrigin() == UserOrigin.NBAD){
						String username = null;
						if(StringUtils.isNotBlank(userChannel.getUserName())){
							username = userChannel.getUserName();
						}else{
							log.warn("Username is not present in migrated NBAD customer data to authenticate");
							username = request.getUserName();							
						}
						status = nbadUserAuthServiceInvoker.authenticateNbadUser(username, request.getPwd1());
						pwdMatched = AppConstants.SUCCESS.equals(status)?true:false;
						log.info("NBAD PWD status check completed :{}",pwdMatched);
						
					} else if (session.getUser().getUserOrigin() == UserOrigin.FGB){
						String diPwd = channelInfoRepository.fetchDiUserId(cif);
						pwdMatched =  Objects.isNull(userChannel.getPwd()) ? false : PwdHelper.matchDigests(request.getPwd1(), diPwd);
						if(pwdMatched){
							status = AppConstants.SUCCESS;
						}
						log.info("FGB PWD status check completed :{}",pwdMatched);
					}
					
					if(Objects.nonNull(status ) &&AppConstants.SUCCESS.equalsIgnoreCase(status)) {
						verifyUserLoginResponse.setStartPage(FORCE_PASSWORD_UPDATE_FLOW);
						pwdMatched = true;
					}
				} else {*/
					pwdMatched =  Objects.isNull(userChannel.getPwd()) ? false : PwdHelper.match(userChannel.getPwd(), request.getPwd());
				//}
				
				if(pwdMatched){
					checkUsernameConstraints(verifyUserLoginResponse, userChannel);
					preferencesRepository.updateUserAlertPreference(cif, ContentID.LOGIN_SUCCESS.name(), false, EMAIL);
				}
			// Mobile device
			} else {
				//channelValidator.isForceAppUpdateRequired(session);
				userChannel = userChannelRepository.fetchUserChannelByUserIDAndDeviceIDActive(cif, deviceID);
				
				//FMDB-47518-changes
				
				if(Objects.nonNull(userChannel) && Objects.nonNull(request.getPushSettings())) {
						log.info("Populating the Push Settings value");
						userChannel.setPushSettings(request.getPushSettings());
				}
				//FMDB-47518-changes end
				
				channelValidator.verifyCifDeviceMatch(request.getDeviceID(), cif, deviceID);
				boolean isCallsignMigrated = TextUtils.INSTANCE.getBoolean(userChannel.getCallsignMigrate());
				if (isCallsignMigrated) {
					pwdMatched = verifyLoginTransactionWithCs(req, true);
				} else {
					pwdMatched = Objects.isNull(userChannel.getPwd()) ? false : PwdHelper.match(userChannel.getPwd(), request.getPwd());
				}
				if(pwdMatched) {
					preferencesRepository.updateUserAlertPreference(cif, ContentID.LOGIN_SUCCESS.name(), false, EMAIL);
					//SMS should be disabled
					preferencesRepository.updateUserAlertPreference(cif, ContentID.LOGIN_SUCCESS.name(), false, AppConstants.SMS);
				}
			}
			
			if (Objects.isNull(channelInfo)){
				log.error("Inconsistent data.. User data exists in USER_CHANNEL but not in CHANNEL_INFO table. for CIF:{} and channel:{}", cif, channelType);
				throw new AppException(ErrorCodes.SYS_INVALID_CONDITION,false);
			}

			log.info("userChannel {} | deviceID {} | cif {} | pwdMatched {} | convID {} ",userChannel,deviceID,cif ,pwdMatched ,convID);
			boolean isLoginRequestComing4mRegistrationFlow = isLoginRequestComing4mRegistrationFlow(userChannel);
			//updateChannelAndAccessInfo(pwdMatched, userChannel, channelInfo);
			updateChannelAndAccessInfo(pwdMatched, userChannel, channelInfo);
			
			if(!pwdMatched){
				notifyPasswordFailure(userChannel);
				return populateErrorResponse(verifyUserLoginResponse,userChannel);
			} 
			String cin = session.getUser().getCin();
			boolean isLoggedinSuccess = true;
			String refId = updateReferenceId(session.getUser(), channelInfo);
			if (isLoginRequestComing4mRegistrationFlow && ChannelStatus.ACTIVE_PENDING_LOGIN != userChannel.getStatus()) {
				enrichLoginResponse(verifyUserLoginResponse, cif, convID, deviceID, userChannel, channelType, cin, 
						isPayit, request.getVersion(), false);
				verifyUserLoginResponse.setRiskEvaluationAdvice(RiskAction.ALLOW.name());
				verifyUserLoginResponse.setRiskEvaluationDeviceId(null);
				log.info("update customer as verified");
				sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
			// This will come only when Mobile user come from forgot PIN flow to exclude RBA
			} else if (ChannelStatus.ACTIVE_PENDING_LOGIN == userChannel.getStatus() && channelType == ChannelType.MOBILE) {
				log.info("bypassing RBA call for only Mobile device and ACTIVE_PENDING_LOGIN status");
				userChannel.setStatus(ChannelStatus.ACTIVE);
				userChannelRepository.updateUserChannel(userChannel);
				enrichLoginResponse(verifyUserLoginResponse, cif,convID, deviceID, userChannel, channelType, cin,
						isPayit, request.getVersion(), false);
				log.info("update customer as verified");
				sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
			} else {
				/*int deviceCount = channelValidator.noOfCsMobileRegistration(cif);
				if ((!isCallsignEnabledForPublic && !callsignAuthHelper.isPilotCustomerForCallsign(session, channelType,isCallsignEnabledForCust))
						|| (deviceCount == 0 && ChannelType.BROWSER == channelType)) {
					log.info("Checking RBA for convID:{}, channel:{} and CIF:{}", convID, channelType, cif);
					riskSF.evaluateRisk(request, cif, verifyUserLoginResponse, false, channelType);
					if (RiskAction.INCREASEAUTH.name().equals(verifyUserLoginResponse.getRiskEvaluationAdvice())) {
						isLoggedinSuccess = false;
						processRiskAdvice(verifyUserLoginResponse, convID, cif,userChannel);
					} else if (RiskAction.ALLOW.name().equals(verifyUserLoginResponse.getRiskEvaluationAdvice())) {
						enrichLoginResponse(verifyUserLoginResponse, cif,convID, deviceID, userChannel, channelType, cin, isPayit, request.getVersion());
						log.info("update customer as verified");
						sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
					}*/
//				} else {
					log.info("Callsign is enabled skipping RBA rules and initiating request to callsign.");
					isLoggedinSuccess = false;

					/*if (Objects.isNull(request.getCsTransactionRequest()) || 
							(Objects.nonNull(request.getCsTransactionRequest()) 
									&& (StringUtils.isBlank(request.getCsTransactionRequest().getCsTransactionId())
											|| request.getCsTransactionRequest().getTransactionType() == null))) {
						throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
					}*/
					
					boolean isCallsignMigrated = TextUtils.INSTANCE.getBoolean(userChannel.getCallsignMigrate());
					/**
					 * verification for callsign migration
					 */
					if(!isCallsignMigrated) { // Only when the user is not created in callsign, create user
						/**
						 * Create user in scim
						 */
						APIResponse createUserRes = csUserManagementSF.createUser(refId);

						if (!createUserRes.getResult().isSuccess()) {
							throw new AppException(ErrorCodes.CS_CREATE_USER_FAILED);
						}
					}
					
					if(channelType == ChannelType.BROWSER) {
						String val = settingsRepository.getSetting(AppConstants.IB_WHATS_NEW_SCREEN);
						verifyUserLoginResponse.setIbWhatsNewScreen(TextUtils.INSTANCE.getBoolean(val));

						// Initiate Transaction for push notification etg
						CsTransactionResponse etgResponse = csTransactionSF.initiateTransaction(request.getCsTransactionRequest());
						
						if(!etgResponse.getResult().isSuccess()) {
							String message = etgResponse.getEtgTransactionResponse().getMessage();
							log.error("VerifyUserLogin - message : {}", message);
							if (StringUtils.isNotBlank(message)
									&& (message.equals(AppConstants.REG_MOBILE_CHANNEL_LOCKED)
											|| message.equals(AppConstants.RESET_MOBILE_CHANNEL_LOCKED)
											|| message.equals(AppConstants.LOGIN_MOBILE_CHANNEL_LOCKED))) {
								csTransactionHelper.processErrorBasedOnMessage(message);
							} else {
								throw new AppException(ErrorCodes.CS_TRANSACTION_INITIATE_FAILED);
							}
						}
						
						/*CsTransactionRequest csTransactionRequest = request.getCsTransactionRequest();
						csTransactionRequest.setAuthenticator(etgResponse.getEtgTransactionResponse().getAuthenticator());
						csTransactionRequest.setRequirementsCombination(etgResponse.getEtgTransactionResponse().getRequirementsCombination());
						csTransactionRequest.setRequirementId(etgResponse.getEtgTransactionResponse().getRequirementId());
						
						csTransactionRequest.setSuccessResultMap(true);
						log.info("VerifyUserLoginSF.verify. verifying login request with context : {}",csTransactionRequest);
						CsTransactionResponse etgUpdateResponse = csTransactionSF.updateTransaction(csTransactionRequest);
						
						if(!etgUpdateResponse.getResult().isSuccess()) {
							throw new AppException(ErrorCodes.CS_TRANSACTION_INITIATE_FAILED);
						}*/
						
						if(etgResponse.getEtgTransactionResponse().getDecision() == DecisionEnum.REFER) {
							verifyUserLoginResponse.setCsTxnActiveAllowedAttempts(etgResponse.getCsTxnActiveAllowedAttempts());
							verifyUserLoginResponse.setCsTxnActiveMaxResendAttempts(etgResponse.getCsTxnActiveMaxResendAttempts());
							verifyUserLoginResponse.setCsTxnActiveTimeInSeconds(etgResponse.getCsTxnActiveTimeInSeconds());
						} else if(etgResponse.getEtgTransactionResponse().getDecision() == DecisionEnum.ALLOW) {
							verifyUserLoginResponse.setRiskEvaluationAdvice(AppConstants.ALLOW);
							sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
							enrichLoginResponse(verifyUserLoginResponse, cif, convID, deviceID, userChannel, channelType, cin, 
									isPayit, request.getVersion(), false);
							isLoggedinSuccess = true;
							//Update user channel to callsign migrated to Y.
							if(!isCallsignMigrated) { 
								userChannel.setCallsignMigrate(AppConstants.Y);
								userChannelRepository.updateUserChannel(userChannel);
							}
						}
						
						verifyUserLoginResponse.setEtgTransactionResponse(etgResponse	.getEtgTransactionResponse());
						verifyUserLoginResponse.getEtgTransactionResponse().clearPIIData();
						
						//If ALLOW, set isLoggedinSuccess to true
					} else {
						if(sessionRepository.isOtpREtgVerfied(convID)) {
							isLoggedinSuccess = true;
							enrichLoginResponse(verifyUserLoginResponse, cif, convID, deviceID, userChannel, channelType, cin,
									isPayit, request.getVersion(), false);
						} 
					}
//				}
			}

			enrichPostLoginDetails(verifyUserLoginResponse, session, cif, convID, channelType, userChannel, cin,
					isLoggedinSuccess);
			
			return verifyUserLoginResponse;
		});
	}
   
   
   -----------------------------------------------------------------
   
   /**
	 * Verify Login Credentials
	 * USAGE: LOGIN (LAST STEP)
	 * @param request
	 * @return VerifyUserLoginResponse
	 */
	public VerifyUserLoginResponse verify(VerifyUserLoginRequest request) {
		VerifyUserLoginResponse response = new VerifyUserLoginResponse();
		return execute(request, response, req ->{
			log.info("Verify callsign transaction is success or not.");
			
			SessionInfo session = SessionContext.getSession();
			String cif = session.getUserId();
			String deviceID = session.getDeviceID();
			String convID = session.getConvID();
			ChannelType channelType = session.getChannelType();
			log.info("verify call Cif:{}, Origin:{}, ChannelType:{}, convID:{}", cif, session.getUser()==null? null: session.getUser().getUserOrigin(), channelType, convID);
			
			ChannelInfo channelInfo  = channelInfoRepository.fetchChannelInfoByChannelUserId(channelType.name(), cif);
			if (Objects.isNull(channelInfo)){
				log.error("Inconsistent data.. User data exists in USER_CHANNEL but not in CHANNEL_INFO table. for CIF:{} and channel:{}", cif, channelType);
				throw new AppException(ErrorCodes.SYS_INVALID_CONDITION,false);
			}
			channelValidator.validateChannelInfo(channelInfo, channelType);
			channelValidator.verifyCifDeviceMatch(request.getDeviceID(), cif, deviceID);
			
			UserChannel userChannel = userChannelRepository.fetchUserChannelByUserIDAndDeviceIDActive(cif, deviceID);
			
			CsTransactionResponse transactionWithOtp = csTransactionSF.transactionWithOtp(request.getCsTransactionRequest());
			mapCSResponse(response, transactionWithOtp);
			
			if(transactionWithOtp.getResult().isSuccess() &&
					transactionWithOtp.getEtgTransactionResponse().getDecision() == DecisionEnum.ALLOW) {
				log.info("Transaction verification is successful with callsign.. enrich verify response...");
				String cin = session.getUser().getCin();
				enrichSuccessResponse(request, response, cif, cin, deviceID, convID, channelType, channelInfo, userChannel);
				
			} else {
				if(!transactionWithOtp.getResult().isSuccess()) {
					verifyUserLoginSF.updateChannelAndAccessInfo(false, userChannel, channelInfo);
					throw new AppException(ErrorCodes.valueOf(transactionWithOtp.getResult().getErrorInfo().getCode()));
				}
			}
			return response;
		}) ;
		
	}

import boto3
import csv
import httpx
import json 
import base64
import ssl
import uuid
import logging
import os
import io
from base64 import b64decode
from datetime import datetime
from urllib.parse import unquote

PASSWORD = 'p@ssw0rd'

CLIENT_CERT =  r'C:\Users\O22665\Documents\Repo\pn-token-sync\code\ssl\uat\client.crt'

SERVER_KEY = r'C:\Users\O22665\Documents\Repo\pn-token-sync\code\ssl\uat\client.key'

CA_CERT = r'C:\Users\O22665\Documents\Repo\pn-token-sync\code\ssl\uat\certificate.pem'

INTERNAL_API_KEY = 'j60AqcESvkfSDad5NMyy80Xl6fSq0HR6Fvlowjw6'
 
'''

Creation of SSL Context for ssl certificate verification.

'''

sslcontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)

sslcontext.verify_mode = ssl.CERT_REQUIRED

sslcontext.check_hostname = True

sslcontext.load_verify_locations(cafile=CA_CERT)

sslcontext.load_cert_chain(CLIENT_CERT,SERVER_KEY,PASSWORD)
 

# Method to fetch customer data based on CIN
def get_customer_data(cin):
    #url= os.environ['GET_CUSTOMER_DETAILS']
    url="https://kproxy-uat.pcdigital-dev.aeapps.bankfab.com/customer-profile/v2/customer-detail"
    xref = str(uuid.uuid4())
    headers = {'XREF': xref, 'CHANNELID': 'IB','LANGUAGE':'EN'}
    currectDate = datetime.now()
    data = {
    "applicationArea": {
        "countryOfOrigin": "AE",
        "creationDateTime": str(currectDate),
        "requiredExecutionDate": str(currectDate),
        "senderId": "IB",
        "transactionDateTime": str(currectDate),
        "transactionId": xref,
        "language": "EN"
    },
    "dataArea": {
        "customerIdentifier": cin,
        "accountingUnitIdentifier": "AE0010001"
    }
    }
    data = json.dumps(data)
    print("data")
    print(data)
    response = httpx.post(url,headers=headers, data=data, verify = sslcontext)
    print("response")
    print(response)
    json_reponse = response.json()
    if response.status_code == 200:
        print(f"Customer detail response received for CIN : {cin}")
        return json_reponse
    else:
        print(f"Customer detail Error response received for CIN : {cin}")
        return None
    
if __name__ == '__main__':
    get_customer_data("123456")

{
    "applicationArea": {
        "countryOfOrigin": "AE",
        "creationDateTime": "2024-08-23 13:08:10.554199",
        "requiredExecutionDate": "2024-08-23 13:08:10.554199",
        "senderId": "IB",
        "transactionDateTime": "2024-08-23 13:08:10.554199",
        "transactionId": "2ad0cdd5-9064-4fbb-a6d7-b86f5a5a8fc7",
        "language": "EN"
    },
    "dataArea": {
        "customerIdentifier": "3396985",
        "accountingUnitIdentifier": "AE0010001"
    }
}

{
   "applicationArea":    {
      "countryOfOrigin": "AE",
      "senderId": "IB",
      "transactionId": "2ad0cdd5-9064-4fbb-a6d7-b86f5a5a8fc7",
      "transactionDateTime": "2024-08-23 13:08:10.554199",
      "language": "EN",
      "creationDateTime": "2024-08-23 13:08:10.554199",
      "requiredExecutionDate": "2024-08-23 13:08:10.554199"
   },
   "responseStatus": {"status": "SUCCESS"},
   "dataArea":    {
      "fullName": "",
      "prefix": "MR",
      "birthDate": "1970-01-01",
      "gender": "M",
      "ltGender": "M",
      "nationality": "PK",
      "emirate": "UMQ",
      "country": "Umm Al Quwain,ARE",
      "maritalStatus": "MARRIED",
      "isResident": "Y",
      "shortName": "bansswap",
      "customerIdentifier": "3396985",
      "customerType": "Individual",
      "customerOpenDate": "2010-07-21",
      "accountingUnitIdentifier": "AE0010001",
      "mothersMaidenName": "FGB SCRAMBLE OWN.CAR",
      "placeOfBirth": "PK",
      "amlSegment": "L",
      "segment": "",
      "isStaff": false,
      "employment":       {
         "employerName": "",
         "employerName2": "FGB SCRAMBLE COMPANY NAME",
         "monthlySalary": "100000.00",
         "employmentStatus": ""
      },
      "additionalCustomerInfo":       {
         "segment": "",
         "customerRateSegment": "Premium",
         "target": "30",
         "accountOfficer": "142",
         "language": "1",
         "startDate": "2010-07-21",
         "nameOnCard": "FGB SCRAMBLE CARD NAM",
         "sector": "4000",
         "profession": "Engineer",
         "subSegment": "6202",
         "relationshipManager": "",
         "vatCategory": "004",
         "constitution": "",
         "dateOfBirth": "2013-03-14",
         "otherOfficer":          [
            "",
            "",
            "",
            ""
         ],
         "country":          [
            "ARE",
            "",
            "",
            ""
         ],
         "customerResidence":          [
            "AE",
            "",
            "",
            ""
         ],
         "ownerName":          [
            "FGB SCRAMBLE OWNER NAME",
            "",
            "",
            ""
         ],
         "ownerNationality":          [
            "",
            "",
            "",
            ""
         ],
         "percentOwner":          [
            "",
            "",
            "",
            ""
         ],
         "riskCategory": "",
         "riskAgreement": "",
         "relationCustomer":          [
            "",
            "",
            "",
            ""
         ],
         "relationCode":          [
            "",
            "",
            "",
            ""
         ],
         "reverseRelationCode":          [
            "",
            "",
            "",
            ""
         ],
         "customerEducationalBackground": "",
         "customerAgeClassification": "MAJOR",
         "powerOfAttorneyFlag": "N"
      },
      "kycInfo":       {
         "kycFlag": "",
         "kycDate": "2010-07-21",
         "kycExpiryDate": "2015-07-21",
         "isKYCUsingEID": false
      },
      "identity":       [
                  {
            "identityType": "EMI",
            "identityNumber": "",
            "identityExpiryDate": "2021-04-12"
         },
                  {
            "identityType": "VIS",
            "identityNumber": "101201770341826",
            "identityExpiryDate": "2020-11-26"
         },
                  {
            "identityType": "PAS",
            "identityNumber": "G1010101",
            "identityExpiryDate": "2018-08-11"
         }
      ],
      "address": [      {
         "addressLine1": "PO Box 56865 Ggh No888",
         "addressLine2": "Hamdan street EEkoc hi",
         "city": "Umm Al Quwain,ARE",
         "country": "ARE",
         "postalCode": "56865"
      }],
      "contacts":       [
                  {
            "contactType": "PERSONAL",
            "mobileNumber": "0563339289",
            "phoneNumber": "",
            "email": "kishore.abdulla@bankfab.com"
         },
                  {
            "contactType": "OFFICE",
            "phoneNumber": ""
         }
      ],
      "accounts":       [
                  {
            "accountIdentifier": "1421003396985036",
            "accountTitle": "FGB SCRAMBLE TITLE.1",
            "postingRestriction": "",
            "customerIdentifier": "3396985",
            "currency": "AED",
            "isActive": true,
            "branchCode": "142",
            "powerOfAttorney": ""
         },
                  {
            "accountIdentifier": "2011003396985027",
            "accountTitle": "FGB SCRAMBLE TITLE.1",
            "postingRestriction": "",
            "customerIdentifier": "3396985",
            "currency": "AED",
            "isActive": false,
            "branchCode": "201",
            "powerOfAttorney": ""
         }
      ],
      "FATCA":       {
         "isPoliticalExposed": "",
         "pepPosition": "",
         "isUSPersonForTaxPurpose": false,
         "socialSecurityNumber": "",
         "isTaxResidentOtherCountry": false,
         "isResidentOfOtherJurisdiction": "",
         "declarationIndicator": false,
         "reasonForDeclarationDisagree": "",
         "status": "",
         "isReportable": false,
         "otherNationalities":          [
            "",
            "",
            "",
            ""
         ],
         "nationality":          [
            "PK",
            "",
            "",
            ""
         ],
         "placeOfBirth": "",
         "taxResidencies":          [
                        {
               "countryJurisdictionOfTaxResident": "",
               "taxIdentificationNumber": "",
               "reasonIfTINNotAvailable": "",
               "comments": ""
            },
                        {
               "countryJurisdictionOfTaxResident": "",
               "taxIdentificationNumber": "",
               "reasonIfTINNotAvailable": "",
               "comments": ""
            },
                        {
               "countryJurisdictionOfTaxResident": "",
               "taxIdentificationNumber": "",
               "reasonIfTINNotAvailable": "",
               "comments": ""
            },
                        {
               "countryJurisdictionOfTaxResident": "",
               "taxIdentificationNumber": "",
               "reasonIfTINNotAvailable": "",
               "comments": ""
            }
         ]
      }
   }
}


Root Cause Analysis (RCA)

Incident Summary:
A recent change was made to the backend API of the Internet Banking platform to disable ADPF Payment beneficiary accounts from appearing in the drop-down list. However, this change unintentionally impacted the Mobile Banking platform, resulting in the ADPF Payment beneficiary accounts also being removed from the mobile platform, which was not part of the requested change. The issue was missed during both the testing and regression testing phases and was not identified in the test case sign-off process.

Root Cause:
The root cause of the incident is attributed to insufficient impact analysis of the backend API change. The change was only intended for the Internet Banking platform but inadvertently affected shared components used by both the Internet Banking and Mobile Banking platforms. Additionally, there was a failure in communication regarding the potential impact of the change on other platforms.

Contributing Factors:

Lack of Comprehensive Impact Analysis: The change request focused on the Internet Banking platform but did not consider the shared nature of the backend services between the Internet Banking and Mobile Banking platforms.
Inadequate Testing Coverage: The testing team did not account for the Mobile Banking platform in their test cases. This critical omission led to the issue going unnoticed during both functional and regression testing.
Test Case Sign-off Missed the Issue: Test case sign-off procedures failed to ensure that all related platforms, including Mobile Banking, were tested. The sign-off process did not include validation across all impacted platforms.
Communication Gap: There was insufficient communication between the development and testing teams regarding the scope of the change and its potential impact on other services, such as the Mobile Banking platform.
Corrective Actions:

Enhanced Impact Assessment Process: Implement a more thorough impact assessment process that explicitly includes the evaluation of shared services and cross-platform dependencies before making any backend changes.
Improved Test Coverage: Expand test case development to include scenarios that cover all platforms that utilize shared services, such as both Internet Banking and Mobile Banking. Ensure test cases are updated accordingly for future changes.
Stricter Sign-off Procedures: Update the test case sign-off process to require a formal review of all platforms impacted by the change, ensuring cross-platform validation before final approval.
Cross-team Communication: Establish stronger communication protocols between development, testing, and business teams to ensure that all potential impacts of a change are clearly understood and documented across all relevant platforms.
Preventive Actions:

Platform-Specific Testing: Mandate that all API changes are tested across every platform using the shared service, with specific test cases for each platform.
Automated Regression Testing: Introduce or enhance automated regression testing to cover multiple platforms and ensure that future changes do not inadvertently affect other parts of the system.
Platform Awareness Training: Conduct regular training sessions to improve platform awareness for both developers and testers, focusing on understanding how changes in one platform can impact others.


org.bouncycastle:bcprov-jdk15on
commons-codec:commons-codec

Top 5 Vulnerable Packages
5 log4j:log4j-1.2.17
2 com.fasterxml.jackson.core:jackson-databind-2.1
3.3
2 org.springframework.security:spring-security-cor
e-5.7.3
1 commons-collections:commons-collections-3.2.2
1 net.minidev:json-smart-2.4.7


Fixed Pom.xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

	<modelVersion>4.0.0</modelVersion>

	<groupId>com.fgb</groupId>
	<version>0.0.1-SNAPSHOT</version>
	<artifactId>FABAdmin</artifactId>
	<packaging>war</packaging>
	<name>FABAdminAPI</name>
	<description>FABAdminAPI</description>

	<properties>
		<junit.version>4.11</junit.version>
		<jdk.version>1.8</jdk.version>
		<logger.version>2.17.1</logger.version>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
	</properties>

	<dependencies>
		<dependency>
			<groupId>javax</groupId>
			<artifactId>javaee-api</artifactId>
			<version>7.0</version>
			<scope>provided</scope>
		</dependency>
		<!-- <dependency> <groupId>org.apache.geronimo.specs</groupId> <artifactId>geronimo-jaxrs_2.0_spec</artifactId> 
			<version>1.0-alpha-1</version> <scope>provided</scope> </dependency> <dependency> 
			<groupId>org.apache.geronimo.specs</groupId> <artifactId>geronimo-servlet_3.0_spec</artifactId> 
			<version>1.0</version> <scope>provided</scope> </dependency> <dependency> 
			<groupId>org.apache.geronimo.specs</groupId> <artifactId>geronimo-ejb_3.1_spec</artifactId> 
			<version>1.0.2</version> <scope>provided</scope> </dependency> -->
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-lang3</artifactId>
			<version>3.7</version>
		</dependency>
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-text</artifactId>
			<version>1.2</version>
		</dependency>
		<dependency>
           <groupId>com.opencsv</groupId>
           <artifactId>opencsv</artifactId>
           <version>5.9</version>
           <exclusions>
				<exclusion>
					<groupId>commons-collections</groupId>
					<artifactId>commons-collections</artifactId>
				</exclusion>
			</exclusions>
        </dependency>
		<dependency>
			<groupId>com.fab</groupId>
			<artifactId>PBLogger</artifactId>
			<version>1.7</version>
			<exclusions>
				<exclusion>
					<groupId>com.fasterxml.jackson.core</groupId>
					<artifactId>jackson-databind</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>${junit.version}</version>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>javax.interceptor</groupId>
			<artifactId>javax.interceptor-api</artifactId>
			<version>3.1</version>
		</dependency>
		<!-- changed version from 1.9.0 to 1.9.3 -->
		<dependency>
			<groupId>org.jasypt</groupId>
			<artifactId>jasypt-spring31</artifactId>
			<version>1.9.3</version>
		</dependency>
		<dependency>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpcore</artifactId>
			<version>4.4.6</version>
		</dependency>
		
		<dependency>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpmime</artifactId>
			<version>4.5.3</version>
			<exclusions>
				<exclusion>
				    <groupId>org.apache.httpcomponents</groupId>
				    <artifactId>httpclient</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<!-- changed version from 4.5.3 to 4.5.13 -->
		<dependency>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpclient</artifactId>
			<version>4.5.14</version>
		</dependency>
		<dependency>
			<groupId>com.jayway.jsonpath</groupId>
			<artifactId>json-path</artifactId>
			<version>2.9.0</version>
		</dependency>
		<!-- changed version from 2.12.5 to 2.13.3 -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-core</artifactId>
			<version>2.13.3</version>
		</dependency>
		<!-- changed version from 2.9.4 to 2.13.3 -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>2.13.4.2</version>
		</dependency>
		<dependency>
			<groupId>com.ibm.websphere.appserver.api</groupId>
			<artifactId>com.ibm.websphere.appserver.api.distributedMap</artifactId>
			<version>2.0.17</version>
		</dependency>
		<!-- changed version from 1.54 to 1.70 -->
		<dependency>
			<groupId>org.bouncycastle</groupId>
			<artifactId>bcprov-jdk15on</artifactId>
			<version>1.70</version>
		</dependency>
		<dependency>
			<groupId>com.oracle</groupId>
			<artifactId>ojdbc6</artifactId>
			<version>11.2.0.3</version>
		</dependency>
		<dependency>
			<groupId>commons-io</groupId>
			<artifactId>commons-io</artifactId>
			<version>2.11.0</version>
		</dependency>
		<dependency>
			<groupId>com.amazonaws</groupId>
			<artifactId>aws-java-sdk-core</artifactId>
			<version>1.12.769</version>
			<exclusions>
				<exclusion>
					<groupId>com.fasterxml.jackson.core</groupId>
					<artifactId>jackson-databind</artifactId>
				</exclusion>
				<exclusion>
				    <groupId>com.fasterxml.jackson.dataformat</groupId>
				    <artifactId>jackson-dataformat-cbor</artifactId>
				</exclusion>
				<exclusion>
				    <groupId>org.apache.httpcomponents</groupId>
				    <artifactId>httpclient</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>com.amazonaws</groupId>
			<artifactId>aws-java-sdk-pinpoint</artifactId>
			<version>1.11.383</version>
			<exclusions>
				<exclusion>
					<groupId>com.fasterxml.jackson.core</groupId>
					<artifactId>jackson-databind</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<!-- changed version from 5.0.0 to 5.2.2 -->
		<dependency>
			<groupId>org.apache.poi</groupId>
			<artifactId>poi-ooxml</artifactId>
			<version>5.3.0</version>
			<exclusions>
				<exclusion>
				    <groupId>org.apache.logging.log4j</groupId>
				    <artifactId>log4j-api</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
		    <groupId>com.fasterxml.jackson.dataformat</groupId>
		    <artifactId>jackson-dataformat-cbor</artifactId>
		    <version>2.13.3</version>
		</dependency>
		<dependency>
			<groupId>com.unboundid</groupId>
    		<artifactId>unboundid-ldapsdk</artifactId>
    		<version>6.0.0</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.ldap</groupId>
			<artifactId>spring-ldap-core</artifactId>
			<version>2.4.1</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-ldap</artifactId>
			<version>6.3.1</version>
		</dependency>
		
		<dependency>
		    <groupId>com.google.re2j</groupId>
		    <artifactId>re2j</artifactId>
		    <version>1.7</version>
		</dependency>
		
		<dependency>
		    <groupId>com.google.code.gson</groupId>
		    <artifactId>gson</artifactId>
		    <version>2.10.1</version>
		</dependency>
		
		<dependency>
		    <groupId>org.apache.logging.log4j</groupId>
		    <artifactId>log4j-slf4j-impl</artifactId>
		    <version>${logger.version}</version>
		</dependency>
		

		<!-- <dependency> <groupId>javax.jms</groupId> <artifactId>javax.jms-api</artifactId> 
			<version>2.0.1</version> </dependency> -->
	</dependencies>
	<build>
		<finalName>FABAdmin</finalName>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.0</version>
				<configuration>
					<source>${jdk.version}</source>
					<target>${jdk.version}</target>
					<archive>
						<manifest>
							<addDefaultImplementationEntries>true</addDefaultImplementationEntries>
						</manifest>
						<manifestEntries>
							<Implementation-Build>$\{buildNumber}</Implementation-Build>
						</manifestEntries>
					</archive>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-war-plugin</artifactId>
				<version>3.4.0</version>
				<configuration>
					<webXml>src/main/webapp/WEB-INF/web.xml</webXml>
					<ignoreWebxml>false</ignoreWebxml>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>2.16</version>
				<configuration>
					<skipTests>true</skipTests>
				</configuration>
			</plugin>
		</plugins>
	</build>
 <repositories>
	 <repository>
		 <id>repo1</id>
		 <name> nexus-release-repo1</name>
		 <url>https://nexus.platform-tools-development.mesouth1.bankfab.com/repository/maven-releases/ </url>
     </repository>
 </repositories>
</project>
--------------------------------------------------

<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

	<modelVersion>4.0.0</modelVersion>

	<groupId>com.fgb</groupId>
	<version>0.0.1-SNAPSHOT</version>
	<artifactId>FABAdmin</artifactId>
	<packaging>war</packaging>
	<name>FABAdminAPI</name>
	<description>FABAdminAPI</description>

	<properties>
		<junit.version>4.11</junit.version>
		<jdk.version>1.8</jdk.version>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
	</properties>

	<dependencies>
		<dependency>
			<groupId>javax</groupId>
			<artifactId>javaee-api</artifactId>
			<version>7.0</version>
			<scope>provided</scope>
		</dependency>
		<!-- <dependency> <groupId>org.apache.geronimo.specs</groupId> <artifactId>geronimo-jaxrs_2.0_spec</artifactId> 
			<version>1.0-alpha-1</version> <scope>provided</scope> </dependency> <dependency> 
			<groupId>org.apache.geronimo.specs</groupId> <artifactId>geronimo-servlet_3.0_spec</artifactId> 
			<version>1.0</version> <scope>provided</scope> </dependency> <dependency> 
			<groupId>org.apache.geronimo.specs</groupId> <artifactId>geronimo-ejb_3.1_spec</artifactId> 
			<version>1.0.2</version> <scope>provided</scope> </dependency> -->
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-lang3</artifactId>
			<version>3.7</version>
		</dependency>
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-text</artifactId>
			<version>1.2</version>
		</dependency>

		<dependency>
			<groupId>com.fab</groupId>
			<artifactId>PBLogger</artifactId>
			<version>1.0</version>
			<exclusions>
				<exclusion>
					<groupId>com.fasterxml.jackson.core</groupId>
					<artifactId>jackson-databind</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>${junit.version}</version>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>javax.interceptor</groupId>
			<artifactId>javax.interceptor-api</artifactId>
			<version>3.1</version>
		</dependency>
		<!-- changed version from 1.9.0 to 1.9.3 -->
		<dependency>
			<groupId>org.jasypt</groupId>
			<artifactId>jasypt-spring31</artifactId>
			<version>1.9.3</version>
		</dependency>
		<dependency>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpcore</artifactId>
			<version>4.4.6</version>
		</dependency>
		
		<dependency>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpmime</artifactId>
			<version>4.5.3</version>
			<exclusions>
				<exclusion>
				    <groupId>org.apache.httpcomponents</groupId>
				    <artifactId>httpclient</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<!-- changed version from 4.5.3 to 4.5.13 -->
		<dependency>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpclient</artifactId>
			<version>4.5.13</version>
		</dependency>

		<dependency>
			<groupId>com.jayway.jsonpath</groupId>
			<artifactId>json-path</artifactId>
			<version>2.6.0</version>
		</dependency>
		<!-- changed version from 2.12.5 to 2.13.3 -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-core</artifactId>
			<version>2.13.3</version>
		</dependency>
		<!-- changed version from 2.9.4 to 2.13.3 -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>2.13.3</version>
		</dependency>
		<dependency>
			<groupId>com.ibm.websphere.appserver.api</groupId>
			<artifactId>com.ibm.websphere.appserver.api.distributedMap</artifactId>
			<version>2.0.17</version>
		</dependency>
		<!-- changed version from 1.54 to 1.70 -->
		<dependency>
			<groupId>org.bouncycastle</groupId>
			<artifactId>bcprov-jdk15on</artifactId>
			<version>1.70</version>
		</dependency>
		<dependency>
			<groupId>com.oracle</groupId>
			<artifactId>ojdbc6</artifactId>
			<version>11.2.0.3</version>
		</dependency>
		<dependency>
			<groupId>commons-io</groupId>
			<artifactId>commons-io</artifactId>
			<version>2.11.0</version>
		</dependency>
		<dependency>
			<groupId>com.amazonaws</groupId>
			<artifactId>aws-java-sdk-core</artifactId>
			<version>1.11.383</version>
			<exclusions>
				<exclusion>
					<groupId>com.fasterxml.jackson.core</groupId>
					<artifactId>jackson-databind</artifactId>
				</exclusion>
				<exclusion>
				    <groupId>com.fasterxml.jackson.dataformat</groupId>
				    <artifactId>jackson-dataformat-cbor</artifactId>
				</exclusion>
				<exclusion>
				    <groupId>org.apache.httpcomponents</groupId>
				    <artifactId>httpclient</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>com.amazonaws</groupId>
			<artifactId>aws-java-sdk-pinpoint</artifactId>
			<version>1.11.383</version>
			<exclusions>
				<exclusion>
					<groupId>com.fasterxml.jackson.core</groupId>
					<artifactId>jackson-databind</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<!-- changed version from 5.0.0 to 5.2.2 -->
		<dependency>
			<groupId>org.apache.poi</groupId>
			<artifactId>poi-ooxml</artifactId>
			<version>5.2.2</version>
			<exclusions>
				<exclusion>
				    <groupId>org.apache.logging.log4j</groupId>
				    <artifactId>log4j-api</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
		    <groupId>org.apache.logging.log4j</groupId>
		    <artifactId>log4j-api</artifactId>
		    <version>2.18.0</version>
		</dependency>
		<dependency>
		    <groupId>com.fasterxml.jackson.dataformat</groupId>
		    <artifactId>jackson-dataformat-cbor</artifactId>
		    <version>2.13.3</version>
		</dependency>
		<dependency>
			<groupId>com.unboundid</groupId>
    		<artifactId>unboundid-ldapsdk</artifactId>
    		<version>6.0.0</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.ldap</groupId>
			<artifactId>spring-ldap-core</artifactId>
			<version>2.4.1</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-ldap</artifactId>
			<version>5.7.3</version>
		</dependency>
		
		<dependency>
		    <groupId>com.google.re2j</groupId>
		    <artifactId>re2j</artifactId>
		    <version>1.7</version>
		</dependency>

		<!-- <dependency> <groupId>javax.jms</groupId> <artifactId>javax.jms-api</artifactId> 
			<version>2.0.1</version> </dependency> -->
	</dependencies>
	<build>
		<finalName>FABAdmin</finalName>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.0</version>
				<configuration>
					<source>${jdk.version}</source>
					<target>${jdk.version}</target>
					<archive>
						<manifest>
							<addDefaultImplementationEntries>true</addDefaultImplementationEntries>
						</manifest>
						<manifestEntries>
							<Implementation-Build>$\{buildNumber}</Implementation-Build>
						</manifestEntries>
					</archive>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-war-plugin</artifactId>
				<version>3.4.0</version>
				<configuration>
					<webXml>src/main/webapp/WEB-INF/web.xml</webXml>
					<ignoreWebxml>false</ignoreWebxml>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>2.16</version>
				<configuration>
					<skipTests>true</skipTests>
				</configuration>
			</plugin>
		</plugins>
	</build>
 <repositories>
	 <repository>
		 <id>repo1</id>
		 <name> nexus-release-repo1</name>
		 <url>https://nexus.platform-tools-development.mesouth1.bankfab.com/repository/maven-releases/ </url>
     </repository>
 </repositories>
</project>


--------------------------------------------------

public void validateDepositRequest(DepositCreateRequest depositCreateRequest) {
    // Get company code based on the source account number
    String companyCode = ciRepository.getAccountUnitIdentifier(depositCreateRequest.getSourceAccountNumber());
    
    // Validate company code
    validateCompanyCode(companyCode);
    
    // Validate interest redeem account
    validateAccountForISL(depositCreateRequest.getInterestRedeemAccount());
    
    // Validate principal redeem account
    validateAccountForISL(depositCreateRequest.getPrincipalRedeemAccount());
}

private void validateCompanyCode(String companyCode) {
    if (StringUtils.isNotBlank(companyCode) && companyCode.equals(T24CompanyCodes.ISL.getCompanyCode())) {
        throw new AppException(ErrorCodes.DEPOSIT_ISL_NOT_ALLOWED);
    }
}

private void validateAccountForISL(String accountNumber) {
    if (StringUtils.isNotBlank(accountNumber)) {
        String companyCode = ciRepository.getAccountUnitIdentifier(accountNumber);
        validateCompanyCode(companyCode);
    }
}
set define off;

CREATE OR REPLACE PACKAGE "IBMBUSER.IBMB_ARCHIVE_PKG" 
AS
PROCEDURE ARCHVICE_EVENT;
PROCEDURE ARCHVICE_NOTIFICATION;
PROCEDURE ARCHVICE_PUSH_NOTI_AUDIT;
PROCEDURE ARCHVICE_SEGMENT_UPLOAD_FILE;
PROCEDURE ARCHVICE_PAGE_VIEW_REPORT;
PROCEDURE ARCHVICE_CA_REQUEST_AUDIT;
PROCEDURE ARCHIVE_CS_TRANSACTION_AUDIT;
END; 

/
create or replace PACKAGE BODY "IBMB_ARCHIVE_PKG" 
IS
   PROCEDURE ARCHVICE_EVENT 
   IS
     CURSOR c_archiveData IS
		SELECT * FROM IBMBUSER.EVENT@ARCH_CIDB_IBMB WHERE CREATED_DATE <= add_months(sysdate, -3);
	TYPE t_data IS TABLE OF  c_archiveData%ROWTYPE;
	chunk_size CONSTANT INTEGER :=100000;
	l_data t_data;
	lc_out  VARCHAR2(512);
    reccount NUMBER;
    totalRecords NUMBER;
   BEGIN
	OPEN c_archiveData;
    totalRecords := 0;
    LOOP
      BEGIN
            FETCH c_archiveData BULK COLLECT INTO l_data LIMIT chunk_size;
            reccount := l_data.COUNT;
            totalRecords := totalRecords + reccount;
            FORALL i IN 1..reccount
                INSERT INTO IBMBARCHIVE.EVENT_ARCHIVE(EVENT_ID,EVENT_TYPE,CIN,CIF,STATUS,PARAM1,PARAM2,PARAM3,PARAM4,PARAM5,CREATED_BY,
				CREATED_DATE,MODIFIED_BY,MODIFIED_DATE,OCCURRENCE,FREQUENCY,DEVICE_ID) 
                VALUES
                (l_data(i).EVENT_ID,l_data(i).EVENT_TYPE,l_data(i).CIN,l_data(i).CIF,l_data(i).STATUS,l_data(i).PARAM1,l_data(i).PARAM2,l_data(i).PARAM3,l_data(i).PARAM4,l_data(i).PARAM5,
                l_data(i).CREATED_BY,l_data(i).CREATED_DATE,l_data(i).MODIFIED_BY,l_data(i).MODIFIED_DATE,l_data(i).OCCURRENCE,l_data(i).FREQUENCY,
                l_data(i).DEVICE_ID);
            lc_out := 'INS';
            FOR i IN 1..reccount
				LOOP
                  DELETE FROM IBMBUSER.EVENT@ARCH_CIDB_IBMB WHERE EVENT_ID = l_data(i).EVENT_ID;
				END LOOP;
            lc_out := lc_out || '-DEL-';
            IF SQL%FOUND THEN
                lc_out := lc_out || 'SUCCESS';
                INSERT INTO IBMB_ARCHIVE_AUDIT (TBL_NAME, RECOUNT, STATUS,ERR_TEXT) VALUES ('EVENT',reccount,'1',lc_out);
                COMMIT;
            END IF;
            EXIT WHEN c_archiveData%NOTFOUND;
        EXCEPTION
            WHEN OTHERS
            THEN
                ROLLBACK;
                lc_out := lc_out || 'Error:' || SQLERRM;
				totalRecords := totalRecords - reccount;
                INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('EVENT',reccount,'0',lc_out);
                COMMIT;
        END;
	END LOOP;
	CLOSE c_archiveData;
    INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('EVENT',totalRecords,'1','JOB_COMPLETED');
    COMMIT;
   END ARCHVICE_EVENT;

PROCEDURE ARCHVICE_NOTIFICATION
   IS
	CURSOR c_archiveData IS
		SELECT * FROM IBMBUSER.NOTIFICATION@ARCH_CIDB_IBMB WHERE CREATED_ON <= add_months(sysdate, -6);
	TYPE t_data IS TABLE OF  c_archiveData%ROWTYPE;
	chunk_size CONSTANT INTEGER :=100000;
	l_data t_data;
	lc_out  VARCHAR2(512);
    reccount NUMBER;
	totalRecords NUMBER;


BEGIN
	totalRecords := 0;
	OPEN c_archiveData;
		LOOP
			BEGIN
            FETCH c_archiveData BULK COLLECT INTO l_data LIMIT chunk_size;
            reccount := l_data.COUNT;
			totalRecords := totalRecords + reccount;
            FORALL i IN 1..reccount
                INSERT INTO IBMBARCHIVE.NOTIFICATION_ARCHIVE(NOTIFICATION_ID,CIF,TITTLE,MESSAGE,CATEGORY,ACTION,ACTION_LABEL,ACTION_URL,READ_STATUS,DELIVERY_METHOD,
				DELIVERY_STATUS,CREATED_BY,CREATED_ON,MODIFIED_BY,MODIFIED_ON,SOURCE_TYPE,PARENT_ID,ERROR_CODE,ERROR_DESC,EVENT_TYPE,EXPIRY_DATE,LOCALE,ANDROID_IMAGE,
				IOS_MEDIA,REFERENCE_ID,TEMPLATE_TYPE,SUPRESSION_TYPE,CONTENT_PATH) 
                VALUES
                (l_data(i).NOTIFICATION_ID,l_data(i).CIF,l_data(i).TITTLE,l_data(i).MESSAGE,l_data(i).CATEGORY,l_data(i).ACTION,l_data(i).ACTION_LABEL,l_data(i).ACTION_URL,l_data(i).READ_STATUS,
                l_data(i).DELIVERY_METHOD,l_data(i).DELIVERY_STATUS,l_data(i).CREATED_BY,l_data(i).CREATED_ON,l_data(i).MODIFIED_BY,l_data(i).MODIFIED_ON,l_data(i).SOURCE_TYPE,l_data(i).PARENT_ID,
                l_data(i).ERROR_CODE,l_data(i).ERROR_DESC,l_data(i).EVENT_TYPE,l_data(i).EXPIRY_DATE,l_data(i).LOCALE,l_data(i).ANDROID_IMAGE,l_data(i).IOS_MEDIA,l_data(i).REFERENCE_ID,l_data(i).TEMPLATE_TYPE,
                l_data(i).SUPRESSION_TYPE,l_data(i).CONTENT_PATH);
            lc_out := 'INS';
            FOR i IN 1..reccount
				LOOP
                  DELETE FROM IBMBUSER.NOTIFICATION@ARCH_CIDB_IBMB WHERE NOTIFICATION_ID = l_data(i).NOTIFICATION_ID;
				END LOOP;
            lc_out := lc_out || '-DEL-';
            IF SQL%FOUND THEN
                lc_out := lc_out || 'SUCCESS';
                INSERT INTO IBMB_ARCHIVE_AUDIT (TBL_NAME, RECOUNT, STATUS,ERR_TEXT) VALUES ('NOTIFICATION',reccount,'1',lc_out);
                COMMIT;
            END IF;
            EXIT WHEN c_archiveData%NOTFOUND;
        EXCEPTION
            WHEN OTHERS
            THEN
                ROLLBACK;
                lc_out := lc_out || 'Error:' || SQLERRM;
				totalRecords := totalRecords - reccount;
                INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('NOTIFICATION',reccount,'0',lc_out);
                COMMIT;
        END;
	END LOOP;
	CLOSE c_archiveData;
	INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('NOTIFICATION',totalRecords,'1','JOB_COMPLETED');
    COMMIT;

END ARCHVICE_NOTIFICATION;

PROCEDURE ARCHVICE_PUSH_NOTI_AUDIT 
   IS
    CURSOR c_archiveData IS
		SELECT * FROM IBMBUSER.PUSH_NOTIFICATION_AUDIT@ARCH_CIDB_IBMB WHERE CREATION_DATE <= add_months(sysdate, -3);
    TYPE t_data IS TABLE OF  c_archiveData%ROWTYPE;
	chunk_size CONSTANT INTEGER :=100000;
	l_data t_data;
	lc_out  VARCHAR2(512);
    reccount NUMBER; 
	totalRecords NUMBER;	
  BEGIN
    totalRecords := 0;
	OPEN c_archiveData;
	LOOP
        BEGIN
            FETCH c_archiveData BULK COLLECT INTO l_data LIMIT chunk_size;
            reccount := l_data.COUNT;
			totalRecords := totalRecords + reccount;
            FORALL i IN 1..reccount
                INSERT INTO IBMBARCHIVE.PUSH_NOTI_AUDIT_ARCHIVE(ID, SEGMENT_ID, CAMPAIGN_ID, DEVICE_ID,CREATION_DATE, NOTIFIED_DATE, STATUS, ERROR_CODE, ERROR_DESC, CIF, CIN,TITTLE,MESSAGE,
                ACTION,ACTION_URL,SOURCE_TYPE,PARENT_ID,TOKEN,EVENT_TYPE,LOCALE, ANDROID_IMAGE, IOS_MEDIA, DEVICE_TYPE)
                VALUES (l_data(i).ID,l_data(i).SEGMENT_ID,l_data(i).CAMPAIGN_ID,l_data(i).DEVICE_ID,l_data(i).CREATION_DATE,l_data(i).NOTIFIED_DATE,l_data(i).STATUS,l_data(i).ERROR_CODE,l_data(i).ERROR_DESC,
                l_data(i).CIF,l_data(i).CIN,l_data(i).TITTLE,l_data(i).MESSAGE,l_data(i).ACTION,l_data(i).ACTION_URL,l_data(i).SOURCE_TYPE,l_data(i).PARENT_ID,l_data(i).TOKEN,l_data(i).EVENT_TYPE,l_data(i).LOCALE,l_data(i).ANDROID_IMAGE,l_data(i).IOS_MEDIA,l_data(i).DEVICE_TYPE);
            lc_out := 'INS';
            FOR i IN 1..reccount
			 LOOP
                 DELETE FROM IBMBUSER.PUSH_NOTIFICATION_AUDIT@ARCH_CIDB_IBMB WHERE ID = l_data(i).ID;
		     END LOOP;
            lc_out := lc_out || '-DEL-';
            IF SQL%FOUND THEN
                lc_out := lc_out || 'SUCCESS';
                INSERT INTO ibmb_archive_audit (TBL_NAME, RECOUNT, STATUS,ERR_TEXT) VALUES ('PUSH_NOTIFICATION_AUDIT',reccount,'1',lc_out);
                COMMIT;
            END IF;
            EXIT WHEN c_archiveData%NOTFOUND;
        EXCEPTION
            WHEN OTHERS
            THEN
                ROLLBACK;
				totalRecords := totalRecords - reccount;
                lc_out := lc_out || 'Error:' || SQLERRM;
                INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('PUSH_NOTIFICATION_AUDIT',reccount,'0',lc_out);
                COMMIT;
        END;
	END LOOP;
	CLOSE c_archiveData;
	INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('PUSH_NOTIFICATION_AUDIT',totalRecords,'1','JOB_COMPLETED');
    COMMIT;

END ARCHVICE_PUSH_NOTI_AUDIT;

PROCEDURE ARCHVICE_SEGMENT_UPLOAD_FILE
   IS
      reccount      NUMBER;
      lc_out        VARCHAR2(512);
   BEGIN

       SELECT COUNT(1) INTO reccount FROM IBMBUSER.SEGMENT_UPLOAD_FILE@ARCH_CIDB_IBMB WHERE UPLOADED_DATE <= add_months(sysdate, -6);

       INSERT INTO IBMBARCHIVE.SEGMENT_UPLOAD_FILE_ARCHIVE SELECT * FROM IBMBUSER.SEGMENT_UPLOAD_FILE@ARCH_CIDB_IBMB WHERE UPLOADED_DATE <= add_months(sysdate, -6);
       lc_out := 'INS';
       IF reccount = SQL%ROWCOUNT THEN
         DELETE FROM IBMBUSER.SEGMENT_UPLOAD_FILE@ARCH_CIDB_IBMB WHERE UPLOADED_DATE <= add_months(sysdate, -6);
         lc_out := lc_out || '-DEL-';
         IF SQL%FOUND THEN
           lc_out := lc_out || 'SUCCESS';
           INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS,ERR_TEXT )  VALUES('SEGMENT_UPLOAD_FILE',reccount,'1',lc_out);
           COMMIT;
         END IF;
       END IF;
	   INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS,ERR_TEXT )  VALUES('SEGMENT_UPLOAD_FILE',reccount,'1','JOB_COMPLETED');
       COMMIT;

   EXCEPTION
      WHEN OTHERS
      THEN
         ROLLBACK;
         lc_out := lc_out || 'Error:' || SQLERRM;
         INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('SEGMENT_UPLOAD_FILE',reccount,'0',lc_out);
         COMMIT;
   END ARCHVICE_SEGMENT_UPLOAD_FILE;

PROCEDURE ARCHVICE_PAGE_VIEW_REPORT
   IS
    CURSOR c_archiveData IS
		SELECT * FROM IBMBUSER.PAGE_VIEW_REPORT@ARCH_CIDB_IBMB WHERE TRUNC(CREATION_TIME) <= TRUNC(sysdate -1);
    TYPE t_data IS TABLE OF  c_archiveData%ROWTYPE;
	chunk_size CONSTANT INTEGER :=200000;
	l_data t_data;
	lc_out  VARCHAR2(512);
    reccount NUMBER;
	totalRecords NUMBER;

   BEGIN
    totalRecords := 0;
	OPEN c_archiveData;
	LOOP
        BEGIN
            FETCH c_archiveData BULK COLLECT INTO l_data LIMIT chunk_size;
            reccount := l_data.COUNT;
			totalRecords := totalRecords + reccount;
            FORALL i IN 1..reccount
                INSERT INTO IBMBARCHIVE.PAGE_VIEW_REPORT_ARCHIVE(ID, CIF,CIN,CHANNEL_ID,PAGE,CREATION_TIME,RC,IP,HOSTNAME,COMPLETION_TIME,API_STATUS,API_ERRORCODE,HTTP_STATUS,HTTP_ERRORCODE,HTTP_ERRORDESC,REMOTE_IP) 
				VALUES (l_data(i).ID, l_data(i).CIF,l_data(i).CIN,l_data(i).CHANNEL_ID,l_data(i).PAGE,l_data(i).CREATION_TIME,l_data(i).RC,l_data(i).IP,l_data(i).HOSTNAME,l_data(i).COMPLETION_TIME,l_data(i).API_STATUS,l_data(i).API_ERRORCODE,l_data(i).HTTP_STATUS,l_data(i).HTTP_ERRORCODE,l_data(i).HTTP_ERRORDESC,l_data(i).REMOTE_IP); -- use columns name
            lc_out := 'INS';
            FOR i IN 1..reccount
			  LOOP
                 DELETE FROM IBMBUSER.PAGE_VIEW_REPORT@ARCH_CIDB_IBMB WHERE ID = l_data(i).ID;
			  END LOOP;
            lc_out := lc_out || '-DEL-';
            IF SQL%FOUND THEN
                lc_out := lc_out || 'SUCCESS';
                INSERT INTO ibmb_archive_audit (TBL_NAME, RECOUNT, STATUS,ERR_TEXT) VALUES ('PAGE_VIEW_REPORT',reccount,'1',lc_out);
                COMMIT;
            END IF;
            EXIT WHEN c_archiveData%NOTFOUND;
        EXCEPTION
            WHEN OTHERS
            THEN
                ROLLBACK;
                lc_out := lc_out || 'Error:' || SQLERRM;
				totalRecords := totalRecords - reccount;
                INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('PAGE_VIEW_REPORT',reccount,'0',lc_out);
                COMMIT;
        END;
	END LOOP;
	CLOSE c_archiveData;
	INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('PAGE_VIEW_REPORT',totalRecords,'1','JOB_COMPLETED');
    COMMIT;
END ARCHVICE_PAGE_VIEW_REPORT; 

PROCEDURE ARCHVICE_CA_REQUEST_AUDIT 
   IS
      reccount      NUMBER;
      lc_out        VARCHAR2(512);
   BEGIN

       SELECT COUNT(1) INTO reccount FROM IBMBUSER.CA_REQUEST_AUDIT@ARCH_CIDB_IBMB  WHERE  TRUNC(CREATE_DATE) <= TRUNC(sysdate -1);

       INSERT INTO IBMBARCHIVE.CA_REQUEST_AUDIT_ARCHIVE SELECT * FROM IBMBUSER.CA_REQUEST_AUDIT@ARCH_CIDB_IBMB WHERE TRUNC(CREATE_DATE) <= TRUNC(sysdate -1);
       lc_out := 'INS';
       IF reccount = SQL%ROWCOUNT THEN
         DELETE FROM IBMBUSER.CA_REQUEST_AUDIT@ARCH_CIDB_IBMB WHERE TRUNC(CREATE_DATE) <= TRUNC(sysdate -1);
         lc_out := lc_out || '-DEL-';
         IF SQL%FOUND THEN
           lc_out := lc_out || 'SUCCESS';
           INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS,ERR_TEXT )  VALUES('CA_REQUEST_AUDIT',reccount,'1',lc_out);
           COMMIT;
         END IF;
       END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         ROLLBACK;
         lc_out := lc_out || 'Error:' || SQLERRM;
         INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('CA_REQUEST_AUDIT',reccount,'0',lc_out);
         COMMIT;
   END ARCHVICE_CA_REQUEST_AUDIT;
   
   PROCEDURE ARCHIVE_CS_TRANSACTION_AUDIT
   IS
    CURSOR c_archiveData IS
		SELECT * FROM IBMBUSER.CS_TRANSACTION_AUDIT@ARCH_CIDB_IBMB WHERE TRUNC(CREATION_TIME) <= TRUNC(sysdate -3);
    TYPE t_data IS TABLE OF  c_archiveData%ROWTYPE;
	chunk_size CONSTANT INTEGER :=200000;
	l_data t_data;
	lc_out  VARCHAR2(512);
    reccount NUMBER;
	totalRecords NUMBER;

   BEGIN
    totalRecords := 0;
	OPEN c_archiveData;
	LOOP
        BEGIN
            FETCH c_archiveData BULK COLLECT INTO l_data LIMIT chunk_size;
            reccount := l_data.COUNT;
			totalRecords := totalRecords + reccount;
            FORALL i IN 1..reccount
                INSERT INTO IBMBARCHIVE.CS_TRANSACTION_AUDIT_ARCHIVE(CONVID,SESSIONID,RC,CIN,CIF,STATUS,CHANNEL,CREATION_TIME,PATH,TRANSACTION_ID,TRANSACTION_TYPE,RESULT,REQUIREMENT_ID,DECISION_ID,DECISION,REQUEST_AUTHENTICATOR,RESPONSE_AUTHENTICATOR,MESSAGE,SDK_ERROR_CODE,SDK_ERROR_MESSAGE,ID,MODIFY_DATE,APP_VERSION)
				VALUES (l_data(i).CONVID, l_data(i).SESSIONID,
				l_data(i).RC,l_data(i).CIN,l_data(i).CIF,l_data(i).STATUS,l_data(i).CHANNEL,l_data(i).CREATION_TIME,l_data(i).PATH,l_data(i).TRANSACTION_ID,l_data(i).TRANSACTION_TYPE,l_data(i).RESULT,l_data(i).REQUIREMENT_ID,l_data(i).DECISION_ID,l_data(i).DECISION,l_data(i).REQUEST_AUTHENTICATOR,l_data(i).RESPONSE_AUTHENTICATOR,l_data(i).MESSAGE,l_data(i).SDK_ERROR_CODE,l_data(i).SDK_ERROR_MESSAGE,l_data(i).ID,l_data(i).MODIFY_DATE,l_data(i).APP_VERSION); -- use columns name
            lc_out := 'INS';
            FOR i IN 1..reccount
			  LOOP
                 DELETE FROM IBMBUSER.CS_TRANSACTION_AUDIT@ARCH_CIDB_IBMB WHERE ID = l_data(i).ID;
			  END LOOP;
            lc_out := lc_out || '-DEL-';
            IF SQL%FOUND THEN
                lc_out := lc_out || 'SUCCESS';
                INSERT INTO ibmb_archive_audit (TBL_NAME, RECOUNT, STATUS,ERR_TEXT) VALUES ('CS_TRANSACTION_AUDIT',reccount,'1',lc_out);
                COMMIT;
            END IF;
            EXIT WHEN c_archiveData%NOTFOUND;
        EXCEPTION
            WHEN OTHERS
            THEN
                ROLLBACK;
                lc_out := lc_out || 'Error:' || SQLERRM;
				totalRecords := totalRecords - reccount;
                INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('CS_TRANSACTION_AUDIT',reccount,'0',lc_out);
                COMMIT;
        END;
	END LOOP;
	CLOSE c_archiveData;
	INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('CS_TRANSACTION_AUDIT',totalRecords,'1','JOB_COMPLETED');
    COMMIT;
    END ARCHIVE_CS_TRANSACTION_AUDIT;

END;

/

commit;


--------------------------------
Yes, you can set multiple email addresses in the os.environ['TO_ADDRESS'] field and modify the send_mail function to handle multiple recipients. You can store multiple email addresses in the TO_ADDRESS environment variable separated by a delimiter (e.g., comma) and then split this string into a list in the function.

Heres how you can modify your function:

Store multiple email addresses in the TO_ADDRESS environment variable, separated by commas.
Split the TO_ADDRESS string into a list inside the function.

import os
import json
import uuid
from datetime import datetime
import httpx

# Method is used to send email
def send_mail(csv_data_in_bytes, s3_file_name):
    if csv_data_in_bytes is not None:
        currectDate = datetime.now().date()
        email_subject = "Sanctioned country report_" + currectDate.strftime("%Y-%m-%d")
        split_array = s3_file_name.split('/')
        s3_file_name=split_array[-1]
        s3_file_name = s3_file_name.replace(':','_')
        url = os.environ['SEND_EMAIL_SERVICE_URL']
        headers = {'XREF': str(uuid.uuid4()), 'CHANNELID': 'AWS', 'content-type': 'application/json'}

        # Split the TO_ADDRESS environment variable into a list of email addresses
        to_address_list = os.environ['TO_ADDRESS'].split(',')

        data = {
            "sourceSystem": "FAB",
            "requestID": str(uuid.uuid4()),
            "fromAddress": "noreply@bankfab.com",
            "entityName": "FAB",
            "toAddress": to_address_list,
            "emailSubject": email_subject,
            "emailBodyContent": "",
            "emailBodyContentType": "TEXT",
            "attachment": [{
                "attachementBytes": str(csv_data_in_bytes.decode("utf-8")),
                "mimeType": "application/csv",
                "fileName": s3_file_name
            }]
        }

        data = json.dumps(data)
        response = httpx.post(url, headers=headers, data=data, verify=sslcontext)
        if response.status_code == 200:
            logger.info("Email sent successfully")
        else:
            logger.info(f"Failed to send email. Status code: {response.status_code}")
        logger.info(f'Email API Response: {response.text}')
    else:
        logger.info("csv_data_in_bytes is null.")


-- Adding indexes
CREATE INDEX IDX_MOBILE_DEVICE_ID ON IBMBUSER.WATCH_REGISTRATION_DETAILS (MOBILE_DEVICE_ID);
CREATE INDEX IDX_WATCH_DEVICE_ID ON IBMBUSER.WATCH_REGISTRATION_DETAILS (WATCH_DEVICE_ID);
CREATE INDEX IDX_CIF ON IBMBUSER.WATCH_REGISTRATION_DETAILS (CIF);
CREATE INDEX IDX_CIN ON IBMBUSER.WATCH_REGISTRATION_DETAILS (CIN);


1. All the Npss related functionality needs to be disabled.
    IPP: Enable IPP Account to Account transfer for MB
    IPP: Enable IPP Account to Account transfer for IB
    NPSS Aani Overlay Roll out Enable(Y)/Disable(N)

2. DB Migration scripts needs to be executed by optimus team

3. Stop G42 Services all 4 services	
     npss-sca
	 npss-enrollment
	 npss-payment
	 npss-notification

try (CSVReader reader = new CSVReader(new StringReader(str))) {
            return reader.readAll().stream()
                .map(this::createSegmentUploadData)
                .collect(Collectors.toList());
        } catch (IOException | CsvValidationException e) {
            throw new AppException(ErrorCodes.SYS_INTERNAL_ERROR, e);
        }

private SegmentUploadData createSegmentUploadData(String[] record) {
        SegmentUploadData uploadData = new SegmentUploadData();

        for (int index = 0; index < record.length; index++) {
            String field = record[index];
            validateField(field);

            switch (index) {
                case 0:
                    uploadData.setData(field.replace("\"", ""));
                    if (uploadData.getData().length() > 100) {
                        log("length is greater than 100");
                        throw new AppException(ErrorCodes.INCORRECT_SEGMENT_DATA);
                    }
                    break;
                case 1:
                    uploadData.setAttr1(field);
                    break;
                case 2:
                    uploadData.setAttr2(field);
                    break;
                case 3:
                    uploadData.setAttr3(field);
                    break;
                case 4:
                    uploadData.setAttr4(field);
                    break;
                case 5:
                    uploadData.setAttr5(field);
                    break;
                case 6:
                    uploadData.setAttr6(field);
                    break;
                case 7:
                    uploadData.setAttr7(field);
                    break;
                default:
                    break;
            }
        }
        return uploadData;
    }


3605561,"1,000"
Invalid char between encapsulated token and delimiter at line: 1, position: 16
try (CSVParser parser = CSVParser.parse(new StringReader(str), format)) {
            for (CSVRecord record : parser) {
                SegmentUploadData uploadData = new SegmentUploadData();

                for (int index = 0; index < record.size(); index++) {
                    String field = record.get(index);
                    validateField(field);

                    switch (index) {
                        case 0:
                            uploadData.setData(field.replace("\"", ""));
                            if (uploadData.getData().length() > 100) {
                                log("length is greater than 100");
                                throw new AppException(ErrorCodes.INCORRECT_SEGMENT_DATA);
                            }
                            break;
                        case 1:
                            uploadData.setAttr1(field);
                            break;
                        case 2:
                            uploadData.setAttr2(field);
                            break;
                        case 3:
                            uploadData.setAttr3(field);
                            break;
                        case 4:
                            uploadData.setAttr4(field);
                            break;
                        case 5:
                            uploadData.setAttr5(field);
                            break;
                        case 6:
                            uploadData.setAttr6(field);
                            break;
                        case 7:
                            uploadData.setAttr7(field);
                            break;
                        default:
                            break;
                    }
                }
                segmentUploadData.add(uploadData);
            }
        } catch (IOException e) {
            throw new AppException(ErrorCodes.SYS_INTERNAL_ERROR, e);
        }



<dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-io</artifactId>
        <version>2.11.0</version>
    </dependency>

        at org.apache.commons.csv.CSVParser$CSVRecordIterator.getNextRecord(CSVParser.java:149)
	at org.apache.commons.csv.CSVParser$CSVRecordIterator.hasNext(CSVParser.java:158)
	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:132)
	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1845)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682)
	at com.fab.pb.helpers.pdfprocessor.PdfHelper.main(PdfHelper.java:348)
Caused by: java.lang.ClassNotFoundException: org.apache.commons.io.function.Uncheck
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-csv</artifactId>
    <version>1.11.0</version>
</dependency>

List<SegmentUploadData> segmentUploadData = new ArrayList<>();

    CSVFormat format = CSVFormat.DEFAULT.withQuote('"');

    try (CSVParser parser = CSVParser.parse(new StringReader(str), format)) {
        segmentUploadData = StreamSupport.stream(parser.spliterator(), false)
            .map(record -> {
                SegmentUploadData uploadData = new SegmentUploadData();
    
                for (int index = 0; index < record.size(); index++) {
                    switch (index) {
                        case 0:
                            uploadData.setData(record.get(0).replace("\"", ""));
                            if (uploadData.getData().length() > 100) {
                                log.info("length is greater than 100");
                                throw new AppException(ErrorCodes.INCORRECT_SEGMENT_DATA);
                            }
                            break; // Added break

                        case 1:
                            uploadData.setAttr1(record.get(1));
                            break;
                        case 2:
                            uploadData.setAttr2(record.get(2));
                            break;
                        case 3:
                            uploadData.setAttr3(record.get(3));
                            break;
                        case 4:
                            uploadData.setAttr4(record.get(4));
                            break;
                        case 5:
                            uploadData.setAttr5(record.get(5));
                            break;
                        case 6:
                            uploadData.setAttr6(record.get(6));
                            break;
                        case 7:
                            uploadData.setAttr7(record.get(7));
                            break;
                        default:
                            break;
                    }
                }

                return uploadData;
            })
            .collect(Collectors.toList());
    }

List<SegmentUploadData> segmentUploadData = new ArrayList<SegmentUploadData>();
			String[] splitted = Arrays.stream(str.split("\n")).map(String::trim).toArray(String[]::new);
			List<String> list = Arrays.asList(splitted);

			for (String lineStr : list) {
				//String[] line = Arrays.stream(lineStr.split(",")).map(String::trim).toArray(String[]::new);
				String[] line = parseCsvLine(lineStr);
				if(ArrayUtils.isNotEmpty(line)) {
				  List<String> splittedLine = Arrays.asList(line);
				  SegmentUploadData uploadData = new SegmentUploadData();
				  for(int index=0;index<splittedLine.size();index++){
					switch(index){
					case 0:
						uploadData.setData(splittedLine.get(0).replace("\"", ""));
						// PRM-2709: FAB_Admin_Elig_file_seg_file_upload_issue with incorrect CIN
						if(uploadData.getData().length()>100) {
							log.info("length is greater than 100");
							throw new AppException(ErrorCodes.INCORRECT_SEGMENT_DATA);
						}
						break;
					case 1:
						uploadData.setAttr1(splittedLine.get(1));
						break;
					case 2:
						uploadData.setAttr2(splittedLine.get(2));
						break;
					case 3:
						uploadData.setAttr3(splittedLine.get(3));
						break;
					case 4:
						uploadData.setAttr4(splittedLine.get(4));
						break;
					case 5:
						uploadData.setAttr5(splittedLine.get(5));
						break;
					case 6:
						uploadData.setAttr6(splittedLine.get(6));
						break;
					case 7:
						uploadData.setAttr7(splittedLine.get(7));
						break;
					default:
						break;
					}
				}
				segmentUploadData.add(uploadData);
			  }
			}


1)Callsign whitelisted the mw risk endpoint: https://kproxy-uat.risk-middleware-dev.aeapps.bankfab.com/ae/core/sim-swap/v1/sim/swap/status  from Akhaya and after we have trigger the etg reqyest and mw team given us the req/res and we repoted to team  
 
 
below is the update:
We worked with CALLSIGN and KONG team to stabilize the environment.
Post that able to generate logs from middleware team. Below are the logs
Naveen Gupta please check. If any support required connect with us Thanks Sanjib Mohanty
Jun 21, 2024 @ 14:33:44.244	trn-p2kg9mwp-0sps3t5r-9ncf25tma-4psbcgd5, simSwapStatus	INFO	Service Request: {"applicationArea":{"transactionId":"trn-p2kg9mwp-0sps3t5r-9ncf25tma-4psbcgd5"}}

Jun 21, 2024 @ 14:33:44.249	trn-p2kg9mwp-0sps3t5r-9ncf25tma-4psbcgd5, simSwapStatus	INFO	Service Response: 400 BAD_REQUEST {"applicationArea":{"transactionId":"trn-p2kg9mwp-0sps3t5r-9ncf25tma-4psbcgd5"},"responseStatus":{"status":"ERROR","errorDetails":[{"errorCode":"GEN8003","errorDesc":"Missing Mandatory fields in Request payload"}]}}
 
 
 
2) After changing the request payload fromat by callsign :   "transaction": {
                    "additionalTransactionInformation": {
                        "channel": "MOB",
                        "phoneNumber": "0504972291",
                        "countryOfOrigin": "AE",
                        "transactionDateTime": "2024-06-21T09:00:45.043Z",
                        "referenceDate": "2024-06-21 03:12:02.751"
                    }
                } 
				Still callsign request is not recieved in mw and they are saying the request is invalid josn format that is why they r not able to provide request 
3)https://kproxy-uat.risk-middleware-dev.aeapps.bankfab.com/ae/core/sim-swap/v1/sim/swap/status   ---------its not working from postman as Etislat connectivity  issue As per Prasant

Update on Middleware Risk Endpoint Whitelisting and Logging:

1. Whitelisting and Initial Triggering:
Callsign has successfully whitelisted the middleware risk endpoint: https://kproxy-uat.risk-middleware-dev.aeapps.bankfab.com/ae/core/sim-swap/v1/sim/swap/status from Akhaya. Following this, we triggered the ETG request, and the middleware team provided us with the request and response details, which we have reported to the team.

Update:
We collaborated with the CALLSIGN and KONG teams to stabilize the environment. Subsequently, we were able to generate logs from the middleware team. Below are the logs:

Naveen Gupta, please review the logs. If any support is required, please connect with us.

Logs:

Timestamp: Jun 21, 2024 @ 14:33:44.244

Transaction ID: trn-p2kg9mwp-0sps3t5r-9ncf25tma-4psbcgd5

Service: simSwapStatus

Log Level: INFO

Service Request: {"applicationArea":{"transactionId":"trn-p2kg9mwp-0sps3t5r-9ncf25tma-4psbcgd5"}}

Timestamp: Jun 21, 2024 @ 14:33:44.249

Transaction ID: trn-p2kg9mwp-0sps3t5r-9ncf25tma-4psbcgd5

Service: simSwapStatus

Log Level: INFO

Service Response: 400 BAD_REQUEST {"applicationArea":{"transactionId":"trn-p2kg9mwp-0sps3t5r-9ncf25tma-4psbcgd5"},"responseStatus":{"status":"ERROR","errorDetails":[{"errorCode":"GEN8003","errorDesc":"Missing Mandatory fields in Request payload"}]}}

2. Payload Format Update:
After modifying the request payload format by Callsign, the updated structure is as follows:

json
Copy code
{
    "transaction": {
        "additionalTransactionInformation": {
            "channel": "MOB",
            "phoneNumber": "0504972291",
            "countryOfOrigin": "AE",
            "transactionDateTime": "2024-06-21T09:00:45.043Z",
            "referenceDate": "2024-06-21 03:12:02.751"
        }
    }
}
Despite this modification, Callsign's request is still not being received by the middleware, and they have indicated that the request is in an invalid JSON format, preventing them from providing the request.

3. Connectivity Issue:
The endpoint https://kproxy-uat.risk-middleware-dev.aeapps.bankfab.com/ae/core/sim-swap/v1/sim/swap/status is currently not functioning from Postman due to connectivity issues with Etisalat, as reported by Prasant.

return getWebClient(finalUrl, false).method(httpMethod).uri(finalUrl)
				.headers(header -> header.putAll(headers)).body(BodyInserters.fromValue(xmlRequest))
				.exchangeToMono(clientResponse -> processResponse(serviceName, finalUrl, headers, t1, clientResponse))
				.contextCapture()
				.retryWhen(Retry.backoff(3, Duration.ofMillis(500))
					            .filter(this::isRetryRequired));


/**
	 * Method to invoke Post and PUT API's without proxy.
	 * 
	 * @param <T>
	 * @param serviceName
	 * @param url
	 * @param httpMethod
	 * @param pathParams
	 * @param requestObj
	 * @param headersMap
	 * @param queryParams
	 * @return
	 */
	public <T> Mono<ConnectorResponse> invokePostPut(String serviceName, String url, HttpMethod httpMethod,
			Map<String, String> pathParams, T requestObj, Map<String, String> headersMap, String... queryParams) {

		String finalUrl = checkNgetServiceUrl(url, pathParams, headersMap, queryParams);
		
		String request = "{}";
		if (Objects.nonNull(requestObj)) {
			request = JsonUtils.convertToJsonUsingGson(requestObj);
		}
		
		HttpHeaders headers = getHttpHeaders(serviceName, finalUrl, httpMethod, headersMap, MediaType.APPLICATION_JSON);
		log.info("XREF: {}, Request: {}", headers.getFirst(BaseAppConstants.XREF), TextUtils.maskJsonFields(request));
		long t1 = System.currentTimeMillis();

		return getWebClient(finalUrl, false).method(httpMethod).uri(finalUrl)
				.headers(header -> header.putAll(headers)).body(BodyInserters.fromValue(request))
				.exchangeToMono(clientResponse -> processResponse(serviceName, finalUrl, headers, t1, clientResponse))
				.contextCapture();




3605561,"1,000"
3189338,"1,000"
5734543,"1,000"
4116175,"1,000"
1074462,"1,000"
4676587,1000
import org.apache.commons.lang3.StringUtils;

private String[] parseCsvLine(String line) {
    List<String> result = new ArrayList<>();
    boolean inQuotes = false;
    StringBuilder current = new StringBuilder();

    for (char c : line.toCharArray()) {
        if (c == '"') {
            inQuotes = !inQuotes;
        } else if (c == ',' && !inQuotes) {
            result.add(current.toString());
            current = new StringBuilder();
        } else {
            current.append(c);
        }
    }
    result.add(current.toString());

    String[] parsedLine = result.toArray(new String[0]);

    // Validate second column if present
    if (parsedLine.length > 1) {
        String secondColumn = StringUtils.strip(parsedLine[1], "\"").trim();
        if (!isValidSecondColumn(secondColumn)) {
            return StringUtils.EMPTY_STRING_ARRAY;
        }
    } else {
        return StringUtils.EMPTY_STRING_ARRAY;
    }

    // Validate first column
    String firstColumn = StringUtils.strip(parsedLine[0], "\"").trim();
    if (StringUtils.isEmpty(firstColumn)) {
        return StringUtils.EMPTY_STRING_ARRAY;
    }

    return parsedLine;
}

private boolean isValidSecondColumn(String column) {
    // Your validation logic for the second column goes here
    // Example: Check if it's numeric with commas and dots
    return column.matches("[0-9,.]+");
}
/**
	 * Method to create segment for file upload.
	 * 
	 * @param segementRequest
	 * @return
	 */
	public CreatePinpointResponse uploadSegment(Segment segementRequest) {
		CreatePinpointResponse response = new CreatePinpointResponse();
		return execute(segementRequest, response, req -> {
			if(StringUtils.isBlank(req.getSegmentName()) || Objects.isNull(req.getSegmentType()) 
					|| StringUtils.isBlank(req.getFileContentsAsBase64()) || StringUtils.isBlank(req.getFileName())) {
				throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
			}
			if(pinpointRepository.checkIfSegmentExists(segementRequest.getSegmentName())){
				throw new AppException(ErrorCodes.SEGMENT_NAME_ALREADY_EXIST);
			}
			byte[] inBytes = Base64.decodeBase64(req.getFileContentsAsBase64().getBytes());
						
			String str = new String(inBytes);

			if (StringUtils.isBlank(str.trim())) {
				throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
			}

			List<SegmentUploadData> segmentUploadData = new ArrayList<SegmentUploadData>();
			String[] splitted = Arrays.stream(str.split("\n")).map(String::trim).toArray(String[]::new);
			List<String> list = Arrays.asList(splitted);

			for (String lineStr : list) {
				String[] line = Arrays.stream(lineStr.split(",")).map(String::trim).toArray(String[]::new);
				List<String> splittedLine = Arrays.asList(line);
				SegmentUploadData uploadData = new SegmentUploadData();
				for(int index=0;index<splittedLine.size();index++){
					switch(index){
					case 0:
						uploadData.setData(splittedLine.get(0).replace("\"", ""));
						// PRM-2709: FAB_Admin_Elig_file_seg_file_upload_issue with incorrect CIN
						if(uploadData.getData().length()>100) {
							log.info("length is greater than 100");
							throw new AppException(ErrorCodes.INCORRECT_SEGMENT_DATA);
						}
						break;
					case 1:
						uploadData.setAttr1(splittedLine.get(1));
						break;
					case 2:
						uploadData.setAttr2(splittedLine.get(2));
						break;
					case 3:
						uploadData.setAttr3(splittedLine.get(3));
						break;
					case 4:
						uploadData.setAttr4(splittedLine.get(4));
						break;
					case 5:
						uploadData.setAttr5(splittedLine.get(5));
						break;
					case 6:
						uploadData.setAttr6(splittedLine.get(6));
						break;
					case 7:
						uploadData.setAttr7(splittedLine.get(7));
						break;
					default:
						break;
					}
				}
				segmentUploadData.add(uploadData);
			}
			
			String segmentID = UUID.randomUUID().toString();
			req.setCreateMode("UPLOAD");
			req.setRecordCount(segmentUploadData.size());
			int count = pinpointRepository.insertToSegment(req, segmentID);
			log.info("Segment created with id :{}", segmentID);
			if(count > 0) {
				//upload the file to new table.
				pinpointRepository.uploadSegmentBatch(segmentUploadData,segmentID, req );
				//Arrays.asList(parts).stream().forEach(record -> pinpointRepository.uploadSegment(record, segmentID, req));
			}
			response.setSegmentId(segmentID);
			return response;
		});
	}


import org.apache.commons.lang3.StringUtils;

private String[] parseCsvLine(String line) {
    List<String> result = new ArrayList<>();
    boolean inQuotes = false;
    StringBuilder current = new StringBuilder();

    for (char c : line.toCharArray()) {
        if (c == '"') {
            inQuotes = !inQuotes;
        } else if (c == ',' && !inQuotes) {
            result.add(current.toString());
            current = new StringBuilder();
        } else {
            current.append(c);
        }
    }
    result.add(current.toString());

    String[] parsedLine = result.toArray(new String[0]);

    // Validate second column if present
    if (parsedLine.length > 1) {
        String secondColumn = StringUtils.strip(parsedLine[1], "\"").trim();
        if (!isValidSecondColumn(secondColumn)) {
            return StringUtils.EMPTY_STRING_ARRAY;
        }
    } else {
        return StringUtils.EMPTY_STRING_ARRAY;
    }

    // Validate first column
    String firstColumn = StringUtils.strip(parsedLine[0], "\"").trim();
    if (StringUtils.isEmpty(firstColumn)) {
        return StringUtils.EMPTY_STRING_ARRAY;
    }

    return parsedLine;
}

private boolean isValidSecondColumn(String column) {
    // Your validation logic for the second column goes here
    // Example: Check if it's numeric with commas and dots
    return column.matches("[0-9,.]+");
}
private boolean isNumericWithCommaAndDot(String str) {
    return str.matches("[0-9,.]+");
}
And here are the updated unit tests:

java
Copy code
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class SegmentUploaderTest {

    SegmentUploader segmentUploader = new SegmentUploader();

    @Test
    public void testParseCsvLine_WithCommasInQuotes() {
        String line = "3605561,\"1,000\"";
        String[] result = segmentUploader.parseCsvLine(line);
        assertArrayEquals(new String[]{"3605561", "1,000"}, result);
    }

    @Test
    public void testParseCsvLine_WithDotsInQuotes() {
        String line = "3605561,\"1.000\"";
        String[] result = segmentUploader.parseCsvLine(line);
        assertArrayEquals(new String[]{"3605561", "1.000"}, result);
    }

    @Test
    public void testParseCsvLine_WithCommasAndDotsInQuotes() {
        String line = "3605561,\"1,000.00\"";
        String[] result = segmentUploader.parseCsvLine(line);
        assertArrayEquals(new String[]{"3605561", "1,000.00"}, result);
    }

    @Test
    public void testParseCsvLine_WithoutQuotes() {
        String line = "4676587,1000";
        String[] result = segmentUploader.parseCsvLine(line);
        assertArrayEquals(new String[]{"4676587", "1000"}, result);
    }

    @Test
    public void testParseCsvLine_WithMultipleColumns() {
        String line = "3605561,\"1,000\",test,\"data,with,commas\"";
        String[] result = segmentUploader.parseCsvLine(line);
        assertArrayEquals(new String[]{"3605561", "1,000", "test", "data,with,commas"}, result);
    }

    @Test
    public void testParseCsvLine_WithEmptyFields() {
        String line = "3605561,\"\",,";
        assertThrows(IllegalArgumentException.class, () -> segmentUploader.parseCsvLine(line));
    }

    @Test
    public void testParseCsvLine_WithNonNumericSecondColumn() {
        String line = "3605561,\"nonNumeric\"";
        assertThrows(IllegalArgumentException.class, () -> segmentUploader.parseCsvLine(line));
    }

    @Test
    public void testParseCsvLine_WithInvalidCharactersInSecondColumn() {
        String line = "3605561,\"1,000a\"";
        assertThrows(IllegalArgumentException.class, () -> segmentUploader.parseCsvLine(line));
    }

    @Test
    public void testParseCsvLine_WithMismatchedQuotes() {
        String line = "3605561,\"1,000";
        assertThrows(IllegalArgumentException.class, () -> segmentUploader.parseCsvLine(line));
    }

    @Test
    public void testParseCsvLine_WithExtraCommas() {
        String line = "3605561,\"1,000\",,,";
        String[] result = segmentUploader.parseCsvLine(line);
        assertArrayEquals(new String[]{"3605561", "1,000", "", "", ""}, result);
    }

    @Test
    public void testParseCsvLine_WithNoData() {
        String line = "";
        String[] result = segmentUploader.parseCsvLine(line);
        assertArrayEquals(new String[]{""}, result);
    }

    @Test
    public void testParseCsvLine_WithNonNumericDataInSecondColumn() {
        String line = "3605561,notNumeric";
        assertThrows(IllegalArgumentException.class, () -> segmentUploader.parseCsvLine(line));
    }

    @Test
    public void testParseCsvLine_WithQuotedCommasInSecondColumn() {
        String line = "3605561,\"data,with,commas\"";
        assertThrows(IllegalArgumentException.class, () -> segmentUploader.parseCsvLine(line));
    }
}

private void prepareAcctLoanDeposits(CustPositionResponse custPosition, CustomerProducts customerFavouriteProducts, CustomerProducts customerProducts, FeaturePromotion featurePromotion,
        Map<String, ProductPreference> userPreferences) {
    // sort accounts in customer position accounts by sorting order of Account types
    sortAccountsByAccountType(custPosition);
    List<AccountDetails> acctDetails = custPosition.getListOfAccounts();
    
    if (acctDetails != null && !acctDetails.isEmpty()) {
        for (AccountDetails acctDtl : acctDetails) {
            // Decide whether to show on dashboard
            if (isLoanAccountCode(acctDtl.getAccountType())) {
                if (!StringUtils.startsWithAny(acctDtl.getAccountNo(), SKIP_PD_LOANS)) {
                    Loan loan = getLoanData(acctDtl);
                    loan.setProduct(ProductTypes.LOAN.name());
                    
                    if (userPreferences.containsKey(loan.getLoanNumber())) {
                        ProductPreference prodPref = userPreferences.get(loan.getLoanNumber());
                        loan.setNickName(prodPref.getNickName());
                        loan.setDisplaySequence(prodPref.getDisplaySequence());
                        loan.setIsFavorite(prodPref.getIsFavorite());
                        loan.setIsHide(prodPref.getIsHide());
                        // Add all favorite products
                        if (prodPref.getIsFavorite()) {
                            customerFavouriteProducts.addLoan(loan);
                        }
                    } else {
                        loan.setDisplaySequence(0);
                    }
                    customerProducts.addLoan(loan);
                } else {
                    log.warn("#### Skipping PD loan from customer loan dashboard:{}", acctDtl.getAccountNo());
                }
            } else {
                // Skip deposit with HNI / ISL / NIF / ISB
                if (AccountType.TD.getCode().equals(acctDtl.getAccountType())) {
                    String accountId = acctDtl.getAccountNo();
                    if (StringUtils.startsWithAny(accountId, AppConstants.SKIP_PREFIX_DEPOSIT)) {
                        acctDtl.setAccountNo(accountId.substring(3));
                    }
                }
                Account acct = getAccountAndDepositData(acctDtl);
                
                if (userPreferences.containsKey(acct.getNumber())) {
                    ProductPreference prodPref = userPreferences.get(acct.getNumber());
                    acct.setNickName(prodPref.getNickName());
                    acct.setDisplaySequence(prodPref.getDisplaySequence());
                    acct.setIsFavorite(prodPref.getIsFavorite());
                    acct.setIsHide(prodPref.getIsHide());
                    acct.setIban(acctDtl.getIban());
                    // Add all favorite products
                    if (prodPref.getIsFavorite()) {
                        if (AccountType.TD.getCode().equals(acctDtl.getAccountType())) {
                            acct.setProduct(ProductTypes.DEPOSIT.name());
                            customerFavouriteProducts.addDeposit(acct);
                        } else {
                            acct.setProduct(ProductTypes.ACCOUNT.name());
                            customerFavouriteProducts.addAccount(acct);
                        }
                    }
                } else {
                    acct.setDisplaySequence(0);
                }
                
                // If iSave account to get the count to show on dashboard
                if (ProductCode.ISAVE.getCode().equals(acctDtl.getAccountCategoryCode())) {
                    acct.setAccountSubType("isave");
                    customerProducts.addIsave(acct);
                    customerProducts.addAccount(acct); // Adding Isave Account in account list after discussing with Pratik
                } else {
                    if (AccountType.TD.getCode().equals(acctDtl.getAccountType())) {
                        customerProducts.addDeposit(acct);
                    } else {
                        customerProducts.addAccount(acct);
                    }
                }
                
                if (Objects.nonNull(acctDtl.getDebitCards()) && !acctDtl.getDebitCards().isEmpty()) {
                    acctDtl.getDebitCards().stream().forEach(debitCard -> {
                        if (DateTimeHelper.INSTANCE.isFutureDate(debitCard.getExpirationDate(), DATE_DDMMYYYY)) {
                            if (DebitCardStatus.NEW_CARD.getCode().equals(debitCard.getCardStatus())) {
                                featurePromotion.addMaskedDcNumber(TextUtils.INSTANCE.maskCardNumber(debitCard.getDebitCardIdentifier(), AppConstants.MASK_CHARCTER));
                                if ("N".equalsIgnoreCase(debitCard.getCardDisplayIndicator())) {
                                    featurePromotion.incrementDebitCardCount();
                                }
                            }
                            if (AppConstants.DBT_CARD_ALLOWED_STATUS.contains(debitCard.getCardStatus())) {
                                Product product = new Product();
                                product.setLabel(TextUtils.INSTANCE.maskCardNumber(debitCard.getDebitCardIdentifier(), AppConstants.MASK_CHARCTER));
                                product.setProdRef(TextUtils.INSTANCE.getCardRef(debitCard.getDebitCardIdentifier()));
                                product.setStatus(DebitCardStatus.find(debitCard.getCardStatus()).getStatusDesc());
                                product.setProductType(ProductTypes.DEBIT);
                                product.setExpiryDate(DateTimeHelper.INSTANCE.formatDate(debitCard.getExpirationDate(), DATE_DDMMYYYY, DATE_MMYY));
                                if (Objects.nonNull(debitCard.getIssueDate()) && !debitCard.getIssueDate().isEmpty()) {
                                    product.setIssueDate(DateTimeHelper.INSTANCE.formatDate(debitCard.getIssueDate(), DATE_DDMMYYYY, DATE_MMYY));
                                } else {
                                    product.setIssueDate(debitCard.getIssueDate());
                                }
                                product.setDigitalCardIndicator(debitCard.getDigitalCardIndicator());
                                product.setVirtualCardIndicator(debitCard.getVirtualCardIndicator());
                                // product.setIssueDate(staticDataRepository.fetchStaticData_EN(VIRTUAL_DEBIT_CARD, ISSUE_DATE).getDescription());
                                // product.setDigitalCardIndicator(staticDataRepository.fetchStaticData_EN(VIRTUAL_DEBIT_CARD, DIGITAL_CARD_INDICATOR).getDescription());
                                // product.setVirtualCardIndicator(staticDataRepository.fetchStaticData_EN(VIRTUAL_DEBIT_CARD, VIRTUAL_CARD_INDICATOR).getDescription());
                                log.info("Virtual Debit card IssueDate, Digital", product.getIssueDate(), product.getVirtualCardIndicator(), product.getDigitalCardIndicator());
                                acct.addDebitCard(product);
                            }
                        }
                        
                        log.info("Debit Card Status " + DebitCardStatus.CARD_ACTIVE.getCode());
                        log.info("Debit Fetch Card Status " + debitCard.getCardStatus());
                        
                        if (DebitCardStatus.CARD_ACTIVE.getCode().equals(debitCard.getCardStatus())) {
                            if ("N".equalsIgnoreCase(debitCard.getCardDisplayIndicator())) {
                                featurePromotion.incrementActiveDebitCardCount();
                            }
                        }
                    });
                }
            }
        }
    } else {
        log.warn("Account:{} is not allowed on Dashboard View", acctDtl);
    }
}

kubectl cp <pod_name>:/var/kafka-ssl/abc.jks /local/path/abc.jks
kubectl exec -n <namespace> <pod_name> -- readlink -f /var/kafka-ssl/abc.jks

[root@g42uatlibmb1 npss]# kubectl exec -n npss npss-notifications-6467fb85db-4g5bq  -- readlink -f /var/ssl-store-kafka-ks/ibmb.keystore.uat.jks
/var/ssl-store-kafka-ks/..2024_06_24_07_46_23.547751902/ibmb.keystore.uat.jks
[root@g42uatlibmb1 npss]# kubectl cp npss-notifications-6467fb85db-4g5bq :..2024_06_24_07_46_23.547751902/ibmb.keystore.uat.jks /root/abc.jks
error: filespec must match the canonical format: [[namespace/]pod:]file/path
[root@g42uatlibmb1 npss]# kubectl cp npss-notifications-6467fb85db-4g5bq :/var/ssl-store-kafka-ks/..2024_06_24_07_46_23.547751902/ibmb.keystore.uat.jks  /root/abc.jks
error: filespec must match the canonical format: [[namespace/]pod:]file/path

kubectl cp npss/npss-notifications-6467fb85db-4g5bq:/var/ssl-store-kafka-ks/..2024_06_24_07_46_23.547751902/ibmb.keystore.uat.jks /root/abc.jks



String jsonString = "{"
    + "\"applicationArea\":{"
        + "\"countryOfOrigin\":\"AE\","
        + "\"senderId\":\"MOB\","
        + "\"transactionId\":\"A9f5243582a124a42bfa8fbe35e5db3e8\","
        + "\"transactionDateTime\":\"2024-XX-XXT04:01:04.004Z\","
        + "\"language\":\"EN\","
        + "\"creationDateTime\":\"22/Jun/2024 04:01:04\","
        + "\"requiredExecutionDate\":\"22/Jun/2024 04:01:04\""
    + "},"
    + "\"responseStatus\":{"
        + "\"status\":\"SUCCESS\","
        + "\"errorDetails\":[{"
            + "\"errorCode\":\"0\","
            + "\"errorDesc\":\"SUCCESS\""
        + "}]"
    + "},"
    + "\"common\":{"
        + "\"rateMode\":\"DBMODE\","
        + "\"rateReferenceNumber\":\"NA\""
    + "},"
    + "\"ratesResponse\":[{"
        + "\"buyCurrency\":\"USD\","
        + "\"sellCurrency\":\"AED\","
        + "\"buyingRate\":3.65779,"
        + "\"sellingRate\":3.68827,"
        + "\"dealtCurrency\":\"AED\","
        + "\"dealtAmount\":100.0,"
        + "\"status\":\"OK\","
        + "\"ccyPair\":\"USD.AED/S\","
        + "\"GMbuyingRate\":3.67248,"
        + "\"GMsellingRate\":3.67358,"
        + "\"GMbuyingMargin\":0,"
        + "\"GMsellingMargin\":0"
    + "}]"
+ "}";

22 Jun 2024 04:01:04,332 INFO (WebContainer : 31) (MOBILE-1000753765) [RequestInterceptor:]: Resource:/ft/mcsend/v1/fxrate/fetch, Request:{"amount":100.0,"fr
omCurrency":"AED","toCurrency":"PHP","transferCurrency":"AED","transferType":"P2P","txnRef":"f1db6b034aec4e44882ec1bbcf99d622"}

22 Jun 2024 04:01:04,332 INFO (WebContainer : 31) (MOBILE-1000753765) [RequestResolver:]: pathURL /ft/mcsend/v1/fxrate/fetch
22 Jun 2024 04:01:04,332 INFO (WebContainer : 31) (MOBILE-1000753765) [RequestResolver:]: rootPath:/ft
22 Jun 2024 04:01:04,332 INFO (WebContainer : 31) (MOBILE-1000753765) [RequestResolver:]: remainingPath:/mcsend/v1/fxrate/fetch
22 Jun 2024 04:01:04,341 INFO (WebContainer : 31) (MOBILE-1000753765) [FxRateSF:]: isNonUSDSettlement flag is :: false
22 Jun 2024 04:01:04,343 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: xref A9f5243582a124a42bfa8fbe35e5db3e8 | channelType "MOBILE"
22 Jun 2024 04:01:04,345 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: Connecting to URL:https://kproxy.risk-mw-pci-kong-prod.aeapps.bankfab
.com/ae/core/trapi/v1/exchange/rates, RequestType:POST, Headers:[{"name":"XXXX","value":"A9f5243582a124a42bfa8fbe35e5db3e8","elements":[{"name":"XXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXX","parameters":[],"parameterCount":0}]},{"name":"XXXXXXXX","value":"EN","elements":[{"name":"XX","parameters":[],"parameterCount":0}]},{
"name":"XXXXXXXXX","value":"MOB","elements":[{"name":"XXX","parameters":[],"parameterCount":0}]},{"name":"XXXXXXXXXXX","value":"87.200.21.97","elements":[{"n
ame":"XX.XXX.XX.XX","parameters":[],"parameterCount":0}]}]
22 Jun 2024 04:01:04,345 INFO (WebContainer : 31) (MOBILE-1000753765) [TextUtils:]: Masking special chars in log
22 Jun 2024 04:01:04,347 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: Http Request:{"rateObjectRequest":{"common":{"customerSegment":"IBMB.
MCSEND","valueDate":"2024-XX-XX","dealtCurrency":"AED","dealtAmount":100.0,"tenor":"SPOT","rateMode":"REALTIME","entity":"AE0XXXXX0001","daoCode":"1033X0100"
,"customerID":"1188110"},"rates":[{"buyCurrency":"USD","sellCurrency":"AED"}]},"applicationArea":{"countryOfOrigin":"AE","creationDateTime":"22/Jun/2024 04:0
1:04","requiredExecutionDate":"22/Jun/2024 04:01:04","senderId":"MOB","transactionDateTime":"2024-XX-XXT04:01:04.004Z","transactionId":"A9f5243582a124a42bfa8
fbe35e5db3e8","language":"EN"}}
22 Jun 2024 04:01:10,936 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: Status code 200
22 Jun 2024 04:01:10,936 INFO (WebContainer : 31) (MOBILE-1000753765) [TextUtils:]: Masking special chars in log
22 Jun 2024 04:01:10,938 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: Http Response:{"applicationArea":{"countryOfOrigin":"AE","senderId":"
MOB","transactionId":"A9f5243582a124a42bfa8fbe35e5db3e8","transactionDateTime":"2024-XX-XXT04:01:04.004Z","language":"EN","creationDateTime":"22/Jun/2024 04:
01:04","requiredExecutionDate":"22/Jun/2024 04:01:04"},"responseStatus":{"status":"SUCCESS","errorDetails":[{"errorCode":"0","errorDesc":"SUCCESS"}]},"common
":{"rateMode":"DBMODE","rateReferenceNumber":"NA"},"ratesResponse":[{"buyCurrency":"USD","sellCurrency":"AED","buyingRate":3.65779,"sellingRate":3.68827,"dea
ltCurrency":"AED","dealtAmount":100.0,"status":"OK","ccyPair":"USD.AED/S","GMbuyingRate":3.67248,"GMsellingRate":3.67358,"GMbuyingMargin":0,"GMsellingMargin"
:0}]}
22 Jun 2024 04:01:10,938 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: Http request processed in :6595 msec for URL:https://kproxy.risk-mw-p
ci-kong-prod.aeapps.bankfab.com/ae/core/trapi/v1/exchange/rates
22 Jun 2024 04:01:10,939 INFO (WebContainer : 31) (MOBILE-1000753765) [FxRateServiceInvoker:]: API URL is : https://kproxy.risk-mw-pci-kong-prod.aeapps.bankf
ab.com/ae/core/trapi/v1/exchange/rates
22 Jun 2024 04:01:10,939 INFO (WebContainer : 31) (MOBILE-1000753765) [FxRateServiceInvoker:]: Handle 4XX errors in sf class..
22 Jun 2024 04:01:10,939 ERROR (WebContainer : 31) (MOBILE-1000753765) [ExceptionHandler:]: Handle null pointer exception for:java.lang.NullPointerException
22 Jun 2024 04:01:10,940 INFO (WebContainer : 31) (MOBILE-1000753765) [LocaleHelper:]: locale:en, code:SYS_DEFAULT_ERROR, text translation:We are unable to p
rocess your request right now. Please try again later.
22 Jun 2024 04:01:10,943 INFO (WebContainer : 31) (MOBILE-1000753765) [RequestInterceptor:]: Resource:/ft/mcsend/v1/fxrate/fetch response:{"result":{"status"
:"error","errorInfo":{"code":"SYS_DEFAULT_ERROR","desc":"We are unable to process your request right now. Please try again later. "}}}
22 Jun 2024 04:01:10,943 INFO (WebContainer : 31) (MOBILE-1000753765) [UserStatisticsSF:]: CIF ID in PageViewReport userID 10007X3765, convid ba461cb4f8e3448
a81baf93f48a3e2f5, url point /ft/mcsend/v1/fxrate/fetch::
22 Jun 2024 04:01:10,944 INFO (WebContainer : 31) (MOBILE-1000753765) [UserStatisticsSF:]: Page View Report {"cif":"10007X3765","cin":"1188110","channelType"
:"MOBILE","viewedPage":"/ft/mcsend/v1/fxrate/fetch","httpStatus":"SUCCESS","httpErrorCode":"0","httpErrorDesc":"SUCCESS","apiStatus":"error","apiErrorCode":"
SYS_DEFAULT_ERROR","rc":"A9f5243582a124a42bfa8fbe35e5db3e8","creationTime":1719014464062,"completionTime":1719014470943,"remoteIp":"87.200.21.97"} ::
22 Jun 2024 04:01:10,980 INFO (WebContainer : 31) (MOBILE-1000753765) [UserStatisticsSF:]: exiting publish2UserStatisticsQ method
22 Jun 2024 04:01:10,980 INFO (WebContainer : 31) (MOBILE-1000753765) [ResponseFilter:]: == URL:/ft/mcsend/v1/fxrate/fetch processed, total time:6932 msec ==
-----------------------------------------

	public McFxRateFetchResponse fetchMCFxRate(final McFxRateFetchRequest request) {
		McFxRateFetchResponse response = new McFxRateFetchResponse();
		return execute(request, response, req -> {
			boolean isNonUSDSettlement = false;
			Double marginPerc = null;
			Double fxRate = null;
			Double conversionRate = null;
			String toCurrency = request.getToCurrency();
			Integer timeToLive = null;
			
			List<McProduct> productByCurrAndType = mcSendRepository.getProductByCurrAndType(request.getToCurrency(),
					request.getTransferType());
			if (!productByCurrAndType.isEmpty()) {
				McProduct mcProduct = productByCurrAndType.get(0);
				if (Objects.nonNull(mcProduct) && StringUtils.isNotBlank(mcProduct.getCurrencyCode())
						&& mcProduct.getCurrencyCode().equalsIgnoreCase(mcProduct.getSendCurrency())) {
					isNonUSDSettlement = true;
				}
			}
			log.info("isNonUSDSettlement flag is :: {}", isNonUSDSettlement);
			if(!isNonUSDSettlement) {
				log.debug("continuing with non USD settlement flow");
				ExchangeRateRequest exchangeRateRequest = new ExchangeRateRequest();
				String dealtCurrency = CURR_AED;
				String buyCurrency = CURR_USD;
				String sellCurrency = CURR_AED;
				exchangeRateRequest.addRate(buyCurrency, sellCurrency, dealtCurrency);
				exchangeRateRequest.setCreditValueDate(new Date());
				exchangeRateRequest.setCustomerRateSegment(MCSEND_SEGMENT);
				exchangeRateRequest.setAmount(request.getAmount());
				
				// 1.Fetch AED to USD rate
				FxRateGetRateResponse exchangeRateResponse = exchangeRateServiceInvoker
						.fetchExchangeRate(exchangeRateRequest);
				if (Objects.nonNull(exchangeRateResponse)
						&& RATE_MODE_REALTIME.equalsIgnoreCase(exchangeRateResponse.getCommon().getRateMode())
						&& exchangeRateResponse.getRatesResponse().isEmpty()) {
					throw new AppException(ErrorCodes.ERROR_FETCH_FX_RATE);
				}

				if (Objects.nonNull(exchangeRateResponse)
						&& !RATE_MODE_REALTIME.equalsIgnoreCase(exchangeRateResponse.getCommon().getRateMode())
						&& exchangeRateResponse.getRateResponse().isEmpty()) {
					throw new AppException(ErrorCodes.ERROR_FETCH_FX_RATE);
				}
				
				RateResponse rateResponse = RATE_MODE_REALTIME.equalsIgnoreCase(exchangeRateResponse.getCommon().getRateMode())
						? exchangeRateResponse.getRatesResponse().get(0)
						: exchangeRateResponse.getRateResponse().get(0);
				Double aedToUsdRate = 1/rateResponse.getSellingRate();
				
				// 2.Fetch USD to FCY rate from DB
				
				McFcyRate mcFcyRate = mcSendRepository.getMcFcyRate(toCurrency, request.getTransferType());
				if (Objects.isNull(mcFcyRate)) {
					throw new AppException(ErrorCodes.ERROR_FETCH_FX_RATE);
				}
				Double usdToFcyRate = mcFcyRate.getFxRate();
				conversionRate = aedToUsdRate * usdToFcyRate;
				log.info("conversionRate received in non USD settlement flow is :: {}", conversionRate);
				
			}else {
				//getDeal invocation
				log.debug("continuing with USD settlement flow :: ");
				FxRateFetchRequest fxRatefetchReq = new FxRateFetchRequest();
				fxRatefetchReq.setFromCurrency(request.getFromCurrency());
				fxRatefetchReq.setToCurrency(toCurrency);
				fxRatefetchReq.setTransferCurrency(request.getTransferCurrency());
				fxRatefetchReq.setAmount(request.getAmount());
				fxRatefetchReq.setTxnRef(request.getTxnRef());
				GetDealResponse dealResponse = getDeal(fxRatefetchReq);
				log.debug("Deal resp received is :: {}", dealResponse);
				if (Objects.nonNull(dealResponse)&&Objects.nonNull(dealResponse.getRate())) {
					conversionRate = 1/dealResponse.getRate().getValue();
					timeToLive = dealResponse.getTimeToLive();
				}else {
					throw new AppException(ErrorCodes.SYS_TECHNICAL_ERROR);
				}
				log.info("conversionRate received in USD settlement flow is :: {} and timeToLive is :: {}", conversionRate, timeToLive);
			}
			
			// 3.fetch margin
			//Double fxRate = aedToFcyRate;
			if (!productByCurrAndType.isEmpty()) {
				McProduct mcProduct = productByCurrAndType.get(0);
				if (Objects.nonNull(mcProduct)) {
					List<String> staffSectorList = settingsRepository.getStaffSectorList();
					if (SessionContext.getSession().getUser().identifyStaff(staffSectorList)) {
						marginPerc = mcProduct.getStaffFxMargin();
					}else
						marginPerc = mcProduct.getFxMargin();
				}
			}
			if (Objects.nonNull(marginPerc)) {
				fxRate = (conversionRate * (1 - marginPerc / 100));
			}
			McFxRate mcFxRate = new McFxRate();
			mcFxRate.setRate(new Amount(fxRate, toCurrency));
			mcFxRate.setTransferAmount(new Amount(fxRate * request.getAmount(), toCurrency));
			mcFxRate.setFromCurrency(request.getFromCurrency());
			mcFxRate.setToCurrency(toCurrency);
			mcFxRate.setTimeToLive(timeToLive);
			List<McFxRate> mcFxRates = new ArrayList<>();
			mcFxRates.add(mcFxRate);
			response.setMcFxRates(mcFxRates);
			log.debug("McFxRate is :: {}", mcFxRate.getRate());
			
			// 4. UPDATE rates in txnsession
			TxnSession txnSession = sessionRepository.findTxnSessionByTxnRef(req.getTxnRef());
			String exchangeRateStr = txnSession.getExchangeRate();
			log.debug("exchangeRateStr received from DB is :: {}", exchangeRateStr);
			FxRateGetDealResponse fxRateDealResponse = null;
			if(isNonUSDSettlement) {
				if (StringUtils.isNotBlank(exchangeRateStr)) {
					fxRateDealResponse = JsonUtils.convertToObject(FxRateGetDealResponse.class, exchangeRateStr);
					log.debug("exchangeRate received from deal service is :: {}", fxRateDealResponse);
				}else {
					log.error("Didnt receive exchangerate infor from session repo");
				}
			}
			McExchangeRate mcExchangeRate = new McExchangeRate();
			//if fx rate not exist in session
			if (StringUtils.isNotBlank(exchangeRateStr)) {
				mcExchangeRate = JsonUtils.convertToObject(McExchangeRate.class, exchangeRateStr);
			}
			mcExchangeRate.setFxRate(conversionRate);//dealWrapperRate
			mcExchangeRate.setFxRateWithMargin(fxRate);
			mcExchangeRate.setFxMargin(marginPerc);
			mcExchangeRate.setTrapiFxRate(conversionRate);//dealWrapperRate
			mcExchangeRate.setExchangeRate(!Objects.isNull(fxRateDealResponse)?getExchangeRateObj(fxRateDealResponse):null);
			log.info("final mcExchangeRate formed is :: {}", mcExchangeRate);
			
			TxnSession session = new TxnSession();
			session.setExchangeRate(JsonUtils.convertToJson(mcExchangeRate));
			session.setTxnRef(req.getTxnRef());
			log.info("Update TXN Session | txnRef: {} exchangerate:{}",req.getTxnRef(),JsonUtils.convertToJson(mcExchangeRate));
			sessionRepository.updateExchangeRate(session);

			return response;
		});
	}

----------------------------------------------------
public FxRateGetRateResponse fetchExchangeRate(ExchangeRateRequest iibRequest) {
		return invoke(ServiceURLs.FX_EXCHANGE_RATE,iibRequest,requestComposer, responseComposer);
	}

----------------------------------------------------
protected <T, R> R invoke(final ServiceURLs serviceURL, T reqObj, Function<T, String> requestComposer, Function<ConnectorResponse, R> responseComposer) {
		ConnectorResponse response = null;
		R respObj = null;
		long t1 = System.currentTimeMillis();
		try {
			serviceInvokerHelper.populateServicUrlEnum(serviceURL);
			String request = requestComposer.apply(reqObj);
			response = httpConnector.post(serviceURL, request, null);
			handleResponse(response, serviceURL);
			respObj = responseComposer.apply(response);
		} catch (Exception e) {
			if (e instanceof AppException || e instanceof SysException) {
				throw e;
			}
			log.error("service invoke failed.." , e);
			throw new AppException(ErrorCodes.SYS_TECHNICAL_ERROR, e);
		} finally {
			log.debug("Service:{} invocation time:{} msec", serviceURL, System.currentTimeMillis() - t1);
			captureHttpStatus(response);
		}
		return respObj;
	}

-------------------------------------------------------
private final Function<ExchangeRateRequest,String> requestComposer = (iibRequest)->{	   
	    Map<String, Object> reqMap = new HashMap<>();
	    SessionInfo sessionInfo = SessionContext.getSession();
	    reqMap.put(APPLICATION_AREA,FABUtils.INSTANCE.getIibReqApplicationArea(sessionInfo.getChannelType(), localeHelper.resolveLanguage(), sessionInfo.getXref()));
	    reqMap.put(RATE_REQ_OBJECT, populateIIBRequest(iibRequest));
	    return JsonUtils.convertToJson(reqMap);
	};
		
	private final Function<ConnectorResponse, FxRateGetRateResponse> responseComposer = (response) -> {
		FxRateGetRateResponse serviceResponse = new FxRateGetRateResponse();
		if (AppConstants.SUCCESS.equalsIgnoreCase(JsonUtils.getJsonPrimitive(response.getJsonResponse(), "$.responseStatus.status"))) {
			serviceResponse = JsonUtils.convertToObject(FxRateGetRateResponse.class, response.getJsonResponse());
		} else {
			throw new AppException(ErrorCodes.ERROR_FETCH_FX_RATE);
		}	
		
		return serviceResponse;
	};




https://www.credly.com/users/umer-farooq.1cd67eef/badges
https://cs.lpi.org/caf/Xamman/certification/verify/LPI000281162/jjngcyhqvv
http://81cd1176253f3f59d435-ac22991740ab4ff17e21daf2ed577041.r77.cf1.rackcdn.com/Certificates/ScrumFundamentalsCertified-UmerFarooq-554089.pdf
http://certification.salesforce.com/certification-detail-print?conId=0034A00002p

*/5 * * * *
If a user enters a credit card number:

It will check if the card is from one of these banks: FIRST GULF BANK, NATIONAL BANK OF ABU DHABI, or FIRST ABU DHABI BANK.
If the card is from one of these banks:
It will make sure the account is in AED (Emirati Dirham) and belongs to the logged-in user.
If the card is not from one of these banks:
It will check if it is a valid IBAN number.

0 0 5 * * ?
 filters records to only include those that have been modified within the past 24 hours from the current time.

Detailed Breakdown for Stakeholders with Justifications
Product Content Configuration:

Integration with Sitecore API:
Task: Develop robust API clients and handle authentication, data retrieval, and error handling.
Justification: Integrating with the Sitecore API is essential to ensure real-time updates and accurate product information on the website. Robust error handling and authentication are necessary to maintain data integrity and security.
Estimation: 2 weeks
Database Design:
Task: Create a database schema to efficiently store and query product details.
Justification: A well-designed database schema ensures that product data is stored efficiently and can be retrieved quickly, which is crucial for performance and scalability.
Estimation: 1 week
API Development:
Task: Build scalable REST APIs to serve the product content to the frontend applications.
Justification: Exposing product details through a REST API allows for decoupling the backend and frontend, making the system more modular and easier to maintain. It also facilitates integration with other systems or future enhancements.
Estimation: 2 weeks
UI/UX - Capture User Data:

Content Configuration:
Task: Set up configurations for content delivery, ensuring it is responsive to user inputs and preferences.
Justification: Dynamic content delivery enhances user experience by providing personalized information based on user inputs, which can increase user engagement and satisfaction.
Estimation: 1 week
Data Capture Endpoints:
Task: Develop backend endpoints to securely capture and store user data.
Justification: Capturing user data accurately and securely is crucial for compliance with data protection regulations and for personalizing user experience. Ensuring secure data handling prevents potential data breaches.
Estimation: 2 weeks
Validation and Processing:
Task: Implement server-side validation to ensure data integrity and security.
Justification: Validating data on the server-side helps prevent invalid or malicious data from entering the system, thus protecting the application from potential attacks and ensuring data quality.
Estimation: 1 week
Quote Functionality:

Service Integration:
Task: Develop service layer to communicate with insurance microservices.
Justification: Integrating with external microservices allows for leveraging existing functionalities and data from insurance providers, which can reduce development time and improve reliability.
Estimation: 3 weeks
Quote Logic Enhancement:
Task: Update existing quote creation logic to handle new insurance options.
Justification: Enhancing the quote functionality to include additional insurance options provides users with more choices, potentially increasing conversion rates and customer satisfaction.
Estimation: 2 weeks
Testing and Validation:
Task: Perform extensive testing to ensure the new quote functionality works seamlessly with existing systems.
Justification: Thorough testing is essential to identify and fix bugs, ensuring that the new features work correctly and do not introduce any regressions. This helps maintain system stability and reliability.
Estimation: 2 weeks

Summary with Justifications
Total Duration: Approximately 13 weeks
Resources: Depending on the team size and expertise, parallel task execution might reduce the overall time.
Justifications:
Integration Tasks: Necessary for ensuring that the backend can communicate effectively with external systems and provide real-time, accurate data to the frontend.
Database Design: Critical for performance, scalability, and efficient data retrieval.
API Development: Facilitates modularity, maintainability, and potential future integrations.
Content Configuration: Enhances user experience through personalized content delivery.
Data Capture and Validation: Ensures data integrity, compliance with regulations, and security against potential threats.
Service Integration and Logic Enhancement: Provides users with enhanced functionalities and options, improving overall service offering.
Testing and Validation: Ensures the reliability and stability of the system, preventing future issues.
This detailed and justified plan helps stakeholders understand the necessity of each task, the effort involved, and the benefits these tasks bring to the overall project. This understanding is crucial for accurate resource allocation and time estimation.


----------------------------
Product Content Configuration
Tasks:
Integration with Sitecore API:
Needs to be built from scratch: Developing API clients to fetch product data from Sitecore.
Database Design:
Needs to be built from scratch: Creating a database schema to store product details.
API Development:
Needs to be built from scratch: Building REST APIs to expose product details.
UI/UX - Capture User Data
Tasks:
Content Configuration:
Needs to be built from scratch: Setting up configurations for content delivery based on user data.
Data Capture Endpoints:
Needs to be built from scratch: Developing endpoints to capture and store user data.
Validation and Processing:
Needs to be built from scratch: Implementing server-side validation and processing for captured data.
Quote Functionality
Tasks:
Service Integration:
Needs to be built from scratch: Developing service layers to communicate with insurance microservices.
Quote Logic Enhancement:
Enhancement: Updating existing quote creation logic to handle new insurance options.
Testing and Validation:
Needs to be built from scratch: Performing extensive testing of the new and enhanced functionalities.
Summary of Tasks
Needs to be built from scratch:
Product Content Configuration

Integrate with Sitecore API
Design and implement database schema for product data
Develop REST APIs to expose product details
UI/UX - Capture User Data

Configure content delivery based on user data
Develop endpoints for capturing and storing user data
Implement server-side validation and processing
Quote Functionality

Integrate with insurance microservices
Perform comprehensive testing of new and enhanced functionalities
Needs to be enhanced:
Quote Functionality
Update the existing quote creation logic to handle new insurance options
Detailed Justification
Product Content Configuration:

Integration with Sitecore API: This task involves building the integration from scratch as it requires developing new API clients and handling specific authentication and data retrieval mechanisms.
Database Design: Creating a new database schema is necessary to store the product data effectively.
API Development: New REST APIs are required to expose product details, ensuring that frontend applications can access this data seamlessly.
UI/UX - Capture User Data:

Content Configuration: This involves setting up a new configuration system to deliver content dynamically based on user inputs, which is a new build.
Data Capture Endpoints: Developing new endpoints to capture and store user data is essential for personalizing the user experience.
Validation and Processing: Implementing server-side validation and processing ensures data integrity and security, which needs to be built from scratch.
Quote Functionality:

Service Integration: This involves building new service layers to communicate with insurance microservices, which is a new task.
Quote Logic Enhancement: Modifying the existing quote creation logic to include new insurance options is an enhancement of the current functionality.
Testing and Validation: Comprehensive testing of both new and enhanced functionalities is crucial to ensure system stability and reliability.
This breakdown helps stakeholders understand the scope of new developments and enhancements, allowing for better estimation of build efforts and resource allocation.
