import boto3
import pbcore.logger as logger
from datetime import datetime
import service.PropertyUtil as propertyutil
from boto3.dynamodb.conditions import Key
from botocore.exceptions import ClientError
import os
from pbcore.aws.parameterstore import get_lambda_ssm_param_value
import service.PropertyUtil as property_util
import json
from boto3.dynamodb.types import TypeDeserializer
from boto3.dynamodb.types import TypeSerializer

LAMBDA_FUNCTION = os.environ.get("AWS_LAMBDA_FUNCTION_NAME")


table_name = propertyutil.getValue("ENVIRONMENT") + "_push_notification_token"


dynamodb = boto3.client('dynamodb')

import boto3
import pbcore.logger as logger
from datetime import datetime
import service.PropertyUtil as propertyutil
from boto3.dynamodb.conditions import Key
from botocore.exceptions import ClientError
import os
from pbcore.aws.parameterstore import get_lambda_ssm_param_value
import service.PropertyUtil as property_util
import json
from boto3.dynamodb.types import TypeDeserializer
from boto3.dynamodb.types import TypeSerializer

LAMBDA_FUNCTION = os.environ.get("AWS_LAMBDA_FUNCTION_NAME")


table_name = propertyutil.getValue("ENVIRONMENT") + "_push_notification_token"


dynamodb = boto3.client('dynamodb')

"""
Fetches device details from DynamoDB based on the provided device ID.

Args:
- deviceId: The ID of the device to fetch details for.

Returns:
- dict: A dictionary containing the device details fetched from DynamoDB.
"""
def fetch_by_deviceId(deviceId):
    try:
        response = dynamodb.get_item(
            TableName=table_name,
            Key={"device_id": {"S": deviceId}}
        )
        item = response["Item"]
        print("Device Details")
        return dynamo_to_python(item)
    except ClientError as err:
        logger.error(f"fetch record error {err}")

"""
Deletes a database record based on the provided device ID.

Args:
- deviceId: The ID of the device whose record needs to be deleted.

Returns:
- dict: The response from the deletion operation.
"""
def delete_by_deviceId(deviceId):
    try:
        return dynamodb.delete_item(TableName=table_name, Key={"device_id": {"S": deviceId}})
        
    except ClientError as err:
        logger.error(f"delete record error {err}")

"""
Creates a new record in DynamoDB based on the provided record details.

Args:
- record: A dictionary containing the details of the record to be inserted.

Returns:
- dict: The response from the DynamoDB `put_item` operation.
"""
def insert_device_details(record):
    logger.info("Create the Record in DynamoDB")
    now = datetime.now()
    date_time = now.strftime("%y-%m-%d, %H:%M:%S")
    try:
        item = {key: {'S': str(value)} for key, value in record.items()} | {
            "created_at": {'S': date_time},
            "modified_at": {'S': date_time},
        }
        response = dynamodb.put_item(TableName=table_name, Item=item)
        print(f'Insert response: {response}')

    except Exception as e:
        logger.error(f'An unexpected error occurred :: create_or_update_record : {e}')

"""
Updates device details in DynamoDB based on the provided device details.

Args:
- device_details: A JSON string containing the device details to be updated.

Returns:
- dict: The response from the update operation in DynamoDB.
"""
def update_device_details(device_details):
    now = datetime.now()
    date_time = now.strftime("%y-%m-%d, %H:%M:%S")
    logger.info(f"Starting update process at {date_time}")

    record = python_to_dynamo(json.loads(device_details))
    attribute_updates = {key: {'Value': value} for key, value in record.items() if key != 'deviceId'}
    attribute_updates['modfied_at'] = {'Value': {'S': date_time}}

    try:
        response = dynamodb.update_item(
            TableName=table_name,
            Key={"device_id": record["deviceId"]},
            AttributeUpdates=attribute_updates
        )
        print(f'Record Updated:{response}')
    except ClientError as err:
        logger.error(f"Unable to update device details for deviceId: {record['deviceId']} - {err}")
        raise
    logger.info("Updated device details successfully")
    return response
 
"""
Converts a DynamoDB object to a Python dictionary.

Args:
- dynamo_object: A DynamoDB object to be converted to a Python dictionary.

Returns:
- dict: The Python dictionary after deserialization.
"""
def dynamo_to_python(dynamo_object: dict) -> dict:
    deserializer = TypeDeserializer()
    return {
        k: deserializer.deserialize(v)
        for k, v in dynamo_object.items()
    }

"""
Converts a Python dictionary to a DynamoDB object.

Args:
- python_object: A Python dictionary to be converted to a DynamoDB object.

Returns:
- dict: The DynamoDB object after serialization.
"""
def python_to_dynamo(python_object: dict) -> dict:
    serializer = TypeSerializer()
    return {
        k: serializer.serialize(v)
        for k, v in python_object.items()
    }

---------------
def insert_device_details(record):
    logger.info("Create the Record in DynamoDB")
    now = datetime.now()
    date_time = now.strftime("%y-%m-%d, %H:%M:%S")
    
    try:
        response=dynamodb.put_item(TableName = table_name, Item = {
                    "customer_Id": {'S' : record['customerId']},
                    "cif": {'S' : record['cif']},
                    "device_id": {'S' : record['deviceId']},
                    "device_type": {'S' : record['deviceType']},
                    "token": {'S' : record['token']},
                    "platform": {'S' : record['platform']},
                    "app_version": {'S' : record['appVersion']},
                    "os_version": {'S' : record['osVersion']},
                    "make": {'S' : record['make']},
                    "model": {'S' : record['model']},
                    "language": {'S' : record['language']},
                    "endpoint_arn": {'S' : record['endpoint_arn']},
                    "created_at": {'S' : date_time},
                    "modfied_at": {'S' : date_time}
                 })
        print(f'Insert response:{response}')

    except Exception as e:
       logger.error(f'An unexpected error occurred :: create_or_update_record : {e}')

"""
Method for update device details
"""


def update_device_details(device_details):
    print(f'Update information')
    now = datetime.now()
    date_time = now.strftime("%y-%m-%d, %H:%M:%S")
    logger.info(
        f"New record"
    )
    
    record = python_to_dynamo(json.loads(device_details))
    logger.info(
        f"Serialize"
    )
    logger.info(
        f"Updating fields"
    )
    try:
        response = dynamodb.update_item(TableName = table_name,
            Key={"device_id": record["deviceId"]},
            AttributeUpdates={"cif": {'Value' : record['cif']},
                    "customer_id": {'Value' : record['deviceId']},
                    "device_type": {'Value' : record['deviceType']},
                    "token": {'Value' : record['token']},
                    "platform": {'Value' : record['platform']},
                    "app_version": {'Value' : record['appVersion']},
                    "os_version": {'Value' : record['osVersion']},
                    "make": {'Value' : record['make']},
                    "model": {'Value' : record['model']},
                    "language": {'Value' : record['language']},
                    "endpoint_arn": {'Value' : record['endpointArn']},
                    "modfied_at": {'Value' : {'S' : date_time}}
            })
        print(f'Record Updated:{response}')
    except ClientError as err:
        logger.error(
            f"Unable to update device details for deviceId: {record["deviceId"]}"
        )
        raise
    logger.info(f"Updated device details")
    return response

import json

class DeviceTokenDetails:
    def __init__(self, customerId, cif, deviceId, deviceType, token, platform, appVersion, osVersion, make, model, language, endpointArn):
        
        self.customerId = customerId
        self.cif = cif
        self.deviceId = deviceId
        self.deviceType = deviceType
        self.token =  token
        self.platform = platform
        self.appVersion = appVersion
        self.osVersion = osVersion
        self.make = make
        self.model = model
        self.language = language
        self.endpointArn = endpointArn

    # Setters
    def setCustomerId(self, customerId):
        self.customerId = customerId

    def setCif(self, cif):
        self.cif = cif    

    def setDeviceId(self, deviceId):
        self.deviceId = deviceId    

    def setDeviceType(self, deviceType):
        self.DeviceType = deviceType

    def setToken(self, token):
        self.token = token

    def setPlatform(self, platform):
        self.platform = platform

    def setAppVersion(self, appVersion):
        self.appVersion = appVersion

    def setOsVersion(self, osVersion):
        self.osVersion = osVersion    

    def setMake(self, make):
        self.make = make

    def setModel(self, model):
        self.model = model

    def setLanguage(self, language):
        self.language = language    

    def setEndpointArn(self, endpointArn):
        self.endpointArn = endpointArn

    # Getter
    def getCustomerId(self):
        return self.customerId

    def getCif(self):
        return self.cif    

    def getDeviceId(self):
        return self.deviceId    

    def getDeviceType(self):
        return self.DeviceType

    def getToken(self):
        return self.token

    def getPlatform(self):
        return self.platform

    def getAppVersion(self):
        return self.appVersion

    def getOsVersion(self):
        return self.osVersion    

    def getMake(self):
        return self.make

    def getModel(self):
        return self.model

    def getLanguage(self):
        return self.language    

    def getEndpointArn(self):
        return self.endpointArn

    def to_json(self):
        print("I am here")
        return json.dumps(self, default=lambda o: o.__dict__, indent=4)

 response = DeviceTokenDetails(
         message_data['customerId'],message_data['cif'], message_data['deviceId'], message_data['deviceType'],message_data['token'],message_data['platform'],message_data['appVersion'],
         message_data['osVersion'],message_data['make'],message_data['model'],message_data['language'],endpoint).to_json()
