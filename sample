

Current Issue: 

The request payload for the Sim Swap External Endpoint is duplicating the transaction details: 

PFBCallSignrequestcapturedonDP-{
	"applicationArea": {
		"senderId": ["IB","IB"],
		"countryOfOrigin": ["AE",
		"AE"],
		"transactionDateTime": ["2024-06-03T03:12:02.002Z",
		"2024-06-03T03:12:03.003Z"],
		"transactionId": "af885605-973e-4ebf-92ce-a8cd010d8bb2"
	},
	"dataArea": {
		"phoneNumber": ["0582725831",
		"0582725831"],
		"referenceDate": ["2024-05-04 03:12:02.751",
		"2024-05-04 03:12:03.079"],
		"customerIdentifier": ["594909f43972f1b78fb98526bcf2e74f",
		"594909f43972f1b78fb98526bcf2e74f"]
	}
}

Current PUT (Update) Payload: 

The current payload for the PUT (update) Request is adding additional transaction object and user object – this is causing the duplication above:

14 Aug 2024 10:49:43,919 INFO (WebContainer : 41) (BROWSER-1005871968) [HttpConnector:]: Http Request:{"userName":"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX","transac
tionId":"1fb2903d-3abe-4d79-8d57-9c01466cb242","sessionId":"482f787a-7eb9-4b93-82ea-5208c56b1cc7","transactionType":"LOGIN","context":[{"type":"AUTHENTICATIO
N","authentication":{"requirementsCombination":{"requirementId":"b950c446-3f7b-41a7-a74c-3fd733d1d8e7","metadata":{"tenantId":"tnt-fnh3br5y-tbdcvkty-3gvvdtxj
v-42kmmf2n","userId":"sub-4rh9n35s-9e1wk1dn-atyjw3pw5-qbx619q7","transactionId":"1fb2903d-3abe-4d79-8d57-9c01466cb242","externalSessionId":"482f787a-7eb9-4b9
3-82ea-5208c56b1cc7","qualifiedIdentity":{"namespace":"userName","id":"7b73e457af6bb6c46ecced0f5XXX88ed"},"timestamp":1723618183760,"mostRecentlyUsedDeviceId
":"-1","language":["en"]},"combinationType":"REQUIREMENT","priority":0,"priorityReason":"ORG_EXPLICIT","requirement":{"type":"AUTHENTICATE","authenticator":{
"channel":"EXTERNAL","bindChannel":"EXTERNAL","className":"UNP","validationMode":"EXTERNAL","deliveryMode":"DEFAULT","displayName":"UNP","mechanism":{"displa
yName":"UNP","factorTypes":["KNOWLEDGE"],"mechanismType":"EXTERNAL","mode":"PRIMARY"},"preference":0,"strength":0,"currentFailureCount":0,"dynamicLinkingFlag
":false,"templates":{},"restrictions":[],"restricted":false,"additionalAttributes":{"maxChallenges":"5","maxAttempts":"3","PERSISTANT_DATA":"false","EXCHANGE
_SDK_DATA":"false"}},"channel":"EXTERNAL","validationMode":"EXTERNAL","deliveryMode":"DEFAULT","challengeData":[{"id":"CS_TITLE","displayValue":"login"},{"id
":"CS_TOTAL_AMOUNT","displayName":"TOTAL_AMOUNT","displayValue":""},{"id":"CS_AUTH_CODE","displayName":"AUTH_CODE","displayValue":"67075478"}],"timestamp":0}
,"timestamp":1723618183794},"result":{"result":"SUCCESS"},"resultsMap":{"b950c446-3f7b-41a7-a74c-3fd733d1d8e7":{"result":"SUCCESS"}},"completedTimestamp":172
3618183863}}, {"type":"TRANSACTION","transaction":{"additionalTransactionInformation":{"forgotPasswordInHours":"19655","authmessage_en":"Swipe to complete you
r login to FAB Online Banking","transactionDateTime":"2024-XX-XXT10:49:43.043Z","forgotPINInHours":"9999","mobileBankingLock":"false","custOnboardInDays":"90
4","channel":"IB","pinChangedInDays":"9999","IB_AUTH":"MOBILE","simSwapReferenceInHours":"720","phoneNumber":"0XXXXX1580","internetBankingLock":"false","coun
tryOfOrigin":"AE","referenceDate":"2024-XX-XX 10:49:43.911","authmessage_ar":"Swipe to complete your login to FAB Online Banking","pwdChangedInDays":"9999"}}
},{"source":"DECISION_REQUEST","type":"USER","user":{"externalUniqueId":"7b73e457af6bb6c46ecced0f5XXX88ed","additionalAttributes":{"device_id":"br_083e0849-d
7ad-4ea7-aa91-dac8a882fabe"},"timestamp":1723618183911}}],"authenticator":"UNP","language":"en"} 


Proposed Solution for the above context:

In the FAB Code base - Remove ONLY the Transaction Object and User Object from the PUT (Update) ETG Call. Everything else should remain the same.

SAMPLE PUT (Update) Request Body:

{
    "request": {
        "metadata": {
            "tenantId": "{{tenantId}}",
            "timestamp": {{currentTime}},
            "externalSessionId": "sessionID",
            "transactionId": "transactionId",
            "qualifiedIdentity": {
                "id": "amuhaimin",
                "namespace": "userName"
            }
        },
        "transaction": {
            "brand": {
                "value": "{{organisationId}}"
            },
            "type": {
                "value": "login"
            },
            "channel": {
                "value": "IB"
            }
        },
        "context": [
            {
                "type": "AUTHENTICATION",
                "authentication": {
                    "requirementsCombination": {{requirementsCombination}},
                    "result":{
                        "result":"SUCCESS"
                    },
                    "resultsMap": {
                        "{{requirementId}}": {
                            "result": "SUCCESS"
                        }
                    },
                    "completedTimestamp": {{currentTime}}
                }
            }
        ],
        "authenticator": "UNP",
        "language": "en"
    }
}


The result should be (Example):

{"applicationArea":{"senderId":"IB","countryOfOrigin":"AE","transactionDateTime":"2024-XX-XXT10:49:43.043Z","transactionId":"txn-50fe9045-6ffa-4d9f-b182-8b938a4ef2bb"},"dataArea":{"phoneNumber":"0XXXXX1580","referenceDate":"2024-XX-XX 10:49:43.911","customerIdentifier":"7b73e457af6bb6c46ecced0f5XXX88ed"}}


NOTE:

This has been tested on the IB Login Journey within the Callsign Environment. This must be tested within the on-prem solution within the FAB environment before applying the change to PROD. 

It is strongly recommended to setup the FAB UAT or FAB Non-PROD environment with the same Initial POST ETG call and Update PUT ETG API calls with the same configurations and codebase as per the PROD environment. This should also include a working Sim Swap Service.  

////////////////////
public ETGTransactionRequest getEtgRequest(CsTransactionRequest csTransactionRequest, ContextTypeEnum contextType) {
		ETGTransactionRequest etgRequest = new ETGTransactionRequest();
		if (Objects.isNull(csTransactionRequest) || (StringUtils.isBlank(csTransactionRequest.getCsTransactionId())
						|| Objects.isNull(csTransactionRequest.getCsTransactionType()))) {
			log.debug("Invalid request for CS Transaction");
			throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
		}

		etgRequest.setTransactionId(csTransactionRequest.getCsTransactionId());
		etgRequest.setOldTransactionId(csTransactionRequest.getCsOldTransactionId());
		etgRequest.setTransactionType(csTransactionRequest.getCsTransactionType());
		etgRequest.setAuthenticator(csTransactionRequest.getAuthenticator());
		SessionInfo session = SessionContext.getSession();
		etgRequest.setSessionId(session.getSessionID());
		String refId = HashUtil.getPseudoCinHash(session.getUser().getCif());
		etgRequest.setUserName(refId);
		etgRequest
				.setLanguage(StringUtils.isBlank(localeHelper.resolveLanguage()) ? AppConstants.LOCALE_EN.toLowerCase()
						: localeHelper.resolveLanguage().toLowerCase());

		etgRequest.addContext(getEtgAuthnticationContext(csTransactionRequest, contextType));
		etgRequest.addContext(getEtgTransactionContext(csTransactionRequest));

		log.debug("Add additional Context with user details.");
		etgRequest.addContext(getUserContext(refId));
		return etgRequest;
	}

	/**
	 * 
	 * @param session
	 * @return context
	 */
	private Context getUserContext(String refId) {
		log.info("CsTransactionHelper.getUserContext.start");
		Context context = new Context();
		context.setSource(ContextSourceEnum.DECISION_REQUEST);
		context.setType(ContextTypeEnum.USER);

		UserIdentity userIdentity = new UserIdentity();
		userIdentity.setExternalUniqueId(refId);
		userIdentity.setTimestamp(System.currentTimeMillis());
		Map<String, String> additionalAttributes = new HashMap<>();
		additionalAttributes.put(AppConstants.ATTRIBUTE_DEVICE_ID, SessionContext.getSession().getUniqueDeviceId());
		userIdentity.setAdditionalAttributes(additionalAttributes);
		context.setUser(userIdentity);
		return context;
	}

	/**
	 * Transaction status for additional transaction information for Mobile and
	 * internet banking lock.
	 * 
	 * @return
	 */
	private Context getEtgTransactionContext(CsTransactionRequest csTransactionRequest) {
		SessionInfo session = SessionContext.getSession();
		Context context = new Context();
		context.setType(ContextTypeEnum.TRANSACTION);
		Transaction transaction = new Transaction();
		Map<String, String> additionalTransactionInformation = new HashMap<>();
		if (session.getChannelType() == ChannelType.BROWSER) {
			if((settingsRepository.isIBDependentOnMobile() && callsignAuthHelper.isCallsignEnabledCust(session, ChannelType.BROWSER))
					|| callsignAuthHelper.isCallsignEnabledCustWithDeviceCount(session, ChannelType.BROWSER)){
				additionalTransactionInformation.put(AppConstants.IB_AUTH_TYPE, AppConstants.IB_AUTH_MOBILE);
				ChannelInfo channelInfo = channelInfoRepository.fetchChannelInfoByChannelUserId(ChannelType.MOBILE.name(),
						session.getUser().getCif());
				boolean isChannelActive = Objects.nonNull(channelInfo) && StringUtils.isNotBlank(channelInfo.getStatus())
						&& AppConstants.ACTIVE.equals(channelInfo.getStatus());
				boolean isMobileLockOrBlocked = Objects.isNull(channelInfo) ? true
						: (TextUtils.INSTANCE.getBoolean(channelInfo.getIsLocked())
								|| TextUtils.INSTANCE.getBoolean(channelInfo.getIsBlocked()));
				additionalTransactionInformation.put(AppConstants.MOBILE_BANKING_LOCK, !isChannelActive ? AppConstants.TRUE
						: isMobileLockOrBlocked ? AppConstants.TRUE : AppConstants.FALSE);
			}else{
				additionalTransactionInformation.put(AppConstants.IB_AUTH_TYPE, AppConstants.IB_AUTH_OTP);
				additionalTransactionInformation.put(AppConstants.MOBILE_BANKING_LOCK, AppConstants.FALSE);
			}
			
			if(csTransactionRequest.getCsTransactionType() == CsTransactionType.PASSWORD_RESET) { 
				log.info("overriding the forget password flow to OTP based on FMDB-94354");
				additionalTransactionInformation.put(AppConstants.IB_AUTH_TYPE, AppConstants.IB_AUTH_OTP);
			}
			
			additionalTransactionInformation.put(AppConstants.INTERNET_BANKING_LOCK, AppConstants.FALSE);
		} else {
			additionalTransactionInformation.put(AppConstants.MOBILE_BANKING_LOCK, AppConstants.FALSE);
		}

		String authMessageEn = getDynamicAuthMessage(csTransactionRequest, AppConstants.AUTH_MESSAGE_EN);
		String authMessageAr = getDynamicAuthMessage(csTransactionRequest, AppConstants.AUTH_MESSAGE_AR);
		additionalTransactionInformation.put(AppConstants.AUTH_MESSAGE_EN, authMessageEn);
		additionalTransactionInformation.put(AppConstants.AUTH_MESSAGE_AR, authMessageAr);

		if (Objects.nonNull(csTransactionRequest.getRiskSeverity())) {
			additionalTransactionInformation.put(AppConstants.CS_TRANSACTION_RISK_CHECKER,
					csTransactionRequest.getRiskSeverity().getCode());
		}
		// additionalTransactionInformation.put("transactionDateTime" ,
		// FABUtils.INSTANCE.get);
		// RBA Code with extra details in the context.
		additionalTransactionInformation.put(AppConstants.TRANSACTION_DATE_TIME, determineTransactionDateTime());
		if (isLoginRregistratin(csTransactionRequest)) {
			// Call the new method and get the details and set in the map.
			setRBAUserDetails(session, additionalTransactionInformation);
		}
		if (csTransactionRequest.getCsTransactionType() == CsTransactionType.MB_REGISTRATION) {
			deviceNearMeNLiveness(csTransactionRequest, session, additionalTransactionInformation);
			// deviceAppCenterName = "HUAWEI" / "iPhone" / "Android"
			// additionalTransactionInformation.put("deviceAppCenterName" ,
			// FABUtils.INSTANCE.get);
			// additionalTransactionInformation.put(AppConstants.DEVICE_APP_CENTER_NAME,
			// deviceTypeChecker.generateDeviceAppCenterName());
			additionalTransactionInformation.put(AppConstants.DEVICE_APP_CENTER_NAME, typeChecker.determineDeviceAppCenterName());

		}
		transaction.setAdditionalTransactionInformation(additionalTransactionInformation);
		context.setTransaction(transaction);

		return context;
	}

	private String determineTransactionDateTime() {
		Date date = new Date();
		StringBuilder builder = new StringBuilder();
		builder.append(DateTimeHelper.INSTANCE.formatDate(date, DATE_YYYMMDD));
		builder.append("T");
		builder.append(DateTimeHelper.INSTANCE.formatDate(date, TIME_HHMMSSSSS));
		builder.append("Z");
		return builder.toString();
	}
==============================================
/**
	 * Initiate ETG transaction with Callsign.
	 * 
	 * @param transactionID
	 * @return cstran CsInitiateTransactionResponse
	 */
	public CsTransactionResponse initiateTransaction(CsTransactionRequest csTransactionRequest) {
		CsTransactionResponse csTransactionResponse = new CsTransactionResponse();
		return execute(csTransactionRequest, csTransactionResponse, req ->  {
			
			if (csTransactionRequest.getCsTransactionType() == CsTransactionType.LOGIN
					|| csTransactionRequest.getCsTransactionType() == CsTransactionType.LOGIN_V2
					|| csTransactionRequest.getCsTransactionType() == CsTransactionType.PIN_RESET)
				checkTrottle();
			
			SessionInfo session = SessionContext.getSession();
			User user = session.getUser();
			String cif = user.getCif();
			String convID = session.getConvID();
			String deviceID = session.getDeviceID();
			
			ChannelType channelType = session.getChannelType();	
			
			ChannelInfo channelInfo = channelInfoRepository.fetchChannelInfoByChannelUserId(channelType.name(), cif);
			channelValidator.validateChannelInfoForCs(channelInfo, channelType, csTransactionRequest);
						
			if(csTransactionRequest.getCsTransactionType() == CsTransactionType.IB_REGISTRATION
					|| csTransactionRequest.getCsTransactionType() == CsTransactionType.MB_REGISTRATION) 
			removeUserCacheDuringRegistration();
			
			if(csTransactionRequest.getCsTransactionType() == CsTransactionType.PIN_RESET_OTP || csTransactionRequest.getCsTransactionType() ==CsTransactionType.PIN_RESET
					|| csTransactionRequest.getCsTransactionType().equals(CsTransactionType.PASSWORD_RESET)) {		
				/** reset OTP authenticator **/
				csAuthenticatorSF.cleanUserDeviceAndAuthenticators(false);
			}
			
			ETGTransactionRequest etgRequest = csTransactionHelper.getEtgRequest(csTransactionRequest, ContextTypeEnum.AUTHENTICATION);
			log.debug("ETG Request {}", etgRequest);
			ETGTransactionResponse etgResponse = null;
			/*if(session.getChannelType() == ChannelType.BROWSER) {
				etgResponse = csTransactionHelper.mockEtgResponse(csTransactionRequest, false, false);
			} else {*/
				etgResponse = csTransactionServiceInvoker.initiateTransaction(etgRequest); // csTransactionHelper.mockEtgResponse(csTransactionRequest, false, false);
				//}
			transactionAudit.saveTransactionAuditInfo(prepareAudtiAttributes(csTransactionRequest,etgResponse , "INITIATE-TRANSACTION"));
			log.debug("ETG response {}", etgResponse);
			if(etgResponse.getResult() == ResultEnum.DENIED  || etgResponse.getResult() == ResultEnum.FAILED) {
				captureLoginFailure(csTransactionRequest, cif, deviceID, channelType);
				String message = etgResponse.getMessage();
				log.error("CsTransactionSF - message : {}", message);
				csTransactionResponse.setEtgTransactionResponse(etgResponse);
				if (StringUtils.isNotBlank(message)
						&& (message.equals(AppConstants.REG_MOBILE_CHANNEL_LOCKED)
								|| message.equals(AppConstants.RESET_MOBILE_CHANNEL_LOCKED)
								|| message.equals(AppConstants.LOGIN_MOBILE_CHANNEL_LOCKED))) {
					csTransactionHelper.processErrorBasedOnMessage(message);
				} else {
					throw new AppException(ErrorCodes.CS_TRANSACTION_INITIATE_FAILED);
				}
			} else if(etgResponse.getDecision() == DecisionEnum.DENY) {
				captureLoginFailure(csTransactionRequest, cif, deviceID, channelType);
				throw new AppException(ErrorCodes.CS_TRANSACTION_INITIATE_FAILED);
			} else if(etgResponse.getDecision() == DecisionEnum.ALLOW) {
				//Update the Session to verified.
				sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
				csTransactionResponse.setEtgTransactionResponse(etgResponse);
			} else if(etgResponse.getDecision() == DecisionEnum.REFER) {
				Long csTxnActiveTimeout = settingsRepository.getCsTxnActiveTimeout();
				int csTxnActiveIncorrectAttempts = settingsRepository.getCsTxnActiveIncorrectAttempts();
				int csTxnActiveMaxAttempts = settingsRepository.getCsTxnActiveMaxAttempts();
				csTransactionResponse.setEtgTransactionResponse(etgResponse);
				sendOTPRUnpAuthnticator(csTransactionResponse, session, user, csTransactionRequest, etgResponse);
				
				csTransactionResponse.setCsTxnActiveAllowedAttempts(csTxnActiveIncorrectAttempts);
				csTransactionResponse.setCsTxnActiveMaxResendAttempts(csTxnActiveMaxAttempts);
				csTransactionResponse.setCsTxnActiveTimeInSeconds(csTxnActiveTimeout);
			}
			mapNameNResponse(csTransactionResponse, cif, user, channelType);
			
			return csTransactionResponse;
		});
	}

/////////////////////
/**
	 * Migrate already registered user to callsign.
	 * 1. Create User in callsign.
	 * 2. initiate transaction with MPIN Authenticator.
	 * 
	 * @param transactionID
	 * @return cstran CsInitiateTransactionResponse
	 */
	public CsTransactionResponse migrateCustomer(CsTransactionRequest csTransactionRequest) {
		CsTransactionResponse csTransactionResponse = new CsTransactionResponse();
		return execute(csTransactionRequest, csTransactionResponse, req ->  {
			SessionInfo session = SessionContext.getSession();
			User user = session.getUser();
			String cif = user.getCif();
			ChannelType channelType = session.getChannelType();
			
			ChannelInfo channelInfo = channelInfoRepository.fetchChannelInfoByChannelUserId(channelType.name(), cif);
			channelValidator.validateChannelInfoForCs(channelInfo, channelType, csTransactionRequest);
			
			/**
			 * Create user in scim
			 */
			String refId = updateReferenceId(user, channelInfo);
			APIResponse createUserRes = csUserManagementSF.createUser(refId);
			
			if(!createUserRes.getResult().isSuccess()) {
				throw new AppException(ErrorCodes.CS_CREATE_USER_FAILED);
			}
			
			ETGTransactionRequest etgRequest = csTransactionHelper.getEtgRequest(csTransactionRequest, ContextTypeEnum.AUTHENTICATOR);
			
			ETGTransactionResponse etgResponse = csTransactionServiceInvoker.initiateTransaction(etgRequest);

			transactionAudit.saveTransactionAuditInfo(prepareAudtiAttributes(csTransactionRequest,etgResponse,  "MPIN-MIGRATE"));
			
			if(etgResponse.getResult() == ResultEnum.DENIED  || etgResponse.getResult() == ResultEnum.FAILED) {
				throw new AppException(ErrorCodes.CS_TRANSACTION_INITIATE_FAILED);
			} else if(etgResponse.getDecision() == DecisionEnum.DENY) {
				throw new AppException(ErrorCodes.CS_TRANSACTION_INITIATE_FAILED);
			}
			Long csTxnActiveTimeout = settingsRepository.getCsTxnActiveTimeout();
			int csTxnActiveIncorrectAttempts = settingsRepository.getCsTxnActiveIncorrectAttempts();
			int csTxnActiveMaxAttempts = settingsRepository.getCsTxnActiveMaxAttempts();
			
			csTransactionResponse.setCsTxnActiveAllowedAttempts(csTxnActiveIncorrectAttempts);
			csTransactionResponse.setCsTxnActiveMaxResendAttempts(csTxnActiveMaxAttempts);
			csTransactionResponse.setCsTxnActiveTimeInSeconds(csTxnActiveTimeout);
			csTransactionResponse.setEtgTransactionResponse(etgResponse);
			
			mapNameNResponse(csTransactionResponse, cif, user, channelType);
			return csTransactionResponse;
		});
	}
/////////////////////////////////////
/**
	 * Reinitiate ETG transaction with Callsign.
	 * Cancel and Initiate new transaction.
	 * 
	 * @param transactionID
	 * @return
	 */
	public CsTransactionResponse reInitiateTransaction(CsTransactionRequest csTransactionRequest) {
		log.debug("CsTransactionSF.reInitiateTransaction.Start {} ",csTransactionRequest);
		CsTransactionResponse csTransactionResponse = new CsTransactionResponse();
		return execute(csTransactionRequest, csTransactionResponse, req ->  {
			
			SessionInfo session = SessionContext.getSession();
			String cif = session.getUser().getCif();
			String convID = session.getConvID();
			String deviceID = session.getDeviceID();
			User user = session.getUser();
			ChannelType channelType = session.getChannelType();
			
			ErrorCodes error = csTransactionRequest.getCsTransactionType() == CsTransactionType.TRANSACTION_RISK_CHECKER 
					? ErrorCodes.CS_RISK_TRANSACTION_INITIATE_FAILED : ErrorCodes.CS_TRANSACTION_INITIATE_FAILED;
			
			ChannelInfo channelInfo = channelInfoRepository.fetchChannelInfoByChannelUserId(channelType.name(), cif);
			channelValidator.validateChannelInfoForCs(channelInfo, channelType, csTransactionRequest);
					
			
			if(csTransactionRequest.getCsTransactionType() == CsTransactionType.IB_REGISTRATION
					|| csTransactionRequest.getCsTransactionType() == CsTransactionType.MB_REGISTRATION) 
			removeUserCacheDuringRegistration();
			
			/*
			|| ( StringUtils.isNotBlank(csTransactionRequest.getCsTransactionId())
					&& StringUtils.isNotBlank(csTransactionRequest.getCsOldTransactionId()) 
					&& csTransactionRequest.getCsOldTransactionId().equals(csTransactionRequest.getCsTransactionId()) )
			*/
			
			if(StringUtils.isBlank(csTransactionRequest.getCsOldTransactionId()) || StringUtils.isBlank(csTransactionRequest.getCsTransactionId())) {
				throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
			}
			ETGTransactionResponse etgResponse = null;
			if(csTransactionRequest.getCsTransactionType() == CsTransactionType.MB_REGISTRATION) {
				//change to old transaction id
				csTransactionServiceInvoker.cancelTransaction(csTransactionRequest.getCsOldTransactionId());
				
				csUserManagementSF.createUser(channelInfo.getReferenceId());
				ETGTransactionRequest etgRequest = csTransactionHelper.getEtgRequest(csTransactionRequest, ContextTypeEnum.AUTHENTICATION);
				log.debug("CsTransactionSF.reInitiateTransaction.ETGTransactionRequest {}",etgRequest);
				
				etgResponse = csTransactionServiceInvoker.initiateTransaction(etgRequest);
			} else {
				ETGTransactionRequest etgRequest = csTransactionHelper.getEtgRequest(csTransactionRequest, ContextTypeEnum.AUTHENTICATION);
				log.debug("CsTransactionSF.reInitiateTransaction.ETGTransactionRequest {}",etgRequest);
				
				/*if(session.getChannelType() == ChannelType.BROWSER) {
					etgResponse = csTransactionHelper.mockEtgResponse(csTransactionRequest, false, false); 
				} else {*/
					etgResponse = csTransactionServiceInvoker.reInitiateTransaction(etgRequest); //csTransactionHelper.mockEtgResponse(csTransactionRequest, false, false); 
				//}
			}
			
			transactionAudit.saveTransactionAuditInfo(prepareAudtiAttributes(csTransactionRequest,etgResponse, "RE-INITIATE-TRANSACTION"));
			log.debug("CsTransactionSF.reInitiateTransaction.ETGTransactionResponse {}",etgResponse);
			if(etgResponse.getResult() == ResultEnum.DENIED  || etgResponse.getResult() == ResultEnum.FAILED) {
				captureLoginFailure(csTransactionRequest, cif, deviceID, channelType);
				throw new AppException(error);
			} else if(etgResponse.getDecision() == DecisionEnum.DENY) {
				captureLoginFailure(csTransactionRequest, cif, deviceID, channelType);
				throw new AppException(error);
			} else if(etgResponse.getDecision() == DecisionEnum.ALLOW) {
				//Update the Session to verified.
				sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
				csTransactionResponse.setEtgTransactionResponse(etgResponse);
			} else if(etgResponse.getDecision() == DecisionEnum.REFER) {
				// Wrap in resendOTP method, take verifycustomersf.verifyEmiratesIDForRegistration as reference.
				// check the authenticator == AuthenticatorClassEnum.OTP_INTERNAL_GEN_EXTERNAL_DELIVER
				// extract OTP and send otp
				// update ETG with success.
				log.debug("CsTransactionSF.reInitiateTransaction.ETGTransactionResponse :REFER {}");

				csTransactionResponse.setEtgTransactionResponse(etgResponse);
				sendOTPRUnpAuthnticator(csTransactionResponse, session, user, csTransactionRequest, etgResponse);

				Long csTxnActiveTimeout = settingsRepository.getCsTxnActiveTimeout();
				csTransactionResponse.setCsTxnActiveTimeInSeconds(csTxnActiveTimeout);
				csTransactionResponse.getEtgTransactionResponse().clearPIIData();
			}
			mapNameNResponse(csTransactionResponse, cif, user, channelType);
			return csTransactionResponse;
		});
	}

////////////////////////////////////////////
	/**
	 * Update ETG transaction with Callsign.
	 * 
	 * @param transactionID
	 * @return cstran CsInitiateTransactionResponse
	 */
	public CsTransactionResponse updateTransaction(CsTransactionRequest csTransactionRequest) {
		CsTransactionResponse csTransactionResponse = new CsTransactionResponse();
		return execute(csTransactionRequest, csTransactionResponse, req ->  {
			
			SessionInfo session = SessionContext.getSession();
			String cif = session.getUserId();
			String convID = session.getConvID();
			String deviceID = session.getDeviceID();
			User user = session.getUser();
			ChannelType channelType = session.getChannelType();
			
			ETGTransactionRequest etgRequest = csTransactionHelper.getEtgRequest(csTransactionRequest, ContextTypeEnum.AUTHENTICATION);
			log.debug("ETG Request {}", etgRequest);
			ETGTransactionResponse etgResponse = null;
			/*if(session.getChannelType() == ChannelType.BROWSER) {
				etgResponse =  csTransactionHelper.mockEtgResponse(csTransactionRequest, false, true);
			} else {*/
				etgResponse =  csTransactionServiceInvoker.updateTransaction(etgRequest); //csTransactionHelper.mockEtgResponse(csTransactionRequest, false, true);
			//}
			transactionAudit.saveTransactionAuditInfo(prepareAudtiAttributes(csTransactionRequest,etgResponse, "UPDATE-TRANSACTION"));
				
			if(etgResponse.getResult() == ResultEnum.DENIED  || etgResponse.getResult() == ResultEnum.FAILED) {
				setErrorMessage(csTransactionRequest);
				captureLoginFailure(csTransactionRequest, cif, deviceID, channelType);
			} else if(etgResponse.getDecision() == DecisionEnum.DENY) {
				setErrorMessage(csTransactionRequest);
				captureLoginFailure(csTransactionRequest, cif, deviceID, channelType);
			} else if(etgResponse.getDecision() == DecisionEnum.REFER && Objects.nonNull(etgResponse.getRequirementId())
					&& Objects.nonNull(etgResponse.getResultsMap().get(etgResponse.getRequirementId()))
					&& Objects.nonNull(etgResponse.getResultsMap().get(etgResponse.getRequirementId()).getResponse())) {
				sendOTPRUnpAuthnticator(csTransactionResponse, session, user, csTransactionRequest, etgResponse);
			}
			
			csTransactionResponse.setEtgTransactionResponse(etgResponse);
			return csTransactionResponse;
		});
	}

===============================================

-------------------------------
Title: Detailed fetchAlertHistory Method Flow with updateLastAccessAlertCenter and Table Interaction

Caller->fetchAlertHistory: Invoke fetchAlertHistory()
fetchAlertHistory->SessionContext: getUser()
SessionContext-->fetchAlertHistory: User
alt User's Mobile Number is Available
    fetchAlertHistory->ciRepository.getAlertHistory: Invoke getAlertHistory(mobileNo, email)
    ciRepository.getAlertHistory->Database: Execute GET_ALERT_HISTORY query
    Database-->ciRepository.getAlertHistory: ResultSet (rs)
    loop Process each row in ResultSet
        ciRepository.getAlertHistory->ciRepository.getAlertHistory: Create AlertDetail object
    end
    ciRepository.getAlertHistory-->fetchAlertHistory: List<AlertDetail>
else
    fetchAlertHistory->fetchAlertHistoryResponse: Initialize Empty Alert List
end
fetchAlertHistory->fetchAlertHistoryResponse: setAlertHistory(alertDtls)
alt Alert Details Not Empty
    fetchAlertHistory->fetchAlertHistoryResponse: Get First AlertDetail
    fetchAlertHistory->SessionContext: getChannelType()
    SessionContext-->fetchAlertHistory: ChannelType
    alt ChannelType is BROWSER
        fetchAlertHistory->userChannelRepository.updateLastAccessAlertCenter: Update Last Access Alert (cif, channelType, alertDetail.getIdMessage())
        userChannelRepository.updateLastAccessAlertCenter->execute: Prepare Statement for USR_CHNL_IB_LASTACCESS_ALERTCENTER
        execute->PreparedStatement: ps.setString(1, idMessage)
        execute->PreparedStatement: ps.setString(2, cif)
        execute->PreparedStatement: ps.setString(3, channelID)
        execute->Database: Execute Update Query on user_channel table
        Database-->execute: Success
        execute-->userChannelRepository.updateLastAccessAlertCenter: Success
    end
end
fetchAlertHistory->Caller: Return fetchAlertHistoryResponse


@SuppressWarnings({ "unchecked", "rawtypes" })
	public List<AlertDetail> getAlertHistory(String mobileNo, String email) {
		return (List) executeQueryForList(CIQueryConstants.GET_ALERT_HISTORY, ps -> {
			ps.setString(1, mobileNo);
			ps.setString(2, email);
			ps.setInt(3, MAX_ROW);
		} , rs -> {
			AlertDetail alertDetail = new AlertDetail();
			int i = 0;
			alertDetail.setDate(rs.getString(++i));
			alertDetail.setAlertType(rs.getString(++i));
			alertDetail.setAddress(rs.getString(++i));
			alertDetail.setAlertMessage(rs.getString(++i));
			alertDetail.setIdMessage(rs.getString(++i));
			return alertDetail;
		});
	}



String GET_ALERT_HISTORY = "SELECT to_char(datcreated) AS vdate, idnotifier, address, message, idmessage  FROM alert_esb_queue where address in (?,?) AND idalert IN ('IBMB_PROFILE_ALERT','IBMB_NOTIFICATION_ALERT') AND ROWNUM <= ? ORDER BY datcreated DESC";

public Integer updateLastAccessAlertCenter(final String cif, final String channelID, final String idMessage) {
		return execute(USR_CHNL_IB_LASTACCESS_ALERTCENTER, ps->{
			int i = 1;
			ps.setString(i, idMessage);
			ps.setString(++i, cif);		
			ps.setString(++i, channelID);
		});
	
	}

private static final String USR_CHNL_IB_LASTACCESS_ALERTCENTER = "UPDATE user_channel SET last_access_alertCenter = ? WHERE cif=? AND channel_id=?";

public FetchAlertHistoryResponse fetchAlertHistory() {
		FetchAlertHistoryResponse apiResponse = new FetchAlertHistoryResponse();
		return execute(null, apiResponse, req -> {
			User user = SessionContext.getSession().getUser();
			log.info("fetchAlertHistory for user:{}", user);
			FetchAlertHistoryResponse fetchAlertHistoryResponse = new FetchAlertHistoryResponse();
			List<AlertDetail> alertDtls = null;
			AlertDetail alertDetail = null;

			if (StringUtils.isNotBlank(user.getMobileNo())) {
				alertDtls = ciRepository.getAlertHistory(user.getMobileNo(),
						(user.getEmail() == null ? AppConstants.NA : user.getEmail()));
			} else {
				alertDtls = new ArrayList<AlertDetail>();
			}

			fetchAlertHistoryResponse.setAlertHistory(alertDtls);
			// PBG-199 Update lastAccess_alertCenter in user channel
			if (Objects.nonNull(alertDtls) && !alertDtls.isEmpty()) {
				alertDetail = alertDtls.get(0);
				log.info("inside alert details - {}", alertDetail.getIdMessage());
			}
			String cif = user.getCif();
			ChannelType channelType = SessionContext.getSession().getChannelType();
			if (ChannelType.BROWSER == channelType && Objects.nonNull(alertDetail)) {
				log.info("in alert history to update last alert access for cif:{} and channelType:{}", cif,
						channelType.name());
				userChannelRepository.updateLastAccessAlertCenter(cif, channelType.name(), alertDetail.getIdMessage());
				log.info("Last access for alerts has been updated in user channel");
			}
			return fetchAlertHistoryResponse;
		});
	}

Prerequisite

‘Within UAE’ (IPP, IPI) and ‘Within FAB’ transfers initiated via FAB Mobile/Online banking post successful implementation of this feature.

Acceptance Criteria:

Case 1 Post successful ‘Within FAB’ transfers, FAB Mobile /Online banking trigger email notification to customer with transfer advice as an attachment.

Case 2 Post successful ‘Within UAE’ (IPP, IPI) transfers, FAB Mobile /Online banking trigger email notification to customer with transfer advice as an attachment.

Case 3 Customer can access the transfer advice for ‘Within UAE’ (IPP, IPI) and ‘Within FAB’ via email notifications.

Case 4 Transfer advice sent to customer's registered email address will be password protected file. We will use the same encryption maintained for account eStatement / stamped statement in production to open the file. (Last 4 digits of the account followed by the 4 digits representing the day and month of birthday)

New E-mail content: To be finalized (pending with business)

Attachment Name:

i) WithinUAE_TransferAdvice [In case if transfer initiated is Within UAE]

ii) WithinFAB_TransferAdvice [In case if transfer initiated is Within FAB]

Attachments

/**
	 * Method for Generate the Iban letter
	 * 
	 * @param an instance of {@link IBANGeneratorReqeust}
	 * @return {@link String}
	 */
	public IBANGeneratorResponse generateIban(final IBANGeneratorReqeust ibanGeneratorReqeust) {

		log.info("LetterSF::generateIban()");
		
		IBANGeneratorResponse apiResponse = new IBANGeneratorResponse();
		IBANAuditRequest ibanAuditRequest = new IBANAuditRequest();
		String customerName = getCustomerName(ibanGeneratorReqeust.getSourceAccount());
		SessionInfo sessionInfo = SessionContext.getSession();
		ibanAuditRequest.setCin(sessionInfo.getUser().getCin());
		ibanAuditRequest.setCif(sessionInfo.getUser().getCif());
		ibanAuditRequest.setCustomerName(customerName);
		
		return execute(ibanGeneratorReqeust, apiResponse, request -> {
			if (isValidIbanRequest(request)) {
				DocumentRequest documentRequest = new DocumentRequest();
				
				// Validate if transaction is authenticated by callsign or not.
				AuthData authResponse = authenticationSF.verifyAuthKey(request);
				if(authResponse.getResult().isSuccess()) {
					documentRequest.setContentItemExchange(contentItemExchangeBuilder(request.getSourceAccount()));
					documentRequest.setDataFields(dataFieldMapper(request, customerName));
					documentRequest.setFileName("IBAN_LETTER_"+ibanGeneratorReqeust.getSourceAccount().substring(ibanGeneratorReqeust.getSourceAccount().length()-4));
					boolean sitFlag = StringUtils.equals(sessionInfo.getEnvironment(), AppConstants.SIT);
					String result =  ibmbMSServiceInvoker.invokePost(documentRequest, sitFlag?ServiceURLs.DOCUMENT_GENERATE_SIT:ServiceURLs.DOCUMENT_GENERATE);
					if (StringUtils.isNotBlank(result)) {
						IBANFileAttachment attachment =JsonUtils.convertToObject(IBANFileAttachment.class, result);
						apiResponse.setFileAttachment(attachment);
						ibanAuditRequest.setStatus(AppConstants.SUCCESS);
						publishIBANEvent(ibanAuditRequest);
						recordIBANAuditDetails(ibanAuditRequest);
						return apiResponse;
					} else {
						ibanAuditRequest.setStatus(AppConstants.FAILURE);
						publishIBANEvent(ibanAuditRequest);
						recordIBANAuditDetails(ibanAuditRequest);
						throw new AppException(ErrorCodes.SYS_TECHNICAL_ERROR);
					}
				}
				ibanAuditRequest.setStatus(AppConstants.FAILURE);
				apiResponse.setResult(authResponse.getResult());
				publishIBANEvent(ibanAuditRequest);
				recordIBANAuditDetails(ibanAuditRequest);
				return apiResponse;
			} else {
				log.info("IBANGeneratorReqeust is not valid");
				ibanAuditRequest.setStatus(AppConstants.FAILURE);
				publishIBANEvent(ibanAuditRequest);
				recordIBANAuditDetails(ibanAuditRequest);
				throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
			}
		});
	}


public APIResponse executeTransfer(final ExecuteTransferRequest transferRequest) {
		APIResponse apiResponse = new APIResponse();
		return execute(transferRequest, apiResponse, req -> {
			EdirhamCardDetailAPIResponse edirhamCardDetails = null;
			if(StringUtils.isBlank(transferRequest.getTxnRef()) || 
					(StringUtils.isNotBlank(transferRequest.getTransferDescription())&&!transferRequest.getTransferDescription().matches(AppConstants.ALPHANUMERIC_SPACES_DOT_COLON_BRACKETS_HYPHEN_COMMA_PLUS))){
				throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
			}
			
			//In case of back dated transfer, we are overriding that back date to current date.
			if((!StringUtils.isBlank(transferRequest.getTransferDate()) 
					&& DateTimeHelper.INSTANCE.isDatelessThenCurrentDate(transferRequest.getTransferDate(), AppConstants.DATE_DDMMYYYY))){
				transferRequest.setTransferDate(DateTimeHelper.INSTANCE.formatDate(new Date(), AppConstants.DATE_DDMMYYYY));
			} 
			if(transferRequest.getAutopay()!=null && !StringUtils.isBlank(transferRequest.getAutopay().getStartDate())
					&& DateTimeHelper.INSTANCE.isDatelessThenCurrentDate(transferRequest.getAutopay().getStartDate(), AppConstants.DATE_DDMMYYYY)){
				transferRequest.getAutopay().setStartDate(DateTimeHelper.INSTANCE.formatDate(new Date(), AppConstants.DATE_DDMMYYYY));
			}
			
			if(transferRequest.getAmount() < 1){ //if(transferRequest.getAmount() <= 0){ 
				// do not ALLOW such request
				throw new AppException(ErrorCodes.MINIMUM_AMOUNT);
			}else if(FundTransferTypes.INTERNATIONAL_FUNDS_TRANSFER == transferRequest.getFundTransferType()) {
				if(Objects.nonNull(transferRequest.getBeneficiary()) && AppConstants.LOCAL_CURRENCY.equals(transferRequest.getBeneficiary().getCurrency())) {
					throw new AppException(ErrorCodes.AED_CURRENCY_NOT_ALLOWED_INTERNAIONAL_TRANSFER);
				}
			}
			List<Product> debitSources = getFundingSources(transferRequest);
			if (Objects.nonNull(debitSources) && debitSources.stream().noneMatch(
					product -> product.getProdRef().equals(transferRequest.getSourceProductRef()))) {
				log.info("Fund Transfer not allowed for Debit Act: {}", transferRequest.getSourceProductRef());
				apiResponse.setError(ErrorCodes.SYS_INVALID_REQUEST);
				return apiResponse;
			}


			boolean bothAcctSame = isSourceNDestAccSame(transferRequest);
			if (bothAcctSame) {
				throw new AppException(ErrorCodes.SOURCE_DEST_ACCT_SAME);
			}
			if(transferRequest.getFundTransferType() == FundTransferTypes.EDIRHAM_TOPUP) {
				edirhamCardDetails = new EdirhamCardDetailAPIResponse();
				getEdirhamCardDetails(transferRequest,edirhamCardDetails);
			}
			checkLimit(transferRequest,edirhamCardDetails);
			/*
			 * if(!checkLimit(transferRequest)){
			 * apiResponse.setError(ErrorCodes.LIMIT_EXCEEDED); return
			 * apiResponse; }
			 */
			if (Objects.isNull(transferRequest.getAccountingUnitIdentifier())) {
				String accountUnitIdentifer = ciRepository.getAccountUnitIdentifier(transferRequest.getSourceProductRef());
				transferRequest.setAccountingUnitIdentifier(accountUnitIdentifer);
			}

			SessionInfo sessionInfo = SessionContext.getSession();
			AuthData authResponse = verify(transferRequest);

			if (authResponse.getResult().isSuccess()) {
				ExecutePaymentResponse paymentResponse = null;

				// Check payitaccount number before transaction	

				if (Objects.nonNull(transferRequest) && Objects.nonNull(transferRequest.getFundTransferType())
						&& transferRequest.getFundTransferType() == FundTransferTypes.PAYIT_WALLET_TOPUP) {
					String accNoOrCCNo = transferRequest.getBeneficiary().getRemitInfo();
					PayitLimitRequest payitLimitRequest = new PayitLimitRequest();
					payitLimitRequest.setMobileNumber(accNoOrCCNo);
					payitLimitRequest.setTransactionId(sessionInfo.getXref());
					PayItValidationResponse payItValidationResponse = payitServiceInvoker
							.fetchOtherCharge(payitLimitRequest);
					log.info("Validating payit accout number before making transaction account1:{} and account2:{}"
							, payItValidationResponse.getAccountDetails().getAccountNumber(), 
							transferRequest.getBeneficiary().getAcctOrCardNo());
					if (!payItValidationResponse.getAccountDetails().getAccountNumber()
							.equals(transferRequest.getBeneficiary().getAcctOrCardNo())) {
						log.info("Account is not correct");
						throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
					}

				}
				if (transferRequest.getFundTransferType() == FundTransferTypes.IPO_SUBSCRIPTION) {
					if(!customerSF.validateAccountBelongsToCif(transferRequest.getSourceProductRef())) {
						log.info("Account Number doesn't belongs to the logged in customer");
						throw new AppException(ErrorCodes.SYS_DEFAULT_ERROR);
					}
					
					List<IPODetails> ipoCompanies = ipoRepository.getIPOCompanies();
					IPODetails ipoCompany = ipoCompanies.stream()
							.filter(company -> company.getIpoId().equalsIgnoreCase(
									transferRequest.getIpoSubscribeDetails().getIpoDetails().getIpoId()))
							.findAny().orElse(null);
					if (Objects.nonNull(ipoCompany)) {
						transferRequest.getIpoSubscribeDetails().setIpoDetails(ipoCompany);
					}
					if ("AE0010007".equalsIgnoreCase(transferRequest.getAccountingUnitIdentifier()))
						transferRequest.setReceiverProductRef(
								transferRequest.getIpoSubscribeDetails().getIpoDetails().getIslCollectionAcc());
					else {
						transferRequest.setReceiverProductRef(
								transferRequest.getIpoSubscribeDetails().getIpoDetails().getConvCollectionAcc());
					}
					// adding investor details again in the request
					overideInvestorDeatils(transferRequest);
				}
				if (transferRequest.getFundTransferType() == FundTransferTypes.INSURANCE_PAYMENT) {
					if(Objects.nonNull(transferRequest.getSourceProductType()) && transferRequest.getSourceProductType() == ProductTypes.ACCOUNT 
							&& !customerSF.validateAccountBelongsToCif(transferRequest.getSourceProductRef())) {
						log.info("Account Number doesn't belongs to the logged in customer");
						throw new AppException(ErrorCodes.SYS_DEFAULT_ERROR);
					}
					InsuranceDetails details = transferRequest.getInsuranceDetails();

					InsuranceDbAuditResponse dbAuditResponse = insuranceAuditSF.getInsuranceDbAudit(details.getJourneyReferenceId(), 
							StringUtils.equals(SessionContext.getSession().getEnvironment(), AppConstants.SIT));
					
					double amount = Double.parseDouble(dbAuditResponse.getTotalPremium());
					log.info("Amount from api: {}",amount);
					log.info("Amount from request: {}",transferRequest.getAmount());
					if(amount != transferRequest.getAmount()) {
						throw new AppException(ErrorCodes.INSURANCE_PAYMENT_AMOUNT_MISMATCH);
					}
					FabSerialNoResponse response = insuranceSF.getFabSerialNo(details.getPlanType());
					log.info("Plan type for fab serial no. {}", details.getPlanType());
					if(response.getResult().getStatus().equals("success")) {
						details.setFabSerialNo(response.getSno());
					}else {
						throw new AppException(ErrorCodes.SYS_TECHNICAL_ERROR);
					}
					details.setCustomerSource(T24CompanyCodes.findByCompanyCode(transferRequest.getAccountingUnitIdentifier()).getDescription());
					transferRequest.setInsuranceDetails(details);
					String receiverRef = settingsRepository.getAppSettingValue(details.getBrandCode()).getValue();
					transferRequest.setReceiverProductRef(receiverRef);
					transferRequest.setAccountingUnitIdentifier(ciRepository.getAccountUnitIdentifier(receiverRef));
					
				}
				//PBG:1863 MCSEND INDIA Update bene details
				
				if(transferRequest.getFundTransferType() == FundTransferTypes.INSTANT_FUNDS_TRANSFER && Objects.nonNull(transferRequest.getIsReceiverNameUpdated()) &&
						transferRequest.getIsReceiverNameUpdated() && Objects.nonNull(transferRequest.getBeneficiary())) {
					log.debug("Inside Bene update");
					CreateUpdateBeneficiaryRequest updateBeneficiaryRequest = createAutopay(transferRequest, false, false);
					updateBeneficiaryRequest.setIsMcSendBeneDetailUpdate(true);
					updateBeneficiaryRequest.setAutopayEnabled(false);
					updateBeneficiaryRequest.setBeneId(transferRequest.getBeneficiary().getId());
					createUpdateBeneficiaryServiceInvoker.update(updateBeneficiaryRequest);
					log.debug("Bene update done");

				}
				

				// Check if transfer date is future date then create SI with onetime frequency
				overrideBeneficiaryObj(transferRequest, sessionInfo.getUserId());
				

				//PRM-686
				//For old version of mobile app's prior to version 1.0.11, 
				//beneficiary bank address wasn't mandatory due to which transaction was getting reversed for FAB remit transaction
				//Block requests if beneficiary bank address isn't passed
				if(transferRequest.getFundTransferType() == FundTransferTypes.BANK_TO_BANK_FUNDS_TRANSFER){
					//Modify paymentDescription to replace with default purpose code for FAB Remit
					transferRequest.setTransferDescription(AppConstants.DEFAULT_SWIFT_PURPOSE_CODE);

					if(StringUtils.isBlank(transferRequest.getBeneficiary().getBankAddress1()) 
							|| StringUtils.isBlank(transferRequest.getBeneficiary().getBankAddress2())){
						throw new AppException(ErrorCodes.BENE_ADDRESS_NA);
					}
				}

				String destinationCurrency = getTransferCurrency(transferRequest);

				//Rule validation for card as funding source.
				if(Objects.nonNull(transferRequest.getSourceProductType()) && transferRequest.getSourceProductType() == ProductTypes.CARD) {
					final CardFundingSourceRule cardRule = staticDataRepository.getCreditCardAsFundingSourceRule(req.getFundTransferType().name());
					if(Objects.nonNull(cardRule)) {
						//check the rules
						if(!isValidCardTransfer(transferRequest, destinationCurrency, cardRule)) {
							throw new AppException(ErrorCodes.OPERATION_NOT_ALLOWED);
						}
					}
				} else {
					/*final List<AccountFundingSourceRule> accountRuleList = staticDataRepository.getAccountAsFundingSourceRule(req.getFundTransferType().name());
					if(Objects.nonNull(accountRuleList)) {
						AccountFundingSourceRule aedAcctRule = accountRuleList.stream().filter(rule -> rule.getTransferCurrency().equals(transferRequest.getSourceCurrency())).findFirst().get();
						AccountFundingSourceRule fcyAcctRule = accountRuleList.stream().filter(rule -> !rule.getTransferCurrency().equals(transferRequest.getSourceCurrency())).findFirst().get();
						log.info("aedAcctRule : {}",aedAcctRule);
						log.info("fcyAcctRule : {}",fcyAcctRule);*/

					/*if(transferRequest.getSourceCurrency().equals(aedAcctRule.getTransferCurrency())) {
							if(!isValidAccountTransfer(transferRequest, destinationCurrency, aedAcctRule)) {
								throw new AppException(ErrorCodes.OPERATION_NOT_ALLOWED);
							}
							} else if(!isValidAccountTransfer(transferRequest, destinationCurrency, fcyAcctRule)) {
								throw new AppException(ErrorCodes.OPERATION_NOT_ALLOWED);
							}
						}*/
					//}

					//TODO: Account funding source rule to be applied.
					if(transferRequest.getFundTransferType() == FundTransferTypes.WITHIN_BANK_FUNDS_TRANSFER) {
						final String creditAccountNo = Objects.nonNull(transferRequest.getBeneficiary())
								? StringUtils.isNotBlank(transferRequest.getBeneficiary().getAcctOrCardNo()) ? transferRequest.getBeneficiary().getAcctOrCardNo() : transferRequest.getReceiverProductRef()
										: transferRequest.getReceiverProductRef();

								//	log.info("getReceiverProductType="+transferRequest.getReceiverProductType().name());

								//	log.info("ProductTypes_CARD="+ProductTypes.CARD.name());

								if(Objects.nonNull(transferRequest.getReceiverProductType()) && transferRequest.getReceiverProductType().name().equals(ProductTypes.CARD.name())) {
									//	log.info("Inside Card check");
									if(StringUtils.isNotBlank(creditAccountNo) && Pattern.matches(AppConstants.CARD_REGEX, creditAccountNo) 
											&& StringUtils.isNotBlank(transferRequest.getSourceCurrency()) && !transferRequest.getSourceCurrency().equals(LOCAL_CURRENCY)) {
										throw new AppException(ErrorCodes.NONAED_ACCT_TO_CARD); 
									}
								}
								/**	if(StringUtils.isNotBlank(creditAccountNo) && Pattern.matches(AppConstants.CARD_REGEX, creditAccountNo) 
								&& StringUtils.isNotBlank(transferRequest.getSourceCurrency()) && !transferRequest.getSourceCurrency().equals(LOCAL_CURRENCY)) {
							throw new AppException(ErrorCodes.NONAED_ACCT_TO_CARD); 
						}	**/
					}
				}
				//7510 Defect changes
				if(transferRequest.getFundTransferType() == FundTransferTypes.WITHIN_BANK_FUNDS_TRANSFER) {
					String creditAccountNo = Objects.nonNull(transferRequest.getBeneficiary())
							? StringUtils.isNotBlank(transferRequest.getBeneficiary().getAcctOrCardNo()) ? transferRequest.getBeneficiary().getAcctOrCardNo() : transferRequest.getReceiverProductRef()
									: transferRequest.getReceiverProductRef();
							AccountDetails prdDtls = ciRepository.fetchBeneficiaryProductDetail(creditAccountNo);

							if(Objects.nonNull(prdDtls) && StringUtils.isNotBlank(prdDtls.getCompany()) && T24CompanyCodes.ISB.name().equals(prdDtls.getCompany())) {
								throw new AppException(ErrorCodes.BENE_ISLAMIC_FAB_ACC);
							}
				}
				if(Objects.nonNull(transferRequest.getSourceProductType()) && transferRequest.getSourceProductType() == ProductTypes.ACCOUNT
						&& transferRequest.getFundTransferType() != FundTransferTypes.OWN_ACCT_FUNDS_TRANSFER) {
					AccountDetails prdDtls = ciRepository.fetchBeneficiaryProductDetail(transferRequest.getSourceProductRef());
					if(Objects.nonNull(prdDtls) && StringUtils.isNotBlank(prdDtls.getCompany()) && T24CompanyCodes.ISB.name().equals(prdDtls.getCompany())) {
						throw new AppException(ErrorCodes.BENE_ISLAMIC_FAB_ACC);
					}
				}

				// only for own account transfer, convert the card ref to cardnumber.
				if((transferRequest.getFundTransferType() == FundTransferTypes.OWN_ACCT_FUNDS_TRANSFER
						|| transferRequest.getFundTransferType() == FundTransferTypes.CARD_PAYMENT_BY_ACCOUNT)
						&& Objects.nonNull(transferRequest.getReceiverProductType()) &&
						transferRequest.getReceiverProductType().compareTo(ProductTypes.CARD) == 0) {
					transferRequest.setReceiverProductRef(TextUtils.INSTANCE.getCardNumber(transferRequest.getReceiverProductRef()));
				}

				if(transferRequest.getFundTransferType() == FundTransferTypes.WITHIN_UAE_FUNDS_TRANSFER) {
					boolean isCityofBirthPresent = Objects.nonNull(transferRequest.getCityOfBirth()) && StringUtils.isNotBlank(transferRequest.getCityOfBirth());
					log.info("isCityofBirthPresent : {}",isCityofBirthPresent);
					transferRequest.setIPIRequest(transferServicesHelper.isIpiTransfer(transferRequest.getAmount(), transferRequest.getBeneficiary().getAcctOrCardNo(), transferRequest.getTransferCurrency(), transferRequest.getFundTransferType()));
					//IPP Fundr transfer
					transferRequest.setIPPRequest(transferServicesHelper.isIppTransfer(transferRequest.getAmount(),
							transferRequest.getBeneficiary().getAcctOrCardNo(), transferRequest.getTransferCurrency(),
							transferRequest.getFundTransferType()) && isCityofBirthPresent);
					log.info("IPP Rule flag in FundTransferSF : " + transferRequest.isIPPRequest());
					//PRM 8208 added fix to default charges for IPI and IPP
					if(transferRequest.isIPIRequest() || transferRequest.isIPPRequest()) {
						transferRequest.setChargeOption(ChargeType.SHA.name());
					}
					
					log.info("IPI Rule flag : " + transferRequest.isIPIRequest());
					
					//FMDB-117871
					
					if(transferRequest.getVersion() > 1) {
						if(Objects.nonNull(transferRequest.getBeneficiary()) 
								&& AMEX_BENE_SWIFTCODE.equalsIgnoreCase(transferRequest.getBeneficiary().getSwiftCode())
								&& !AppConstants.AED.equalsIgnoreCase(transferRequest.getTransferCurrency())							
								)
							throw new AppException(ErrorCodes.AMEX_BENE_INVALID_CURRENCY);
					}
				}


				boolean isCoolingPeriodApplicable = false;
				if(Objects.nonNull(transferRequest.getBeneficiary()) && StringUtils.isNotBlank(transferRequest.getBeneficiary().getStatus())) {
					if(ACTIVE.equals(transferRequest.getBeneficiary().getStatus())) {
						// Applicable for MB and IB
						isCoolingPeriodApplicable = false;
					} else {
						isCoolingPeriodApplicable = true;
					}
				} else {
					// Applicable for IB when Save and Pay flow
					int transferCoolingPeriod = settingsRepository.getTransferCoolingPeriod(transferRequest.getFundTransferType());
					if(transferCoolingPeriod > 0) {
						isCoolingPeriodApplicable = true;
					}
					log.info("Beneficiary is not Active and CoolingPeriod:{} and Create Beneficiary Flag: {}", isCoolingPeriodApplicable, transferRequest.getCreateBeneficiary());
				}
				boolean isFutureDatedTransfer = DateTimeHelper.INSTANCE.isFutureDate(transferRequest.getTransferDate(), DATE_DDMMYYYY);
				log.info("Fund Transfer: transferDate:{} and isFutureDated:{}, isCoolingPeriod:{}", transferRequest.getTransferDate(), isFutureDatedTransfer, isCoolingPeriodApplicable);
				
				if(transferRequest.getFundTransferType() == FundTransferTypes.IPO_SUBSCRIPTION || transferRequest.getFundTransferType() == FundTransferTypes.INSURANCE_PAYMENT) {
					isFutureDatedTransfer = false;
					isCoolingPeriodApplicable = false;
				}
				if (isFutureDatedTransfer || isCoolingPeriodApplicable /* && Objects.nonNull(transferRequest.getCreateBeneficiary()) && transferRequest.getCreateBeneficiary()*/ ) {
					//Modify paymentDescription to append purpose code
					//TICR-142: Purpose code changes
					if (FundTransferTypes.INTERNATIONAL_FUNDS_TRANSFER
							.compareTo(transferRequest.getFundTransferType()) == 0
							&& AppConstants.CURRENCY_INR.equalsIgnoreCase(destinationCurrency)) {
						String purposeCode = getPurposeCodeForSwiftInr(transferRequest);
						String txnPurposeCode = "/" + purposeCode + "/";
						transferRequest
						.setTransferDescription(txnPurposeCode + transferRequest.getTransferDescription());
					}
					final CreateUpdateBeneficiaryRequest beneficiaryRequest = createAutopay(transferRequest, isFutureDatedTransfer, isCoolingPeriodApplicable);
					CreateUpdateBeneficiaryResponse beneficiaryResponse;
					try {
						beneficiaryResponse = beneficiarySF.invokeCreateBeneficiary(beneficiaryRequest);
					}catch(AppException e) {
						if(ErrorCodes.SYS_TECHNICAL_ERROR.getCode().equalsIgnoreCase(e.getErrorCode().getCode()))
							throw new AppException(ErrorCodes.SYS_TECHNICAL_ERROR_002);
						throw e;
					}catch(Exception e) {
						log.error(e.getMessage());
						throw new AppException(ErrorCodes.SYS_TECHNICAL_ERROR_002);
					}
					if(beneficiaryResponse.getResult().isSuccess() && !isCoolingPeriodApplicable){
						// SUCCESS MESSAGE FOR AUTO BENEFICIARY
						Map<String, Object> msgArgs = new HashMap<>();
						msgArgs.put("nickName", StringUtils.trimToEmpty(beneficiaryRequest.getNickName()));
						msgArgs.put("txnDateTime", DateTimeHelper.INSTANCE.getCurrentDateForMessage(null));
						msgArgs.put("txnDesc", beneficiaryRequest.getTransferType().getTransferDesc());
						msgArgs.put("destAcc", TextUtils.INSTANCE.acctOrCardLast4Digits(beneficiaryRequest.getAccountOrCardNo()));
						msgArgs.put("destProductType", "Account/Card No.");
						msgArgs.put("transferCurrency", beneficiaryRequest.getTransferCurrency());
						msgArgs.put("startDate", transferRequest.getTransferDate());
						msgArgs.put("frequency", beneficiaryRequest.getAutopay().getFrequency());
						msgArgs.put("transferAmount", Double.toString(beneficiaryRequest.getAutoPayAmount()));

						if(FundTransferTypes.PAYIT_WALLET_TOPUP.compareTo(transferRequest.getFundTransferType()) == 0) {
							msgArgs.put("destAcc", TextUtils.INSTANCE.acctOrCardLast4Digits(beneficiaryRequest.getRemitInfo()));
							notificationService.processNotification(ContentID.PAYIT_SI_TRANSFER_ONETIME, sessionInfo, msgArgs);
						}else if(FundTransferTypes.EDIRHAM_TOPUP.compareTo(transferRequest.getFundTransferType()) == 0) {
							notificationService.processNotification(ContentID.EDIRHAM_SI_TRANSFER_ONETIME, sessionInfo, msgArgs);
						} 
						// **** FMDB-1143 DF Card Payment notification for onetime future dated SI setup
						else if(FundTransferTypes.DF_CARD_PAYMENT.compareTo(transferRequest.getFundTransferType()) == 0) {
							notificationService.processNotification(ContentID.DF_CARD_PAYMENT_SI_TRANSFER_ONETIME, sessionInfo, msgArgs);
						} 
						else {
							notificationService.processNotification(ContentID.SI_TRANSFER_ONETIME, sessionInfo, msgArgs);
						}
						/*notificationService.processNotification(ContentID.SI_TRANSFER_ONETIME,
								transferRequest.getFundTransferType().getTransferDesc(), sessionInfo,
								transferRequest.getFundTransferType().getTransferDesc(), beneficiaryRequest.getNickName(),
								beneficiaryRequest.getAccountOrCardNo(), Double.toString(beneficiaryRequest.getAutoPayAmount()),
								DateTimeHelper.INSTANCE.formatDate(transferRequest.getTransferDate(), DATE_DDMMYYYY , DATE_DDMMMYYYYHHMM),
								beneficiaryRequest.getTransferCurrency());*/
					} 
					/*else if(isCoolingPeriodApplicable) {
						int transferCoolingPeriod = settingsRepository.getTransferCoolingPeriod(beneficiaryRequest.getTransferType());
						if(transferCoolingPeriod > 0){
							// SMS/Email specific to cooling period
							Map<String, Object> msgArgs = new HashMap<>();
							msgArgs.put("nickName", StringUtils.trimToEmpty(beneficiaryRequest.getNickName()));
							msgArgs.put("txnDateTime", DateTimeHelper.INSTANCE.getCurrentDateForMessage(null));
							msgArgs.put("txnDesc",  beneficiaryRequest.getTransferType().getTransferDesc());
							msgArgs.put("destAcc", TextUtils.INSTANCE.acctOrCardLast4Digits(beneficiaryRequest.getAccountOrCardNo()));
							msgArgs.put("coolingPeriod", TextUtils.INSTANCE.getCoolingPeriod(transferCoolingPeriod));
							ContentID content = ContentID.getSuccessContentId(beneficiaryRequest.getTransferType().name(), BENEF_ADD, COOLING_PERIOD_SUCCESS);
							// TODO: BENEF_ADD notification message need to be changed to Fund transfer schedule message.
							notificationService.processNotification(content, SessionContext.getSession(), msgArgs);
						}
					}*/
					paymentResponse = new ExecutePaymentResponse();
					if (AppConstants.ERROR.equalsIgnoreCase(beneficiaryResponse.getResult().getStatus())
							&& ErrorCodes.SYS001_BENEFICIARY.getCode().equalsIgnoreCase(beneficiaryResponse.getResult().getErrorInfo().getCode()))
						beneficiaryResponse.getResult().setFailure(ErrorCodes.SYS001_REQUEST);
					paymentResponse.setResult(beneficiaryResponse.getResult());
				} else {
					log.info("Execute Fund Transfer:{}", transferRequest.getFundTransferType());
					//Validate sender and receiver count
					if(FundTransferTypes.SMS_CASH.compareTo(transferRequest.getFundTransferType()) == 0) {
						checkSmsCashLimit(transferRequest);
					} else if(FundTransferTypes.INTERNATIONAL_FUNDS_TRANSFER.compareTo(transferRequest.getFundTransferType()) == 0) {
						// Server side dual validation to verify again
						//validateAndOverrideSwiftOrRtCode(transferRequest);
						overrideSwiftOrRtCode(transferRequest);
						// Apply override routing code rules
						if(StringUtils.isNotBlank(transferRequest.getBeneficiary().getRoutingCode())) {
							String routingCode = applyOverrideRoutingRule(transferRequest.getBeneficiary().getRoutingCode(), transferRequest.getBeneficiary().getBankName());
							transferRequest.getBeneficiary().setRoutingCode(routingCode);	
						}

						if(LOCAL_CURRENCY.equals(destinationCurrency)) {
							transferRequest.getBeneficiary().setCorrBankBicCode(settingsRepository.getSetting(NOSTRO_ACCOUNT+ UNDERSCORE + LOCAL_CURRENCY));
						} else {
							List<CorrespondentBankDetails> correnpondentBankDetailList = fundTransferRepo.getCorrenpondentBankDetails(transferRequest.getBeneficiary().getCountry().getShortCode(), destinationCurrency, transferRequest.getBeneficiary().getSwiftCode());
							if(Objects.isNull(correnpondentBankDetailList) || correnpondentBankDetailList.isEmpty()) {
								log.error("Correspondent bank details not mapped for country:{} , and currency:{} ",transferRequest.getBeneficiary().getCountry().getShortCode() , destinationCurrency);
								apiResponse.setError(ErrorCodes.INT_TRANSFER_BANK_NOT_MAPPED,transferRequest.getBeneficiary().getCountry().getShortCode() , destinationCurrency );
								return apiResponse;
							}
							if (correnpondentBankDetailList.size() > 1) {
								overrideCorresBankDetails(transferRequest, correnpondentBankDetailList);
							} else {
								transferRequest.getBeneficiary().setCorrBankBicCode(PREFIX_SWIFT + correnpondentBankDetailList.get(0).getBicCode());
							}	
						}

						//Modify paymentDescription to append purpose code
						//TICR-142: Purpose code changes
						if (FundTransferTypes.INTERNATIONAL_FUNDS_TRANSFER
								.compareTo(transferRequest.getFundTransferType()) == 0
								&& destinationCurrency.equalsIgnoreCase(AppConstants.CURRENCY_INR)) {
							String purposeCode = getPurposeCodeForSwiftInr(transferRequest);
							String txnPurposeCode = "/" + purposeCode + "/";
							transferRequest
							.setTransferDescription(txnPurposeCode + transferRequest.getTransferDescription());
						}
					} else if(FundTransferTypes.WITHIN_UAE_FUNDS_TRANSFER.compareTo(transferRequest.getFundTransferType()) == 0) {
						if(!LOCAL_CURRENCY.equalsIgnoreCase(transferRequest.getTransferCurrency())) {
							List<CorrespondentBankDetails> correnpondentBankDetailList = fundTransferRepo.getCorrenpondentBankDetails(AppConstants.COUNTRY_AE, transferRequest.getTransferCurrency(), transferRequest.getBeneficiary().getSwiftCode());
							if(Objects.isNull(correnpondentBankDetailList) || correnpondentBankDetailList.isEmpty()) {
								log.error("Correspondent bank details not mapped for country:{} , and currency:{} ",AppConstants.COUNTRY_AE , transferRequest.getTransferCurrency());
								apiResponse.setError(ErrorCodes.INT_TRANSFER_BANK_NOT_MAPPED, AppConstants.COUNTRY_AE , transferRequest.getTransferCurrency() );
								return apiResponse;
							}
							if (correnpondentBankDetailList.size() > 1) {
								overrideCorresBankDetails(transferRequest, correnpondentBankDetailList);
							} else {
								transferRequest.getBeneficiary().setCorrBankBicCode(PREFIX_SWIFT + correnpondentBankDetailList.get(0).getBicCode());
							}
						}

					}

					// PBG:1613 Adding charges in amount and modifyring transfer object
					if (FundTransferTypes.EDIRHAM_TOPUP.compareTo(transferRequest.getFundTransferType()) == 0) {
						setChargeInAmount(transferRequest, edirhamCardDetails);
					}
					//Reporting changes - when SAVE and PAY.
					if (Objects.nonNull(transferRequest.getCreateBeneficiary()) && transferRequest.getCreateBeneficiary()) {
						transferRequest.getBeneficiary().setCreatedOn(new Date());
						transferRequest.getBeneficiary().setCreatedChannel(sessionInfo.getChannelName());
					}

					enrichReceiverProductType(transferRequest); // to identify receiver is card or account for within FAB

					/*		if(transferRequest.getFundTransferType() == FundTransferTypes.WITHIN_UAE_FUNDS_TRANSFER) {
						transferRequest.setIPIRequest(ipiTransferHelper.isIpiTransfer(transferRequest.getAmount(), transferRequest.getBeneficiary().getAcctOrCardNo(), transferRequest.getTransferCurrency(), transferRequest.getFundTransferType()));	
					}*/
					paymentResponse = transferServiceInvoker.executeFundTransfer(transferRequest);
					if (paymentResponse.getResult().isSuccess()) {
						if(transferRequest.getFundTransferType() == FundTransferTypes.EDIRHAM_TOPUP) {
							ValidatePPCTopupDataAreaRequest edirhamProcessPPCTopupRequest = new ValidatePPCTopupDataAreaRequest();
							enrichPocessE11TopupRequest(edirhamProcessPPCTopupRequest,transferRequest);
							ValidatePPCTopupResposne edirhamTopupResponse = edirhamServiceInvoker.validatePPCTopup(edirhamProcessPPCTopupRequest);
							if(!(Objects.nonNull(edirhamTopupResponse) && Objects.nonNull(edirhamTopupResponse.getProcessPPCTopUpRes())
									&& Objects.nonNull(edirhamTopupResponse.getProcessPPCTopUpRes().getDataAreaProcessPPCTopUpRes())
									&& Objects.nonNull(edirhamTopupResponse.getProcessPPCTopUpRes().getDataAreaProcessPPCTopUpRes().getChangeStatus())
									&& Objects.nonNull(edirhamTopupResponse.getProcessPPCTopUpRes().getDataAreaProcessPPCTopUpRes().getChangeStatus().getReasonCode())
									&& (edirhamTopupResponse.getProcessPPCTopUpRes().getDataAreaProcessPPCTopUpRes().getChangeStatus().getReasonCode()==0))){
								log.info("Process PPC Top up failed, calling transaction reversal"+paymentResponse);
								transferServiceInvoker.executeCancelPaymentForEdirham(paymentResponse);
								paymentResponse.setError(ErrorCodes.TRANSFER_FAILED_FOR_EDIRHAM);
								return paymentResponse;
							}
							//5307 changes
						} else if(transferRequest.getFundTransferType() == FundTransferTypes.IPO_SUBSCRIPTION) {
							log.info("inside IPO subscription");
							try {
								IPOSubscriptionAudit ipoAudit = new IPOSubscriptionAudit();
								IPOSubscriptionDataAreaRequest ipoSubsRequest = new IPOSubscriptionDataAreaRequest();
								enrichIPOSubscriptionDataAreaRequest(ipoSubsRequest, transferRequest, paymentResponse);
								insertIPOTransferAudit(transferRequest, paymentResponse, null, INITIATED);
								IPOSubscriptionAPIResponse ipoSubscriptionResponse = ipoServiceInvoker
										.ipoSubscription(ipoSubsRequest);

								// check payment staus
								if (ipoSubscriptionResponse.getResult().isSuccess()
										&& Objects.nonNull(ipoSubscriptionResponse.getDataArea()) && Objects.nonNull(
												ipoSubscriptionResponse.getDataArea().getApplicationNumber())) {
									paymentResponse.setApplicationNumber(
											ipoSubscriptionResponse.getDataArea().getApplicationNumber());
									ipoRepository.updateIpoAudit(ipoSubscriptionResponse.getDataArea().getApplicationNumber(), AppConstants.SUCCESS_CAPS);

								} else {
									log.info("Getting error from IPO Subscription service" + paymentResponse);
									transferServiceInvoker.executeCancelPaymentForEdirham(paymentResponse);
									ipoRepository.updateIpoAudit(null, AppConstants.FAILED);
									paymentResponse.setError(ErrorCodes.IPO_SUBMISSION_FAILED);
								}

							} catch (Exception e) {
								log.info("Exception occured from IPO Subscription service");
								transferServiceInvoker.executeCancelPaymentForEdirham(paymentResponse);
								ipoRepository.updateIpoAudit(null, AppConstants.FAILED);
								paymentResponse.setError(ErrorCodes.IPO_SUBMISSION_FAILED);
							}
						}else if(transferRequest.getFundTransferType() == FundTransferTypes.INSURANCE_PAYMENT) {
							String narration = transferRequest.getInsuranceDetails().getFabSerialNo() + "/" + transferRequest.getInsuranceDetails().getBrandCode() + "/MB";
							updateInsuranceDbAudit(transferRequest, paymentResponse, InsuranceAppStatus.PAYMENT_T24_SUCCESS, narration, null);
							IssuePolicyRequest issuePolicyRequest = new IssuePolicyRequest();
							issuePolicyRequest.setJourneyReferenceId(transferRequest.getInsuranceDetails().getJourneyReferenceId());
							issuePolicyRequest.setTransactionStatus("SUCCESS");
							issuePolicyRequest.setModeOfPayment(transferRequest.getSourceProductType().name());
							issuePolicyRequest.setTransactionNarration(narration);
							InsuranceDetailsResponse response = convertIssuePolicyResponse(insuranceSF.issuePolicy(issuePolicyRequest));
							if("FAILURE".equalsIgnoreCase(response.getStatus()) || "error".equalsIgnoreCase(response.getStatus())) {
								transferServiceInvoker.reverseInsurancePayment(transferRequest, paymentResponse);
								updateInsuranceDbAudit(transferRequest, paymentResponse, InsuranceAppStatus.PAYMENT_CONFM_PARTNER_FAILED, narration, "FAILED");
								paymentResponse.setError(ErrorCodes.SYS_DEFAULT_ERROR);
							}else if("IN_PROGRESS".equalsIgnoreCase(response.getStatus())) {
								updateInsuranceDbAudit(transferRequest, paymentResponse, null, narration, "IN_PROGRESS");
								paymentResponse.setError(ErrorCodes.TRV_INS_POLICY_IN_PROGRESS);
								notifyPaymentSuccess(transferRequest, paymentResponse, sessionInfo);
							}
							paymentResponse.setInsuranceDetails(response);
						}
					}
				}
				final String cin = sessionInfo.getUser().getCin();
				if (paymentResponse.getResult().isSuccess()) {

					// CALL ACCRUAL API FOR REMITTANCE
					try
					{
						String enableCollinsionFlag = settingsRepository.getSetting(AppConstants.ENABLE_COLLINSION);
						if(Objects.nonNull(enableCollinsionFlag) && "TRUE".equalsIgnoreCase(enableCollinsionFlag)) {
							log.info(" Collinson is enabled...Calling accrual api");
							callAccrualAPI(transferRequest, paymentResponse);
							log.info("Accrual api call ends ");
						}
					}catch(Exception exception)					{
						log.info("Error while calling accural{}",exception);
					}

					super.deleteTxnSession(transferRequest);
					// SUCCESS MESSAGE FOR TRANSFER ONLY IF THE TRANSFER DATE IS NOT FUTURE DATED
					if (!isFutureDatedTransfer && !isCoolingPeriodApplicable) {
						//mqNotifier.refreshCustomerPositionCache(cin);
						String key = AppConstants.CUSTOMER_POS_KEY + cin;
						cacheHelper.removeCustomerPositionCache(key);

						/*if(transferRequest.getFundTransferType() == FundTransferTypes.CARD_PAYMENT_BY_ACCOUNT ||
								(Objects.nonNull(transferRequest.getSourceProductType()) && transferRequest.getSourceProductType() == ProductTypes.CARD)){
							mqNotifier.refreshCustomerPositionCache(cin, AppConstants.CUST_POSITION_CARD);
						} else if(Objects.nonNull(transferRequest.getSourceProductType()) && transferRequest.getSourceProductType() == ProductTypes.ACCOUNT) {
							mqNotifier.refreshCustomerPositionCache(cin, AppConstants.CUST_POSITION_ACCOUNT);
						}*/
						// Override transaction currency in response after receiving the response from T24
						if(StringUtils.isNotBlank(transferRequest.getSourceCurrency()) && Objects.nonNull(paymentResponse.getBalanceForFundingSource())) {
							paymentResponse.getBalanceForFundingSource().setCurrency(transferRequest.getSourceCurrency());
						}
						if(StringUtils.isNotBlank(transferRequest.getReceiverCurrency()) && Objects.nonNull(paymentResponse.getBalanceForCreditAccount())) {
							paymentResponse.getBalanceForCreditAccount().setCurrency(destinationCurrency);
						}

						//INSERTING IN TRANSFER DETAILS FOR AUDIT
						/*try{
							fundTransferRepo.insertTransferDetails(transferRequest,paymentResponse);
						} catch (Exception e){
							log.error("Error while inserting transfer details in audit table:{}", e);
						}*/ //Migrated to Mongo
						notifyPaymentSuccess(transferRequest, paymentResponse, sessionInfo);

						try {
							final TransactionAudit txnAudit = enrichTransferAudit(transferRequest, paymentResponse,
									sessionInfo);
							//changed as part of Mongo to Oracle migration
							//transferPaymentAuditSF.captureRequest(TRANSFER, sessionInfo.getUserId(), txnAudit);
							transferPaymentAuditSF.captureTxnAuditRequest(TRANSFER, sessionInfo.getUserId(), txnAudit);

							if (Objects.nonNull(txnAudit) && Objects.nonNull(txnAudit.getTransferType())
									&& (FundTransferTypes.INSTANT_FUNDS_TRANSFER
											.compareTo(txnAudit.getTransferType()) == 0
											|| Objects.nonNull(txnAudit) && Objects.nonNull(txnAudit.getTransferType())
											&& FundTransferTypes.WALLET_TRANSFER
											.compareTo(txnAudit.getTransferType()) == 0
											|| Objects.nonNull(txnAudit) && Objects.nonNull(txnAudit.getTransferType())
											&& FundTransferTypes.INTERNATIONAL_FUNDS_TRANSFER
											.compareTo(txnAudit.getTransferType()) == 0
											|| Objects.nonNull(txnAudit) && Objects.nonNull(txnAudit.getTransferType())
											&& FundTransferTypes.BANK_TO_BANK_FUNDS_TRANSFER
											.compareTo(txnAudit.getTransferType()) == 0)) {

//								transferPaymentAuditSF.captureRequestForInstantAndWalletTransfer(
//										INSTANT_AND_WALLET_TRANSFER, sessionInfo.getUserId(), txnAudit);
								transferPaymentAuditSF.captureTxnAuditRequest(INSTANT_AND_WALLET_TRANSFER, sessionInfo.getUserId(), txnAudit);
							} else if (FundTransferTypes.INTERNATIONAL_FUNDS_TRANSFER
									.compareTo(transferRequest.getFundTransferType()) == 0
									|| FundTransferTypes.BANK_TO_BANK_FUNDS_TRANSFER
									.compareTo(transferRequest.getFundTransferType()) == 0) {
								enrichB2BandInternationAudit(transferRequest, txnAudit);

								log.info("FundTransferType::TransactionAudit after enrichB2BandInternationAudit : ");

//								transferPaymentAuditSF.captureRequestForInstantAndWalletTransfer(
//										INSTANT_AND_WALLET_TRANSFER, sessionInfo.getUserId(), txnAudit);
								transferPaymentAuditSF.captureTxnAuditRequest(INSTANT_AND_WALLET_TRANSFER, sessionInfo.getUserId(), txnAudit);
							}
						} catch (Exception ex) {
							log.error("Error while udpating txn session : ", ex);
						}

					}

					// CREATE BENEFICIARY
					if (Objects.nonNull(transferRequest.getCreateBeneficiary()) && transferRequest.getCreateBeneficiary()) {
						CreateUpdateBeneficiaryResponse benefCreation  = creteBeneficiaryAndNotify(transferRequest, sessionInfo, isCoolingPeriodApplicable);
						if(Objects.nonNull(benefCreation)) return benefCreation;
					} else if(Objects.nonNull(transferRequest.getBeneficiary())) {
						updateBeneficiaryDetails(transferRequest, destinationCurrency);
					}

					// CREATE AUTO BENEFICIARY
					if (Objects.nonNull(transferRequest.getCreateAutopay()) && transferRequest.getCreateAutopay()) {
						CreateUpdateBeneficiaryResponse recurringTransfer  = createRecurringTransferAndNotify(transferRequest, sessionInfo, isCoolingPeriodApplicable);
						if(Objects.nonNull(recurringTransfer)) return recurringTransfer;
					}
				}
				// Start of PRM-4775_IBMB_DUPLICATE_TRANSFER_ISSUE fix
				if(AppConstants.ERROR.equalsIgnoreCase(paymentResponse.getResult().getStatus())) {
					if(Objects.nonNull(paymentResponse.getResult().getErrorInfo()) &&"TRANSFER_FAILED".equalsIgnoreCase(paymentResponse.getResult().getErrorInfo().getCode()))
					{
						log.info(" inside the TRANSFER_FAILED scenario");
						super.deleteTxnSession(transferRequest);
						//mqNotifier.refreshCustomerPositionCache(sessionInfo.getUser().getCin());
						String key = AppConstants.CUSTOMER_POS_KEY + cin;
						cacheHelper.removeCustomerPositionCache(key);
					}	
				  }
				//End of PRM-4775_IBMB_DUPLICATE_TRANSFER_ISSUE fix
				
				if(FundTransferTypes.EDIRHAM_TOPUP.compareTo(transferRequest.getFundTransferType()) == 0 && Objects.nonNull(paymentResponse) &&
						Objects.nonNull(paymentResponse.getResult()) && Objects.nonNull(paymentResponse.getResult().getErrorInfo())&&
						Objects.nonNull(paymentResponse.getResult().getErrorInfo().getCode()) &&
						paymentResponse.getResult().getErrorInfo().getCode().equalsIgnoreCase(ErrorCodes.TRANSFER_FAILED.getCode())) {
					paymentResponse.setError(ErrorCodes.TRANSFER_FAILED_FOR_EDIRHAM);
				}
				if(FundTransferTypes.IPO_SUBSCRIPTION.compareTo(transferRequest.getFundTransferType()) == 0 && Objects.nonNull(paymentResponse) &&
						Objects.nonNull(paymentResponse.getResult()) && Objects.nonNull(paymentResponse.getResult().getErrorInfo())&&
						Objects.nonNull(paymentResponse.getResult().getErrorInfo().getCode()) &&
						paymentResponse.getResult().getErrorInfo().getCode().equalsIgnoreCase(ErrorCodes.TRANSFER_FAILED.getCode())) {
					insertIPOTransferAudit(transferRequest, paymentResponse,
							 null,AppConstants.FAILED);	
					paymentResponse.setError(ErrorCodes.IPO_SUBMISSION_FAILED);
				}
				if(FundTransferTypes.INSURANCE_PAYMENT.compareTo(transferRequest.getFundTransferType()) == 0 && Objects.nonNull(paymentResponse) &&
						Objects.nonNull(paymentResponse.getResult()) && Objects.nonNull(paymentResponse.getResult().getErrorInfo())&&
						Objects.nonNull(paymentResponse.getResult().getErrorInfo().getCode()) &&
						paymentResponse.getResult().getErrorInfo().getCode().equalsIgnoreCase(ErrorCodes.TRANSFER_FAILED.getCode())) {
					
					IssuePolicyRequest issuePolicyRequest = new IssuePolicyRequest();
					issuePolicyRequest.setJourneyReferenceId(transferRequest.getInsuranceDetails().getJourneyReferenceId());
					issuePolicyRequest.setTransactionStatus("FAILURE");
					issuePolicyRequest.setModeOfPayment(transferRequest.getSourceProductType().name());
					String narration = transferRequest.getInsuranceDetails().getFabSerialNo() + "/" + transferRequest.getInsuranceDetails().getBrandCode() + "/MB";
					issuePolicyRequest.setTransactionNarration(narration);
					updateInsuranceDbAudit(transferRequest, paymentResponse, InsuranceAppStatus.PAYMENT_T24_FAILED, narration, null);
					if (paymentResponse != null && paymentResponse.getResult() != null
							&& paymentResponse.getResult().getErrorInfo() != null) {
						issuePolicyRequest.setErrorResponseMessages(paymentResponse.getResult().getErrorInfo().getDesc());
					}

					paymentResponse.setInsuranceDetails(convertIssuePolicyResponse(insuranceSF.issuePolicy(issuePolicyRequest)));
					paymentResponse.setError(ErrorCodes.INSURANCE_PAYMENT_FAILED);
				}
				if(isFutureDatedTransfer) {
					paymentResponse.setNextExecutionDate(transferRequest.getTransferDate());
				} else if(Objects.nonNull(transferRequest.getCreateAutopay()) && transferRequest.getCreateAutopay()) {
					Date paymentDate = new Date();
					if(StringUtils.isNotBlank(transferRequest.getTransferDate())) {
						paymentDate = DateTimeHelper.INSTANCE.formatDate(transferRequest.getTransferDate(), DATE_DDMMYYYY);
					} 
					paymentResponse.setNextExecutionDate(DateTimeHelper.INSTANCE.getNextRunOnDate(paymentDate, Frequency.getFrequency(transferRequest.getAutopay().getFrequency()), null)); 
				}
				return paymentResponse;
			}
			
			return authResponse;
		});
	}


Initial State

Transfer Advice for transactions are only available for Swift / International Transfers

Target State: 

In addition to Swift/ Intenational payments, the advice will also be provided to  Within Bank and within UAE transfers.

Solution steps:

1)User submits the transaction

2) Transaction is completed successfully

3) PDF generation logic should be triggered, and the pdf created will be sent as an attachment in the notification email (existing notification email will be used to send the attachment and minor modification in the email content will be there). The template required will be put in content_item table.

4) /document/v1/generate: This service is to be modified and used for PDF generation. For password protection, an optional field with the password value will be sent in request and logic needs to be added to read the variable. If the variable has password value, then password protection with the mentioned password need to be implemented on the generated pdf file. If not, then BAU logic (without password protection) will be used.

When sending the email for sending advice post successful transactions, all the details of transaction can obtained from java beans. 

 Mappings

 

Field in Advice	Object	Attribute
Amount	com.fab.pb.services.paymentNtransfers.requests.ExecuteTransferRequest	amount
Charge Including VAT	com.fab.pb.services.paymentNtransfers.responses.FetchFTChargeResponse	com.fab.pb.models.List<Charge> chargeList  -- charge and tax amount of the first element . Add both.
Transaction date	com.fab.pb.services.paymentNtransfers.requests.ExecuteTransferRequest	transferDate | Alt : date at which the transaction is executed
Transaction Reference	com.fab.pb.services.paymentNtransfers.responses.ExecutePaymentResponse	transactionRefNo (FTNumber needs to be shown)
Transfer Description 	com.fab.pb.services.paymentNtransfers.requests.ExecuteTransferRequest	transferDescription



From : Sender 	com.fab.pb.models. User	User user = SessionContext.getSession().getUser()

get details from this object for name . Use 'name' and 'salutation' fields
Sender account number/card number	com.fab.pb.services.paymentNtransfers.requests.ExecuteTransferRequest	sourceProductRef
From Bank 	
will always default to 'First Abu Dhabi Bank'



Beneficiary	
com.fab.pb.services.paymentNtransfers.requests.ExecuteTransferRequest --> com.fab.pb.models.bo.Beneficiary
Beneficiary Name	com.fab.pb.models.bo.Beneficiary	name
Beneficiary IBAN/Card number	com.fab.pb.models.bo.Beneficiary	acctOrCardNo
Beneficiary bank	com.fab.pb.models.bo.Beneficiary	bankName
  

The attachment in pdf format should be password protected (similar to stamped statements: Last 4 digits of the account followed by the 4 digits representing the day and month of birthday) before sending as it has secure client information.



Additionally email content needs to be updated as mentioned in story.

import software.amazon.awscdk.Duration;
import software.amazon.awscdk.Stack;
import software.amazon.awscdk.StackProps;
import software.amazon.awscdk.services.ec2.*;
import software.amazon.awscdk.services.events.targets.LambdaFunction;
import software.amazon.awscdk.services.iam.IRole;
import software.amazon.awscdk.services.iam.Role;
import software.amazon.awscdk.services.kms.IKey;
import software.amazon.awscdk.services.kms.Key;
import software.amazon.awscdk.services.lambda.*;
import software.amazon.awscdk.services.lambda.destinations.S3EventSource;
import software.amazon.awscdk.services.lambda.notifications.NotificationKeyFilter;
import software.amazon.awscdk.services.s3.Bucket;
import software.amazon.awscdk.services.s3.IBucket;
import software.amazon.awscdk.services.s3.notifications.LambdaDestination;
import software.amazon.awscdk.services.s3.events.S3EventSource;
import software.amazon.awscdk.services.s3.eventsource.NotificationKeyFilter;
import software.constructs.Construct;

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

public class SanctionCountryReportS3LambdaStack extends Stack {

    public SanctionCountryReportS3LambdaStack(final Construct scope, final String id) {
        this(scope, id, null);
    }

    public SanctionCountryReportS3LambdaStack(final Construct scope, final String id, final StackProps props) {
        super(scope, id, props);

        CfnParameter envParameter = new CfnParameter(this, "env",
                CfnParameterProps.builder().defaultValue("local").build());
        CfnParameter regionParameter = new CfnParameter(this, "region",
                CfnParameterProps.builder().defaultValue("me-central-1").build());
        CfnParameter accountIdParameter = new CfnParameter(this, "account",
                CfnParameterProps.builder().defaultValue("517606038493").build());
        CfnParameter kmsAccountIdParameter = new CfnParameter(this, "kms-account",
                CfnParameterProps.builder().defaultValue("644749578616").build());

        CfnParameter vpcIdParameter = new CfnParameter(this, "vpcId",
                CfnParameterProps.builder().type("AWS::EC2::VPC::Id").build());
        CfnParameter appSubnetIdsParameter = new CfnParameter(this, "appSubnetIds",
                CfnParameterProps.builder().type("List<AWS::EC2::Subnet::Id>").build());

        CfnParameter xksKeyIdParameter = new CfnParameter(this, "xksKeyId",
                CfnParameterProps.builder().defaultValue("cc63e70e-6095-42fa-9fa0-a7c20a726de9").build());

        CfnParameter s3BucketParameter = new CfnParameter(this, "s3Bucket",
                CfnParameterProps.builder().defaultValue("ibmb-gfri-reports").build());

        CfnParameter s3bucketPathParameter = new CfnParameter(this, "bucketPath",
                CfnParameterProps.builder().defaultValue("negative-country-phase0/input/").build());

        // Lambda Configuration parameters
        CfnParameter memorySizeParameter = new CfnParameter(this, "memorySize",
                CfnParameterProps.builder().type("Number").defaultValue("128").build());
        CfnParameter lambdaTimeoutParameter = new CfnParameter(this, "timeout-seconds",
                CfnParameterProps.builder().type("Number").defaultValue("60").build());
        CfnParameter deploymentBucketParameter = new CfnParameter(this, "deployment-bucket",
                CfnParameterProps.builder().defaultValue("ibmb-ms-deployment-dev-uae").build());
        CfnParameter deploymentFileParameter = new CfnParameter(this, "deployment-file-name", CfnParameterProps
                .builder().defaultValue("lambda/deployment/sanction-country-report_v1.zip").build());
        CfnParameter layerVersionParameter = new CfnParameter(this, "python-layer-version",
                CfnParameterProps.builder().defaultValue("20").build());

        // Environment variables for Lambda function
        CfnParameter certificatePasswordParameter = new CfnParameter(this, "certificate-password",
                CfnParameterProps.builder().defaultValue("xxxxx").build());
        CfnParameter toAddressParameter = new CfnParameter(this, "to-address",
                CfnParameterProps.builder().defaultValue("vishal.jagtap@bankfab.com").build());
        CfnParameter fetchCinCifByRefIdServiceUrlParameter = new CfnParameter(this, "fetch-cin-cif-service-url", CfnParameterProps.builder()
                .defaultValue("https://api-sit.digital-ibmb-dev.aeapps.bankfab.com/pbdb/v1/customer/cust-id-info").build());
        CfnParameter sendEmailServiceUrlParameter = new CfnParameter(this, "send-email-service-url", CfnParameterProps.builder()
                .defaultValue("https://kproxy-uat.pcdigital-dev.aeapps.bankfab.com/NotificationService/nsapi/email/sendemail").build());
        CfnParameter getCustDetailsServiceUrlParameter = new CfnParameter(this, "get_customer_details", CfnParameterProps.builder()
                .defaultValue("https://dpuat.bankfab.com:2038/customeronboarding/v2/customer-details").build());

        String env = envParameter.getValueAsString();
        String region = regionParameter.getValueAsString();
        String account = accountIdParameter.getValueAsString();
        String kmsAccount = kmsAccountIdParameter.getValueAsString();
        String s3Arn = "arn:aws:s3:::" + s3BucketParameter.getValueAsString();
        String s3BucketPath = s3bucketPathParameter.getValueAsString();

        String vpcId = vpcIdParameter.getValueAsString();
        List<String> subnetIds = appSubnetIdsParameter.getValueAsList();

        String xksKeyId = xksKeyIdParameter.getValueAsString();

        Number memorySize = memorySizeParameter.getValueAsNumber();
        Number lambdaTimeout = lambdaTimeoutParameter.getValueAsNumber();
        String deploymentBucketName = deploymentBucketParameter.getValueAsString();
        String deploymentFileKey = deploymentFileParameter.getValueAsString();
        String layerVersion = layerVersionParameter.getValueAsString();

        String certificatePassword = certificatePasswordParameter.getValueAsString();
        String toAddress = toAddressParameter.getValueAsString();
        String fetchCinCifByRefIdServiceUrl = fetchCinCifByRefIdServiceUrlParameter.getValueAsString();
        String sendEmailServiceUrl = sendEmailServiceUrlParameter.getValueAsString();
        String getCustomerDetailsUrl = getCustDetailsServiceUrlParameter.getValueAsString();

        Map<String, String> lambdaEnvVariableMap = getEnvVariableMap(env, certificatePassword,
                toAddress, fetchCinCifByRefIdServiceUrl, sendEmailServiceUrl, getCustomerDetailsUrl);

        IKey kmsKey = Key.fromKeyArn(this, "kmsKey", "arn:aws:kms:" + region + ":" + kmsAccount + ":key/" + xksKeyId);

        ILayerVersion lambdaLayerVersion = LayerVersion.fromLayerVersionArn(this, "lambda-py-layer",
                "arn:aws:lambda:" + region + ":" + account + ":layer:lambda-py-layer:" + layerVersion);

        IBucket ibucket = Bucket.fromBucketArn(this, "negative-country-report-bucket", s3Arn);

        IRole scReportRole = Role.fromRoleName(this, "scReportRoleId", "sc-report-role-iam-lambda-" + env);

        Function sanctionCountryReportFunction = sanctionCountryReportFunction(id, env, vpcId, subnetIds,
                memorySize, lambdaTimeout, deploymentBucketName, deploymentFileKey, lambdaLayerVersion, kmsKey,
                scReportRole, lambdaEnvVariableMap);

        // Grant Lambda function read access to the S3 bucket
        ibucket.grantRead(sanctionCountryReportFunction);

        // Add an event notification for when an object is created in the S3 bucket
        ibucket.addEventNotification(S3EventSource.OBJECT_CREATED, new LambdaDestination(sanctionCountryReportFunction),
                NotificationKeyFilter.builder()
                        .prefix(s3BucketPath)
                        .suffix(".csv")
                        .build());
    }

    private Function sanctionCountryReportFunction(String id, String env, String vpcId, List<String> subnetIds,
                                                   Number memorySize, Number lambdaTimeout, String deploymentBucketName, String deploymentFileKey,
                                                   ILayerVersion lambdaLayerVersion, IKey xksKey, IRole sanctionCountryReportRole, Map<String, String> lambdaEnvVariableMap) {

        return new Function(this, "sanction-country-report", FunctionProps.builder()
                .functionName("Sanction-Country-Report-" + env)
                .runtime(Runtime.PYTHON_3_9)
                .role(sanctionCountryReportRole)
                .environmentEncryption(xksKey)
                .code(Code.fromBucket(Bucket.fromBucketName(this, "function_deploymnet_bucket", deploymentBucketName),
                        deploymentFileKey))
                .handler("lambda.handler")
                .memorySize(memorySize)
                .timeout(Duration.seconds(lambdaTimeout))
                .environment(lambdaEnvVariableMap)
                .layers(Collections.singletonList(lambdaLayerVersion))
                .currentVersionOptions(VersionOptions.builder().description("v1")
                        .removalPolicy(RemovalPolicy.RETAIN).build())
                .vpc(Vpc.fromVpcAttributes(this, id,
                        VpcAttributes.builder().vpcId(vpcId).availabilityZones(getAvailabilityZones()).build()))
                .vpcSubnets(SubnetSelection.builder().subnets(getAppSubnetList(subnetIds)).build()).build());
    }

    public Map<String, String> getEnvVariableMap(String env, String certificatePassword,
                                                 String toAddress, String fetchCinCifByRefIdServiceUrl, String sendEmailServiceUrl, String getCustomerDetailsUrl) {
        Map<String, String> map = new HashMap<>();
        String path = "/var/task/ssl/".concat(env);

        map.put("CERT_PASSWORD", certificatePassword);
        map.put("CLIENT_CERT", path.concat("/client.crt"));
        map.put("SERVER_KEY", path.concat("/client.key"));
        map.put("CA_CERT", path.concat("/certificate.pem"));
        map.put("TO_ADDRESS", toAddress);
        map.put("FETCH_CIN_CIF_BY_REFID_URL", fetchCinCifByRefIdServiceUrl);
        map.put("SEND_EMAIL_SERVICE_URL", sendEmailServiceUrl);
        map.put("GET_CUSTOMER_DETAILS", getCustomerDetailsUrl);

        return map;
    }

    private List<ISubnet> getAppSubnetList(List<String> subnetIds) {
        List<ISubnet> subnetList = new ArrayList<>();
        AtomicInteger counter = new AtomicInteger(0);
        subnetIds.forEach(
                subnet -> subnetList.add(Subnet.fromSubnetId(this, "subnet" + counter.incrementAndGet(), subnet)));
        return subnetList;
    }

}


-------------------------------------------

public class SanctionCountryReportS3LambdaStack extends Stack {

	public SanctionCountryReportS3LambdaStack(final Construct scope, final String id) {
		this(scope, id, null);
	}

	public SanctionCountryReportS3LambdaStack(final Construct scope, final String id, final StackProps props) {
		super(scope, id, props);

		CfnParameter envParameter = new CfnParameter(this, "env",
				CfnParameterProps.builder().defaultValue("local").build());
		CfnParameter regionParameter = new CfnParameter(this, "region",
				CfnParameterProps.builder().defaultValue("me-central-1").build());
		CfnParameter accountIdParameter = new CfnParameter(this, "account",
				CfnParameterProps.builder().defaultValue("517606038493").build());
		CfnParameter kmsAccountIdParameter = new CfnParameter(this, "kms-account", 
        		CfnParameterProps.builder().defaultValue("644749578616").build());
		
		CfnParameter vpcIdParameter = new CfnParameter(this, "vpcId",
				CfnParameterProps.builder().type("AWS::EC2::VPC::Id").build());
		CfnParameter appSubnetIdsParameter = new CfnParameter(this, "appSubnetIds",
				CfnParameterProps.builder().type("List<AWS::EC2::Subnet::Id>").build());

		CfnParameter xksKeyIdParameter = new CfnParameter(this, "xksKeyId",
				CfnParameterProps.builder().defaultValue("cc63e70e-6095-42fa-9fa0-a7c20a726de9").build());
		
		CfnParameter s3BucketParameter = new CfnParameter(this, "s3Bucket",
				CfnParameterProps.builder().defaultValue("ibmb-gfri-reports").build());
		
		CfnParameter s3bucketPathParameter = new CfnParameter(this, "bucketPath",
				CfnParameterProps.builder().defaultValue("negative-country-phase0/input/").build());

		// Lambda Configuration parameters
		CfnParameter memorySizeParameter = new CfnParameter(this, "memorySize",
				CfnParameterProps.builder().type("Number").defaultValue("128").build());
		CfnParameter lambdaTimeoutParameter = new CfnParameter(this, "timeout-seconds",
				CfnParameterProps.builder().type("Number").defaultValue("60").build());
		CfnParameter deploymentBucketParameter = new CfnParameter(this, "deployment-bucket",
				CfnParameterProps.builder().defaultValue("ibmb-ms-deployment-dev-uae").build());
		CfnParameter deploymentFileParameter = new CfnParameter(this, "deployment-file-name", CfnParameterProps
				.builder().defaultValue("lambda/deployment/sanction-country-report_v1.zip").build());
		CfnParameter layerVersionParameter = new CfnParameter(this, "python-layer-version",
				CfnParameterProps.builder().defaultValue("20").build());
		
		// Environment variables for Lambda function
		CfnParameter certificatePasswordParameter = new CfnParameter(this, "certificate-password",
				CfnParameterProps.builder().defaultValue("xxxxx").build());
		CfnParameter toAddressParameter = new CfnParameter(this, "to-address",
				CfnParameterProps.builder().defaultValue("vishal.jagtap@bankfab.com").build());
		CfnParameter fetchCinCifByRefIdServiceUrlParameter = new CfnParameter(this, "fetch-cin-cif-service-url", CfnParameterProps.builder()
				.defaultValue("https://api-sit.digital-ibmb-dev.aeapps.bankfab.com/pbdb/v1/customer/cust-id-info").build());
		CfnParameter sendEmailServiceUrlParameter = new CfnParameter(this, "send-email-service-url", CfnParameterProps.builder()
				.defaultValue("https://kproxy-uat.pcdigital-dev.aeapps.bankfab.com/NotificationService/nsapi/email/sendemail").build());
		CfnParameter getCustDetailsServiceUrlParameter = new CfnParameter(this, "get_customer_details", CfnParameterProps.builder()
				.defaultValue("https://dpuat.bankfab.com:2038/customeronboarding/v2/customer-details").build());
		
		String env = envParameter.getValueAsString();
		String region = regionParameter.getValueAsString();
		String account = accountIdParameter.getValueAsString();
		String kmsAccount = kmsAccountIdParameter.getValueAsString();
		String s3Arn = "arn:aws:s3:::" + s3BucketParameter.getValueAsString();
		String s3BucketPath = s3bucketPathParameter.getValueAsString();

		String vpcId = vpcIdParameter.getValueAsString();
		List<String> subnetIds = appSubnetIdsParameter.getValueAsList();
		
		String xksKeyId = xksKeyIdParameter.getValueAsString();
		
		Number memorySize = memorySizeParameter.getValueAsNumber();
		Number lambdaTimeout = lambdaTimeoutParameter.getValueAsNumber();
		String deploymentBucketName = deploymentBucketParameter.getValueAsString();
		String deploymentFileKey = deploymentFileParameter.getValueAsString();
		String layerVersion = layerVersionParameter.getValueAsString();
		
		String certificatePassword = certificatePasswordParameter.getValueAsString();
		String toAddress = toAddressParameter.getValueAsString();
		String fetchCinCifByRefIdServiceUrl = fetchCinCifByRefIdServiceUrlParameter.getValueAsString();
		String sendEmailServiceUrl = sendEmailServiceUrlParameter.getValueAsString();
		String getCustomerDetailsUrl  = getCustDetailsServiceUrlParameter.getValueAsString();
		
		Map<String, String> lambdaEnvVariableMap = getEnvVariableMap(env, certificatePassword,
				toAddress, fetchCinCifByRefIdServiceUrl, sendEmailServiceUrl, getCustomerDetailsUrl);
		
		@NotNull
		IKey kmsKey = Key.fromKeyArn(this, "kmsKey", "arn:aws:kms:" + region + ":" + kmsAccount + ":key/" + xksKeyId);

		ILayerVersion lambdaLayerVersion = LayerVersion.fromLayerVersionArn(this, "lambda-py-layer",
				"arn:aws:lambda:" + region + ":" + account + ":layer:lambda-py-layer:" + layerVersion);

		IBucket ibucket = Bucket.fromBucketArn(this, "negative-country-report-bucket", s3Arn);
		
		@NotNull
		IRole scReportRole = Role.fromRoleName(this, "scReportRoleId", "sc-report-role-iam-lambda-"+env); 
		
		Function sanctionCountryReportFunction = sanctionCountryReportFunction(id, env, vpcId, subnetIds,
				memorySize, lambdaTimeout, deploymentBucketName, deploymentFileKey, lambdaLayerVersion, kmsKey,
				scReportRole, lambdaEnvVariableMap);

		ibucket.grantRead(sanctionCountryReportFunction);
 		ibucket.addObjectCreatedNotification(new LambdaDestination(sanctionCountryReportFunction), NotificationKeyFilter.builder()
				.prefix(s3BucketPath)
				.suffix(".csv")
				.build());
	}

	private Function sanctionCountryReportFunction(String id, String env, String vpcId, List<String> subnetIds,
			Number memorySize, Number lambdaTimeout, String deploymentBucketName, String deploymentFileKey,
			@NotNull ILayerVersion lambdaLayerVersion, @NotNull IKey xksKey, @NotNull IRole sanctionCountryReportRole, Map<String, String> lambdaEnvVariableMap) {

		return new Function(this, "sanction-country-report", FunctionProps.builder()
				.functionName("Sanction-Country-Report-" + env)
				.runtime(software.amazon.awscdk.services.lambda.Runtime.PYTHON_3_9)
				.role(sanctionCountryReportRole)
				.environmentEncryption(xksKey)
				.code(Code.fromBucket(Bucket.fromBucketName(this, "function_deploymnet_bucket", deploymentBucketName),
						deploymentFileKey))
				.handler("lambda.handler")
				.memorySize(memorySize)
				.timeout(Duration.seconds(lambdaTimeout))
				.environment(lambdaEnvVariableMap)
				.layers(List.of(lambdaLayerVersion))
				.currentVersionOptions(VersionOptions.builder().description("v1")
						.removalPolicy(RemovalPolicy.RETAIN).build())
				.vpc(Vpc.fromVpcAttributes(this, id,
						VpcAttributes.builder().vpcId(vpcId).availabilityZones(getAvailabilityZones()).build()))
				.vpcSubnets(SubnetSelection.builder().subnets(getAppSubnetList(subnetIds)).build()).build());
	}

	/**
	 * @param env
	 * @param certificatePassword
	 * @param validateCustomerProfileUrl
	 * @param documentUploadUrl
	 * @param confirmCustomerRegistrationUrl
	 * @return
	 */
	
	public Map<String, String> getEnvVariableMap(String env, String certificatePassword,
			String toAddress, String fetchCinCifByRefIdServiceUrl, String sendEmailServiceUrl, String getCustomerDetailsUrl) {
		Map<String, String> map = new HashMap<>();
		String path = "/var/task/ssl/".concat(env);
		
		map.put("CERT_PASSWORD", certificatePassword);
		map.put("CLIENT_CERT", path.concat("/client.crt"));
		map.put("SERVER_KEY", path.concat("/client.key"));
		map.put("CA_CERT", path.concat("/certificate.pem"));
		map.put("TO_ADDRESS", toAddress);
		map.put("FETCH_CIN_CIF_BY_REFID_URL", fetchCinCifByRefIdServiceUrl);
		map.put("SEND_EMAIL_SERVICE_URL", sendEmailServiceUrl);
		map.put("GET_CUSTOMER_DETAILS", getCustomerDetailsUrl);
		
		return map;
	}

	private List<@NotNull ISubnet> getAppSubnetList(List<String> subnetIds) {
		List<ISubnet> subnetList = new ArrayList<>();
		AtomicInteger counter = new AtomicInteger(0);
		subnetIds.forEach(
				subnet -> subnetList.add(Subnet.fromSubnetId(this, "subnet" + counter.incrementAndGet(), subnet)));
		return subnetList;
	}

}



#!/usr/bin/env python3
import os
import json
import csv
import base64
import uuid
import io
from datetime import datetime
from urllib.parse import unquote
import pbcore.logger as logger
import pbcore.header as header
import pbcore.sslcontext as sslcont
import pbcore.aws.secretstore as secretstore
import boto3  # Updated: Use boto3 for S3

# Initialize the S3 client using boto3
s3_client = boto3.client('s3')  # Updated: Use boto3 client for S3 operations


# Defining Constant variables
COMMA_DELIMETER = ','

# Creation of SSL Context for SSL certificate verification using pbcore's sslcontext.
if(LAMBDA_FUNCTION is not None):
    ssl_context = sslcont.get_ssl_context()
else:
    ssl_context = sslcont.get_ssl_context_local('uat')
    
# CSV column mapping with Object fields
csv_column_mapping = {
    'customerId': 'CIN', 
    'cif': 'CIF', 
    'fullName': 'CM Name', 
    'target': 'Target Code', 
    'segment': 'Business Segment', 
    'accountOfficer': 'Branch', 
    'relationshipManager': 'RM', 
    'nationality': 'Nationality', 
    'login_attempts': 'Total Login Attempts', 
    'no_of_days': 'Login Period (no. of Days)'
}

# Lambda handler
def handler(event, content):
    logger.info(f"Event received from S3: {event}")
    s3_bucket = event['Records'][0]['s3']['bucket']['name']
    s3_key = event['Records'][0]['s3']['object']['key']
    s3_key = unquote(s3_key)
    logger.info(f"Unquote S3 key: {s3_key}")

    # Fetch the file from S3 using boto3
    response = s3_client.get_object(Bucket=s3_bucket, Key=s3_key)  # Updated: Fetch file from S3 using boto3
    csv_content = response['Body'].read().decode('utf-8')

    # Process the CSV content
    processor(io.StringIO(csv_content), s3_key)

# Method to read CSV data and calculate login attempts and number of days
def read_csv(csv_data):
    user_activity_dict = {}
    data = []
    reader = csv.reader(csv_data)
    header = next(reader, None)
    data.append(header)

    for row in reader:
        if row:
            rawTime = row[2].split('.')
            row[2] = ' ' + rawTime[0] + ''
        data.append(row)
        user_id = row[0].strip()
        if user_id not in user_activity_dict:
            unique_transaction_date = set()
            unique_transaction_date.add(row[2].strip().split(' ')[0])
            user_activity_dict[user_id] = {
                'transaction_date': unique_transaction_date, 
                'no_of_days': 0, 
                'login_attempts': 0
            }
            transaction_type = row[5].strip()
            if transaction_type.lower().find('login') != -1:
                user_activity_dict[user_id]['no_of_days'] += 1
                user_activity_dict[user_id]['login_attempts'] += 1
        else:
            transaction_date = user_activity_dict[user_id]['transaction_date']
            transaction_type = row[5].strip()
            if transaction_type.lower().find('login') != -1:
                if row[2].strip().split(' ')[0] not in transaction_date:
                    transaction_date.add(row[2].strip().split(' ')[0])
                    user_activity_dict[user_id]['no_of_days'] += 1
                    user_activity_dict[user_id]['login_attempts'] += 1
                else:
                    user_activity_dict[user_id]['login_attempts'] += 1

    with open('/tmp/output.csv', 'w', newline='') as outputFile:
        writer = csv.writer(outputFile)
        writer.writerows(data)
    logger.info("CSV file is copied to the temp location")
    return user_activity_dict

# Method to update user activity dictionary with customer data
def update_user_activity_dict(user_details, user_activity_dict):
    userlist = user_details.get('userList', [])
    userlist_map = {next(iter(item.keys())): next(iter(item.values())) for item in userlist}

    for map_values in userlist_map:
        values = user_activity_dict[map_values]
        values["customerId"] = userlist_map[map_values]["customerId"]
        values["cif"] = userlist_map[map_values]["cif"]
        json_response = get_customer_data(userlist_map[map_values]["customerId"])

        try:
            values["fullName"] = json_response["dataArea"]["fullName"]
            values["target"] = json_response["dataArea"]["additionalCustomerInfo"]["target"]
            values["segment"] = json_response["dataArea"]["additionalCustomerInfo"]["segment"]
            values["accountOfficer"] = json_response["dataArea"]["additionalCustomerInfo"]["accountOfficer"]
            values["relationshipManager"] = json_response["dataArea"]["additionalCustomerInfo"]["relationshipManager"]
            values["nationality"] = json_response["dataArea"]["nationality"]
        except:
            logger.error(f"Error in parsing JSON response: {json_response}")

# Method to write updated CSV content back to temp location        
def write_csv(temp_file_location, user_activity_dict):
    with open(temp_file_location, 'r') as file:
        csv_data = list(csv.DictReader(file))

        for row in csv_data:
            row_key = row.get('USER_NAME')
            values = user_activity_dict.get(row_key)
            if values:
                for json_key, csv_column in csv_column_mapping.items():
                    row[csv_column] = values.get(json_key, row.get(csv_column))

    fieldnames = [
        'USER_NAME', 'USER_ID', 'TIMESTAMP', 'TRANSACTION_ID',
        'IP_ADDRESS', 'TRANSACTION_TYPE', 'COUNTRY', 'CIN', 'CIF',
        'CM Name', 'Target Code', 'Business Segment', 'Branch', 'RM',
        'Nationality', 'Total Login Attempts', 'Login Period (no. of Days)'
    ]

    with open(temp_file_location, 'w', newline='') as outputFile:
        writer = csv.DictWriter(outputFile, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(csv_data)
    logger.info("Updated CSV file written to temp location")

# Method to send email with CSV attachment
def send_mail(csv_data_in_bytes, s3_file_name):
    if csv_data_in_bytes is not None:
        currectDate = datetime.now().date()
        email_subject = "Sanctioned country report_" + currectDate.strftime("%Y-%m-%d")
        split_array = s3_file_name.split('/')
        s3_file_name=split_array[-1]
        s3_file_name = s3_file_name.replace(':','_')
        url = os.environ['SEND_EMAIL_SERVICE_URL']

        headers = header.update_headers({
            'XREF': str(uuid.uuid4()),
            'CHANNELID': 'AWS',
            'content-type': 'application/json'
        })

        to_address_list = os.environ['TO_ADDRESS'].split(COMMA_DELIMETER)

        data = {
            "sourceSystem": "FAB",
            "requestID": str(uuid.uuid4()),
            "fromAddress": "noreply@bankfab.com",
            "entityName": "FAB",
            "toAddress": to_address_list,
            "emailSubject": email_subject,
            "emailBodyContent": "",
            "emailBodyContentType": "TEXT",
            "attachment": [{
                "attachementBytes": str(csv_data_in_bytes.decode("utf-8")),
                "mimeType": "application/csv",
                "fileName": s3_file_name
            }]
        }

        data = json.dumps(data)

        response = boto3.client('lambda').invoke(  # Updated: Use boto3 for Lambda invocation
            FunctionName=url,
            InvocationType='RequestResponse',
            Payload=json.dumps(data)
        )
        if response['StatusCode'] == 200:
            logger.info("Email sent successfully")
        else:
            logger.error(f"Failed to send email. Status code: {response['StatusCode']}")
    else:
        logger.error("csv_data_in_bytes is null")

# Method to fetch user details
def fetch_user_details(transaction_ids):
    url = os.environ['FETCH_CIN_CIF_BY_REFID_URL']

    headers = header.update_headers({
        'XREF': str(uuid.uuid4()),
        'CHANNELID': 'IB',
        'content-type': 'application/json'
    })

    data = json.dumps(transaction_ids)

    response = boto3.client('lambda').invoke(  # Updated: Use boto3 for Lambda invocation
        FunctionName=url,
        InvocationType='RequestResponse',
        Payload=json.dumps(data)
    )

    if response['StatusCode'] == 200:
        logger.info("User details fetched successfully")
        return response['Payload'].read().decode('utf-8')
    else:
        logger.error(f"Failed to fetch user details. Status code: {response['StatusCode']}")
        return None

# Processor method
def processor(csv_data, s3_file_name):
    user_activity_dict = read_csv(csv_data)
    temp_file_location = "/tmp/output.csv"

    user_ids_list = list(user_activity_dict.keys())
    json_response = fetch_user_details(user_ids_list)

    if json_response:
        update_user_activity_dict(json.loads(json_response), user_activity_dict)
        write_csv(temp_file_location, user_activity_dict)
        file_in_bytes = convert_attachment_in_bytes(temp_file_location)
        send_mail(file_in_bytes, s3_file_name)
    else:
        logger.error("JSON response is null")

if __name__ == '__main__':
    input = r"C:\Users\O25420\Docs\python\test1r.csv"
    processor(input)

------*************************************
#!/usr/bin/env python3
import os
import json
import service.CustomerProfile as customer_profile
import service.EFRService as efr_service
import pbcore.logger as logger
import pbcore.header as header
import pbcore.sslcontext as sslcont
import pbcore.aws.secretstore as secretstore
from enums.EventAction import EventAction
import service.APIGatewayService as api_gateway_service
from enums.EventStatus import EventStatus
import helper.StpValidation as stp_validation
import helper.BpmsProcessor as bpms_processor

LAMBDA_FUNCTION = os.environ.get("AWS_LAMBDA_FUNCTION_NAME")
ENV = os.environ.get("ENVIRONMENT")

'''
    Creation of SSL Context for ssl certificate verification.
    for aws lambda use getsslcontext to get certificates
    for local testing use getsslcontextlocal(environmentname) to get certificate

    Get INTERNAL_GATEWAY_KEY from secret store
'''
if(LAMBDA_FUNCTION is not None):
    ssl_context = sslcont.get_ssl_context()
    INTERNAL_API_KEY = secretstore.get_secret_value('AWS_IBMB_INTERNAL_API_GATEWAY_KEY_'+ ENV)
else:
    ssl_context = sslcont.get_ssl_context_local('uat')
    INTERNAL_API_KEY = 'j60AqcESvkfSDad5NMyy80Xl6fSq0HR6Fvlowjw6'


'''
    Lambda handler for processing the records for kyc upload processor with EFR.
'''
def handler(event,context):
    if event:
        batch_item_failures = []
        sqs_batch_response = {}
        logger.info(f"event received from SQS : {event}")
        sqs_message = event.get("Records")
        if sqs_message is not None and len(sqs_message) > 0:
            for message in sqs_message:
                message_id = message["messageId"]
                #### extracting body from sqs event
                message_body = message["body"]
                message_body = json.loads(message_body)
                final_message_body = message_body["Message"]  
                ##### converting message body to json
                final_message_body = json.loads(final_message_body)
                message_headers = final_message_body["headers"]
                message_data = final_message_body["data"]
                message_headers = header.update_headers(message_headers, message_data)
                logger_data = logger.prepare_logger_data(message_headers, message_data)
                logger.info(f"message id : {message_id}", **logger_data)
                logger.info(f"headers received from SQS: {message_headers}", **logger_data)
                logger.info(f"Data received from SQS: {message_data}", **logger_data)
                try:
                    service_orchestrator(message_data, message_headers, logger_data)
                except Exception as e:
                    logger.error(f'An unexpected error occurred : {e}', **logger_data)
                    batch_item_failures.append({"itemIdentifier": message_id})
            sqs_batch_response["batchItemFailures"] = batch_item_failures
            logger.info(f"sqsBatchResponse: {sqs_batch_response}", **logger_data)
            return sqs_batch_response

'''
    Method to orchestrate Service for EFR and DMS upload
'''
def service_orchestrator(message_data, message_headers, logger_data):
    efr_get_data_response = efr_service.get_efr_data_by_conv_id(message_data, message_headers, logger_data, ssl_context, INTERNAL_API_KEY)
    get_customer_data_from_t24 = customer_profile.get_customer_details_from_t24(message_data, message_headers, logger_data, ssl_context)
    efr_status = message_data.get("efrStatus")
    logger.info(f"EFR Status Code : {efr_status}", **logger_data)
    stp_flag, processed_flag = "N", "N"
    if efr_status == 'EFR_DOCUMENT_UPLOAD_COMPLETED':
        logger.info(f"efrJourneyStatus is : {efr_status}", **logger_data)
        validate_data_for_stp_flow_flag = stp_validation.validate_data_for_stp_flow(efr_get_data_response, get_customer_data_from_t24, logger_data)
        logger.info(f"In case validate data for stp flow is: {validate_data_for_stp_flow_flag}", **logger_data)
        if validate_data_for_stp_flow_flag:
            stp_flag = "Y" 
            api_gateway_service.publish_events_async(message_data, message_headers, logger_data, ssl_context, INTERNAL_API_KEY, EventAction.EFR_DATA_VALIDATION.name, EventStatus.SUCCESS.name, None, None) 
            update_customer_details = customer_profile.update_t24_customer_details(message_data, efr_get_data_response, get_customer_data_from_t24, message_headers, logger_data, ssl_context)
            logger.info(f"Update T24 Customer Details Status : {update_customer_details}", **logger_data)
            # check the status of update customer details service call
            if (update_customer_details == "UPDATE_SUCCESS" 
                or update_customer_details ==  "NO_CUSTOMER_UPDATE"): 
                logger.info(f"After Update Customer Details able to Proceed Processed Flow", **logger_data)
                processed_flag = "Y"
                logger.info(f" STP: {stp_flag}, Processed : {processed_flag}. Get Updated T24 customer Data for {update_customer_details} ", **logger_data)
                bpms_processor.trigger_stp_bpms_posting(stp_flag, processed_flag, efr_get_data_response, get_customer_data_from_t24, message_data, message_headers, logger_data, ssl_context)
            elif isinstance(update_customer_details, dict) :
                logger.info(f" STP: {stp_flag}, Processed : {processed_flag}. Updating T24 customer Data got failed and returned error Code & Description, {update_customer_details}", **logger_data)
                processed_flag = "N"
                bpms_processor.trigger_stp_non_processed_bpms_posting(stp_flag, processed_flag, efr_get_data_response, get_customer_data_from_t24, message_data, message_headers, update_customer_details, logger_data, ssl_context)
            else:
                logger.info(f" STP: {stp_flag}, Processed : {processed_flag}. Updating T24 customer Data got failed and return Error Exception {update_customer_details}", **logger_data)
                # edge case need to clarify
                processed_flag = "N"
                bpms_processor.trigger_stp_non_processed_bpms_posting(stp_flag, processed_flag, efr_get_data_response, get_customer_data_from_t24, message_data, message_headers, None, logger_data, ssl_context)
        #### invoke Notification Service
        else:
           api_gateway_service.publish_events_async(message_data, message_headers, logger_data, ssl_context, INTERNAL_API_KEY, EventAction.EFR_DATA_VALIDATION.name, EventStatus.FAILURE.name, None, None) 
           logger.info(f" STP: {stp_flag}, Processed : {processed_flag}. In case validate data for stp flow is: {validate_data_for_stp_flow_flag}", **logger_data)
           bpms_processor.trigger_non_stp_bpms_posting(stp_flag, processed_flag, efr_get_data_response, get_customer_data_from_t24,message_data, message_headers, logger_data, ssl_context)
    elif efr_status == 'EFR_FAILURE':
        logger.info(f" STP: {stp_flag}, Processed : {processed_flag}. In case EFR Failure", **logger_data)
        bpms_processor.trigger_non_stp_bpms_posting(stp_flag, processed_flag, efr_get_data_response, get_customer_data_from_t24,message_data, message_headers, logger_data, ssl_context)


# if __name__ == '__main__':
#     #event = {'Records': [{'messageId': 'bca38d1e-91a0-4559-9e03-bacd54e2365b', 'receiptHandle': 'AQEBiNg5NYVJVOitF73rWHhUsUTqT0WQgPmMFB38GoKg9UO3LYFxOiXQUp3IdATo38aplxaaiPhGAslrpMWvf1aywJIeaYd/t+UKLyTcweAWM52d9nTeyPf1y2VUq/3Gm4sLXq+y9wxS0PAFHpXf1pWVGkyutKzhO9PxKVWXxO802BKX20UHaA54Myey4bhYsB9jcFbzTb9vOZLDvNMy3Pf2U8K74sUABH8XWgXXr8g9wmpkRzpq3Tk5yHDzv7IK5J9QtLylbEDF/x6X13h6epaYvsEJGpif/CR3AjGRFMKZluHvpCzMgfcIr2Qn0LA1oqfnLAVuK0tBth5VBs0jfuoKOo/VrNFfk8bis6Z+E/eKoM19sJ8U1bj3NLlpyFSu/l4tAtMbMBvt1c7j4CgSpIqLtoee3f9axI8QdVOyMI2v4GU=', 'body': '{\n  "data" : {\r\n    "queueName": "efr-document-upload-uat",\r\n    "convId": "9a583974260e4ca1910bf3bad2e57b02",\r\n    "customerId": "565656",\r\n    "journey": "KYC_UPLOAD",\r\n    "efrJourneyStatus": "SUCCESS",\r\n    "requestedBy": "efr-documnet-upload"\r\n},\n  "headers": {\n        "Accept": "*\\/*" ,\n        "Accept-Encoding": "gzip, deflate, br" ,\n        "Content-Type": "application\\/json" ,\n        "Cookie": "BIGipServervim6a8s0WbVja\\/7YOr9aUg=!VfgFFE 450OTwYtoDqTKsUPsC0Fa4ZR6HMF6dWGJ1zyumrEsQR w3VMX4gewkHOSsutwkgOiaBEzM9A=" ,\n        "Host": "internalretailapi-uat.bankfab.com" ,\n        "Postman-Token": "e4517c87-8496-419a-8d79-64d84418f2a7" ,\n        "User-Agent": "PostmanRuntime\\/7.26.5" ,\n        "x-amzn-cipher-suite": "ECDHE-RSA-AES128-GCM-SHA256" ,\n        "x-amzn-tls-version": "TLSv1.2" ,\n        "x-amzn-vpc-id": "vpc-05bb082fa47361dc5" ,\n        "x-amzn-vpce-config": "1" ,\n        "x-amzn-vpce-id": "vpce-09f935921e24d61d6" ,\n        "x-api-key": "j60AqcESvkfSDad5NMyy80Xl6fSq0HR6Fvlowjw6" ,\n        "x-apigw-api-id": "5n9ib4nxlk" ,\n        "X-Forwarded-For": "10.125.21.105, 172.28.184.78" \n      }\n}', 'attributes': {'ApproximateReceiveCount': '1', 'AWSTraceHeader': 'Root=1-65c6048b-a0f4297b0faa2514efd82c4c', 'SentTimestamp': '1707476108046', 'SenderId': 'AROAXRA5ZLPO6PSCNEQFQ:BackplaneAssumeRoleSession', 'ApproximateFirstReceiveTimestamp': '1707476113046'}, 'messageAttributes': {}, 'md5OfBody': '60bb8acdc77b0127a34d8a86e51d0b80', 'eventSource': 'aws:sqs', 'eventSourceARN': 'arn:aws:sqs:me-central-1:517606038493:efr-document-upload-uat', 'awsRegion': 'me-central-1'}]}
#     event = {'Records': [{'messageId': '1aed51bd-6d0d-49c8-ba93-19a63382e898', 'receiptHandle': 'AQEBXici3zjgwINuGp3ipDB9MRW8LcE82NT6Wf6IH2LwZu75hl1hZkTrB+z7nx6YzJ0DSBTS1ZLkpHKny7cS5XNzUPmrZjJc9vP769qto4+2KFQM5VOKPIwJ8iSom/BMtkZ4gFMg4HFNU88PrzJYAKzhlQQIauwN02FJbdKwl6JWYSKJEj1DEiDMLCxWH52KJiNQMDXfxZxxv9Eol4N9OQiFQ+WjYXlZ1n8t7fIVLvvC2WEJrSWEXMMl/fEauxZWlPf9MYzBzVspSSwg7MWO3jtQsIoMm4mUP0TqbMcqhlANIrXNGyRrwPPEpV2SYvzHNiHA7P5Rir+5egXTw4KYpWc+uIRSlkMiY3bgSaBXAsvhyMorTeACc+3TKGqMoSlegozzflRzlKCdt59Gx9WtBSgEzg==', 'body': '{\n  "Type" : "Notification",\n  "MessageId" : "52b07294-6c2e-5192-a4a1-2cd46afa61ce",\n  "TopicArn" : "arn:aws:sns:me-central-1:517606038493:efr-journey-status-uat",\n  "Message" : "{\\n  \\"data\\" : {\\n    \\"topicName\\": \\"efr-journey-status-uat\\",\\n    \\"convId\\": \\"6119ee087afb4dddbfa98ea2f88fceae\\",\\n    \\"customerId\\": \\"6047331\\",\\n    \\"journey\\": \\"KYC_UPLOAD\\",\\n    \\"efrStatus\\": \\"EFR_DOCUMENT_UPLOAD_COMPLETED\\",\\n    \\"requestedBy\\": \\"EFR_DOCUMENT_UPLOAD-uat\\"\\n},\\n  \\"headers\\": {\\n        \\"Accept\\": \\"*\\\\/*\\" ,\\n        \\"Accept-Encoding\\": \\"gzip, deflate\\" ,\\n        \\"CHANNELID\\": \\"MOB\\" ,\\n        \\"Content-Type\\": \\"application\\\\/json\\" ,\\n        \\"Host\\": \\"internalretailapi-uat.bankfab.com\\" ,\\n        \\"User-Agent\\": \\"python-httpx\\\\/0.24.1\\" ,\\n        \\"x-amzn-cipher-suite\\": \\"ECDHE-RSA-AES128-GCM-SHA256\\" ,\\n        \\"x-amzn-tls-version\\": \\"TLSv1.2\\" ,\\n        \\"x-amzn-vpc-id\\": \\"vpc-05bb082fa47361dc5\\" ,\\n        \\"x-amzn-vpce-config\\": \\"1\\" ,\\n        \\"x-amzn-vpce-id\\": \\"vpce-09f935921e24d61d6\\" ,\\n        \\"x-api-key\\": \\"j60AqcESvkfSDad5NMyy80Xl6fSq0HR6Fvlowjw6\\" ,\\n        \\"x-apigw-api-id\\": \\"5n9ib4nxlk\\" ,\\n        \\"X-Forwarded-For\\": \\"10.74.8.71, 172.28.184.78\\" ,\\n        \\"XREF\\": \\"9a583974260e4ca1910bf3bad2e57b0223462908\\" \\n      }\\n}",\n  "Timestamp" : "2024-02-09T10:55:16.626Z",\n  "SignatureVersion" : "1",\n  "Signature" : "Hxp4yjSVT6QwkGO3rUNLK+mbOxapOSRzUcKijcDlZUI+SEqiamxzg1ApJAbarYFcU47CTVIp62ielp6oTKg/4/pEGlgUnYcImPAEFiFSM9LB+cBaQCSty+pSFEB3zu+ikgRGlan0yob4eMouDKydsgi+iepmZK7DBphmaLjvM9m1kRuvGhpgyuYP0jFHnwyPdPYB6JIEE+XWw+dJJCm7I02Dmv2lhPZwAfNk4XyyAtkCLfuBpU+oeisNfXkSJNoTJGu8Pl0wvszP1oH51pmfyJbaxrbXPBII3J0bFtYwLIS/HBLBWbXR0JIAZQ8cSkkArIL4faDcXCxqWTmy8CLJwQ==",\n  "SigningCertURL" : "https://sns.me-central-1.amazonaws.com/SimpleNotificationService-4feda397066d7d9e786590d8f4f17d7b.pem",\n  "UnsubscribeURL" : "https://sns.me-central-1.amazonaws.com/?Action=Unsubscribe&SubscriptionArn=arn:aws:sns:me-central-1:517606038493:efr-journey-status-uat:405d2cf0-60ba-448d-b0e1-1c7a96944758"\n}', 'attributes': {'ApproximateReceiveCount': '1', 'AWSTraceHeader': 'Root=1-65c60494-7cb0f7abcb364b4922a4f761', 'SentTimestamp': '1707476116759', 'SenderId': 'AIDAXDF67A73FC5KNYUHY', 'ApproximateFirstReceiveTimestamp': '1707476121759'}, 'messageAttributes': {}, 'md5OfBody': 'f073409ea8f86138d405387d0b4a7dd4', 'eventSource': 'aws:sqs', 'eventSourceARN': 'arn:aws:sqs:me-central-1:517606038493:kyc-upload-uat', 'awsRegion': 'me-central-1'}]}
#     # stp_flag  = "N"
#     # processed_flag = "N"
#     # message_headers = {"LANGUAGE": "EN", "XREF":"IEE3DEA38E35C42018BD1AD8835E7", "CHANNELID":"MOB"}
#     # message_data = { "topicName": "efr-journey-status-uat", "convId": "9a583974260e4ca1910bf3bad2e57b02", "customerId": "6047342", "journey": "KYC_UPLOAD", "efrStatus": "EFR_DOCUMENT_UPLOAD_COMPLETED", "requestedBy": "efr-document-upload_uat", "sessionId": "d28551386bc24e5885d4ed7a579c58ff", "deviceID": "3f1667a0-cec7-44e3-8bcc-35d626e45087" }
#     # message_headers = header.update_headers(message_headers, message_data)
#     # logger_data = logger.prepare_logger_data(message_headers, message_data)
# #     efr_get_data_response = efr_service.get_efr_data_by_conv_id(message_data, message_headers, logger_data, ssl_context, INTERNAL_API_KEY)
# #     # get_customer_updated_data_from_t24 = { "applicationArea": { "correlationId": "A55969627811e4ee5833fefde9ef9aa655750758524680", "countryOfOrigin": "AE", "senderId": "MOB", "transactionId": "A55969627811e4ee5833fefde9ef9aa655750758524680", "transactionDateTime": "2024-03-05T12:40:26:523Z", "language": "EN", "creationDateTime": "05/Mar/2024 12:40:26", "requiredExecutionDate": "05/Mar/2024 12:40:26" }, "responseStatus": { "status": "SUCCESS" }, "dataArea": { "fullName": "Adhithyan Jyothy Jyothy Gopinathan Nair Subhadra Amma", "prefix": "MR", "birthDate": "1994-06-28", "gender": "M", "ltGender": "F", "nationality": "IN", "emirate": "AUH", "country": "ABU DHABI, UAE", "maritalStatus": "", "isResident": "Y", "shortName": "Adhithyan Jyothy Jyothy Gopinathan", "customerIdentifier": "6045770", "customerType": "Individual", "customerOpenDate": "2024-01-04", "accountingUnitIdentifier": "AE0010001", "mothersMaidenName": "Lakshmi", "placeOfBirth": "IN", "amlSegment": "LM", "segment": "", "isStaff": False, "employment": { "employerName": "", "employerName2": "ADCOM", "monthlySalary": "30000.00", "employmentStatus": "Employed" }, "additionalCustomerInfo": { "segment": "02", "customerRateSegment": "Mass", "target": "30", "accountOfficer": "178", "language": "1", "startDate": "2024-01-04", "nameOnCard": "ADHITHYAN JYOTHY JYOT", "sector": "4000", "profession": "CLINIC MANAGER", "subSegment": "6201", "relationshipManager": "FGB2353", "vatCategory": "004", "constitution": "", "otherOfficer": [ "", "" ], "country": [ "20", "" ], "customerResidence": [ "AE", "" ], "ownerName": [ "", "" ], "ownerNationality": [ "", "" ], "percentOwner": [ "", "" ], "riskCategory": "", "riskAgreement": "", "relationCustomer": [ "", "" ], "relationCode": [ "", "" ], "reverseRelationCode": [ "", "" ], "customerEducationalBackground": "", "customerAgeClassification": "MAJOR", "powerOfAttorneyFlag": "" }, "kycInfo": { "kycFlag": "FULL", "kycDate": "2024-02-06", "kycExpiryDate": "2027-02-06", "isKYCUsingEID": False }, "identity": [ { "identityType": "EMI", "identityNumber": "784199498780198", "identityExpiryDate": "2024-10-10" }, { "identityType": "VIS", "identityNumber": "20120199366198", "identityExpiryDate": "2024-09-12" }, { "identityType": "PAS", "identityNumber": "P3965511", "identityExpiryDate": "2029-08-27" } ], "address": [ { "addressLine1": "22334455", "addressLine2": "ALFARABI STREET AL AIN", "city": "ABU DHABI, UAE", "country": "20", "postalCode": "" } ], "contacts": [ { "contactType": "PERSONAL", "mobileNumber": "0506256555", "email": "madhura.deshpande3@bankfab.com" }, { "contactType": "OFFICE" } ], "accounts": [ { "accountIdentifier": "1781006045770001", "accountTitle": "PRASANNA KUMAR VELLORE SELVAKUMAR", "postingRestriction": "", "customerIdentifier": "6045770", "currency": "AED", "isActive": True, "branchCode": "178", "powerOfAttorney": "" }, { "accountIdentifier": "1786006045770002", "accountTitle": "ADHITHYAN JYOTHY JYOTHY GOPINATHAN", "postingRestriction": "", "customerIdentifier": "6045770", "currency": "AED", "isActive": True, "branchCode": "178", "powerOfAttorney": "" } ], "FATCA": { "isPoliticalExposed": "NO"   , "isUSPersonForTaxPurpose": False, "socialSecurityNumber": "", "isTaxResidentOtherCountry": False, "isResidentOfOtherJurisdiction": "", "declarationIndicator": False, "reasonForDeclarationDisagree": "", "status": "", "isReportable": False, "otherNationalities": [ "", "" ], "nationality": [ "IN", "" ], "placeOfBirth": "Chittoor", "taxResidencies": [ { "countryJurisdictionOfTaxResident": "AE", "taxIdentificationNumber": "", "reasonIfTINNotAvailable": "A", "comments": "" }, { "countryJurisdictionOfTaxResident": "", "taxIdentificationNumber": "", "reasonIfTINNotAvailable": "", "comments": "" } ] } } }
# #     # get_customer_data_from_t24 = customer_profile.get_customer_details_from_t24(message_data, message_headers, logger_data, ssl_context)
#     # event = {'Records': [{'messageId': 'e3adbe49-5fa8-4541-949e-1aefddf057f7', 'receiptHandle': 'AQEBS4w73FODe0r4kJbZzM6ZNCsGd2fz1ZVPbWOq5vpJyvw9FLiZX3OQTlj0WU1hYlV4CbMKj8GtD3sriPW/DH56yuNavADYM64AsVisCvUht1n+YEqhqEFmebog/MWBTPu714Cu6f+G41sWg6VO0Upl97x0oo/IQ/QCdGH3iIa24oNSsDCgPKRJnvLuYblqVuXZ1QGpNa+qYlWXdn2/46DnS7Rt0U1g4DJNj3NMWaRIDe5TP7lpuYSJkGaRIwdAQ6ZI4st/LhH7eZ4HgQil9XIMvwvXZMuKaTt5Y1ff8zqfLOXCRzy0SgQTSwd1Wtn6QBLGnQDIy+9xoox90vE6RAuJRdwmYFHs2xXBmNRFpklvqpDcFgH0aZn28HXOqaXGbK2MAEjjNhju+lMKEeyYK33tCtPjVuzL9VUEHifbdQzqbxc=', 'body': '{\n  "data" : {\r\n    "queueName": "efr-document-upload-uat",\r\n    "convId": "9a583974260e4ca1910bf3bad2e57b02",\r\n    "customerId": "6046253",\r\n    "journey": "KYC_UPLOAD",\r\n    "efrJourneyStatus": "SUCCESS",\r\n  "sessionId": "12345678",\r\n "deviceID": "1234567",\r\n   "requestedBy": "efr-documnet-upload"\r\n},\n  "headers": {\n        "Accept": "*\\/*" ,\n        "Accept-Encoding": "gzip, deflate, br" ,\n        "CHANNELID": "MOB" ,\n        "Content-Type": "application\\/json" ,\n        "Cookie": "BIGipServervim6a8s0WbVja\\/7YOr9aUg=!oQ81yzQgR F09pkqkmW0s8UFcCcwuwgKTGvsZV 8XCDf0fzMrSlBbCzj3akFLwdTouDC9N6z2bhGD34=" ,\n        "Host": "internalretailapi-uat.bankfab.com" ,\n        "Postman-Token": "5daca6f6-5fbb-404f-a1ea-2c2bfe463d50" ,\n        "User-Agent": "PostmanRuntime\\/7.26.5" ,\n        "x-amzn-cipher-suite": "ECDHE-RSA-AES128-GCM-SHA256" ,\n        "x-amzn-tls-version": "TLSv1.2" ,\n        "x-amzn-vpc-id": "vpc-05bb082fa47361dc5" ,\n        "x-amzn-vpce-config": "1" ,\n        "x-amzn-vpce-id": "vpce-09f935921e24d61d6" ,\n        "x-api-key": "j60AqcESvkfSDad5NMyy80Xl6fSq0HR6Fvlowjw6" ,\n        "x-apigw-api-id": "5n9ib4nxlk" ,\n        "X-Forwarded-For": "10.125.21.100, 172.28.184.78" ,\n        "XREF": "234567898765432" \n      }\n}', 'attributes': {'ApproximateReceiveCount': '7', 'AWSTraceHeader': 'Root=1-65b8e280-afd5a06880a7dd392e9b1ac7', 'SentTimestamp': '1706615425132', 'SenderId': 'AROAXRA5ZLPOZ4TGJQV3G:BackplaneAssumeRoleSession', 'ApproximateFirstReceiveTimestamp': '1706615430132'}, 'messageAttributes': {}, 'md5OfBody': '0d5f8a9517fd72bb857692eeb8e99e04', 'eventSource': 'aws:sqs', 'eventSourceARN': 'arn:aws:sqs:me-central-1:517606038493:efr-document-upload-uat', 'awsRegion': 'me-central-1'}]}
#     res = handler(event, None)
# #     # res = bpms_service.posting_kyc_update(stp_flag, processed_flag, efr_get_data_response, get_customer_data_from_t24, message_data, message_headers, logger_data, ssl_context, None)
# #     print(efr_get_data_response)
# #     # get_customer_updated_data_from_t24 = {"applicationArea":{"correlationId": "I63C0D7A10B384DFC99AF0E01270278584262481102911","countryOfOrigin": "AE","senderId": "MOB","transactionId": "I63C0D7A10B384DFC99AF0E01270278584262481102911","transactionDateTime": "2024-02-29T06:29:02:061Z","language": "EN","creationDateTime": "29/Feb/2024 06:29:02","requiredExecutionDate": "29/Feb/2024 06:29:02"},"responseStatus": {"status": "SUCCESS"},"dataArea": {"fullName": "PRASANNA KUMAR","prefix": "MR","birthDate": "1983-06-24","gender": "M","ltGender": "M","nationality": "IN","emirate": "AUH","country": "ABU DHABI, UAE","maritalStatus": "","isResident": "Y","shortName": "PRASANNA KUMAR VEL SELVAKUMA","customerIdentifier": "6046679","customerType": "Individual","customerOpenDate": "2024-02-26","accountingUnitIdentifier": "AE0010001","mothersMaidenName": "Sujathasiri","placeOfBirth": "IN","amlSegment": "L","segment": "","isStaff": False,"employment": {"employerName": "","employerName2": "AGA","monthlySalary": "30000.00","employmentStatus": "Employed"},"additionalCustomerInfo": {"segment": "","customerRateSegment": "Mass","target": "30","accountOfficer": "178","language": "1","startDate": "2024-02-26","nameOnCard": "","sector": "4000","profession": "Computer Engineer","subSegment": "6201","relationshipManager": "FGB2353","vatCategory": "004","constitution": "","otherOfficer": [""],"country": ["UAE"],"customerResidence": ["AE"],"ownerName": [""],"ownerNationality": [""],"percentOwner": [""],"riskCategory": "","riskAgreement": "","relationCustomer": [""],"relationCode": [""],"reverseRelationCode": [""],"customerEducationalBackground": "","customerAgeClassification": "MAJOR","powerOfAttorneyFlag": ""},"kycInfo": {"kycFlag": "FULL","kycDate": "2024-02-26","kycExpiryDate": "2029-02-26","isKYCUsingEID": False},"identity": [{"identityType": "EMI","identityNumber": "","identityExpiryDate": "2025-04-26"},{"identityType": "VIS","identityNumber": "20120199366198","identityExpiryDate": "2025-09-12"},{"identityType": "PAS","identityNumber": "TC5306","identityExpiryDate": "2029-08-26"}],"address": [{"addressLine1": "22334455","addressLine2": "ALFARABI STREET AL AIN","city": "ABU DHABI, UAE","country": "UAE","postalCode": ""}],"contacts": [{"contactType": "PERSONAL","mobileNumber": "0506256536","email": "sanjiv.kadam@bankfab.com"},{"contactType": "OFFICE"}],"accounts": [{"accountIdentifier": "1786006046679001","accountTitle": "PRASANNA KUMAR VEL SELVAKUMAR","postingRestriction": "","customerIdentifier": "6046679","currency": "AED","isActive": True,"branchCode": "178","powerOfAttorney": ""}],"FATCA": {"isPoliticalExposed": "NO","pepPosition": "None","isUSPersonForTaxPurpose": False,"socialSecurityNumber": "","isTaxResidentOtherCountry": False,"isResidentOfOtherJurisdiction": "","declarationIndicator": False,"reasonForDeclarationDisagree": "","status": "","isReportable": False,"otherNationalities": [""],"nationality": ["IN"],"placeOfBirth": "Chittoor","taxResidencies": [{"countryJurisdictionOfTaxResident": "AE","taxIdentificationNumber": "","reasonIfTINNotAvailable": "A","comments": ""}]}}}
# #     # efr_get_data_response = {"convId": "fed6ac255f554bff8f46a704e44d8612","journey": "KYC_UPLOAD","creationTime": "29-02-2024 10:28:22.415","frontCardScan": "/Z","backCardScan": "//Z","mrz": {"line1": "ILARE1290903011784198783609609\r","line2": "8702230M2504269IND<<<<<<<<<<<7\r","line3": "SELVAKUMARCCPRASANNA<KUMARCVEL","valid": False},"details": {"docIssuingAuthority": "ARE","docNumber": "129090301","docCode": "IL","primaryIdentifier": "SELVAKUMARCCPRASANNA KUMARCVEL","secondaryIdentifiers": "SELVAKUMARCCPRASANNA KUMARCVEL","dateOfBirth": "870223","docExpiryDate": "250426","visualExpiryDate": "250426","gender": "M","nationality": "IND","nationalityIso2": "IN","registrantNumber": "784198783609609"},"cardLayoutType": "2","ttl": 1709360902,"onboardCustomerResponse": {"report": "=","identityCardDetails": {"docType": 0,"docIssuingAuthority": "ARE","docNumber": "129090301","docCode": "IL","primaryIdentifier": "SELVAKUMARCCPRASANNA KUMARCVEL","secondaryIdentifiers": "SELVAKUMARCCPRASANNA KUMARCVEL","dateOfBirth": "1987-02-23","docExpiryDate": "2025-04-26","gender": "M","nationality": "IND","registrantNumber": "784198783609609"}},"efrValidateCustomerProfileResponse": {"data": {"pdfCertificate": "z","jsonReport": {"reportIssueDate": "2024-02-29T10:28:42.9712577+04:00","reportExpiryDate": "2025-02-28T10:28:42.9712601+04:00","identityCardDetails": {"cardCode": "IL","registrantNumber": "784198783609609","cardNumber": "129090301","issueDate": "2023-04-27T00:00:00","expiryDate": "2025-04-26T00:00:00"},"passportDetails": {"passportType": 1,"passportNumber": "TC5306","passportCountryCode": "IND","issuingAuthority": "IND","issueDate": "2019-08-27T00:00:00","expiryDate": "2029-08-26T00:00:00"},"residencyDetails": {"residencyType": {"code": "2","arabicDescription": "اقامة","englishDescription": "Residence"},"residencyNumber": "201/2019/9/366198","issuePlace": "IND","issueDate": "2023-09-13T00:00:00","expiryDate": "2025-09-12T00:00:00"},"personalDetails": {"fullName": "Prasanna Kumar Vel Selvakumar","birthDate": "1987-02-23T00:00:00","nationality": {"code": "IND","arabicDescription": "جمهورية الهند","englishDescription": "INDIA"},"maritalStatus": {"code": "1","arabicDescription": "اعزب","englishDescription": "SINGLE"},"gender": {"code": "M","arabicDescription": "ذكر","englishDescription": "MALE"},"familyBookNumber": "0","placeOfBirth": "India","motherName": "Sujathasiri"},"professionalDetails": {"qualificationLevel": {"code": "6","arabicDescription": "ماجستير","englishDescription": "MASTER"},"occupation": {"code": "1118","englishDescription": "Computer Engineer"},"fieldOfstudyEnglish": {}},"addressDetails": {"addressType": "LOCAL","phoneNumber": "02-123-8888","mobilePhoneNumber": "050-123-8888","emailAddress": "22334455","buildingName": "Falcon Tower","location": {"code": "1","arabicDescription": "ABU DHABI"},"emirate": {"code": "1","arabicDescription": "ABU DHABI"},"city": {"code": "2","englishDescription": "AL AIN"},"area": {"code": "550","arabicDescription": " العين","englishDescription": "AL AIN"},"street": {"code": "24567","arabicDescription": "شارع الفارابى","englishDescription": "AL-FARABI STREET"},"country": {},"pOBox": "22334455"},"sponsorDetails": {"sponsorType": {"code": "9","arabicDescription": "كفيل حكومة / شبه حكومة","englishDescription": "Govt / semi-Govt sponsor"},"name": "ABC CARE LLC","number": "2345767","registrantNumber": "784198421865951","nationalityCode": "IND"}}}},"documentIds": {"EID_EFR_REPORT": "090364178011a34b","EID_FRONT_PAGE": "090364178011a346","EID_EFR_CERTIFICATE": "090364178011a34c","EID_BACK_PAGE": "090364178011a347"}}
# #     # value = validate_data_for_stp_flow(efr_get_data_response=efr_get_data_response,
# #     #                            get_customer_data_from_t24=get_customer_updated_data_from_t24,
# #     #                            logger_data=logger_data)
# #     # print (f"end result : {value}")



import boto3
import csv
import httpx
import json 
import base64
import ssl
import uuid
import logging
import os
import io
from base64 import b64decode
from datetime import datetime
from urllib.parse import unquote

logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Fectching details from env variables
CERT_PASSWORD = os.environ['CERT_PASSWORD']
CLIENT_CERT =  os.environ['CLIENT_CERT']
SERVER_KEY = os.environ['SERVER_KEY']
CA_CERT = os.environ['CA_CERT']

# Defining Constant variables
COMMA_DELIMETER = ','


# Decrypt code should run once and variables stored outside of the function
# handler so that these are decrypted once per container
logger.info(os.environ['AWS_LAMBDA_FUNCTION_NAME'])
PASSWORD = boto3.client('kms').decrypt(
    CiphertextBlob=b64decode(CERT_PASSWORD),
    EncryptionContext={'LambdaFunctionName': os.environ['AWS_LAMBDA_FUNCTION_NAME']}
)['Plaintext'].decode('utf-8')


# PASSWORD = 'p@ssw0rd'
# CLIENT_CERT =  r'C:\Users\O27038\Python\efr-validate-customer-profile\ssl\sit\client.crt'
# SERVER_KEY = r'C:\Users\O27038\Python\efr-validate-customer-profile\ssl\sit\client.key'
# CA_CERT = r'C:\Users\O27038\Python\efr-validate-customer-profile\ssl\sit\certificate.pem'

'''
Creation of SSL Context for ssl certificate verification.
'''
sslcontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
sslcontext.verify_mode = ssl.CERT_REQUIRED
sslcontext.check_hostname = True
sslcontext.load_verify_locations(cafile=CA_CERT)
sslcontext.load_cert_chain(CLIENT_CERT,SERVER_KEY,PASSWORD)

s3_client = boto3.client('s3')

# CSV column mapping with Object fields
csv_column_mapping = {'customerId' :'CIN' , 'cif' :  'CIF', 'fullName' : 'CM Name', 'target' : 'Target Code', 'segment' : 'Business Segment', 'accountOfficer' : 'Branch', 'relationshipManager' : 'RM', 'nationality' : 'Nationality', 'login_attempts':'Total Login Attempts', 'no_of_days':'Login Period (no. of Days)'}


# Lambda handler
def handler(event,content):
    logger.info(f"event received from S3 : {event}")
    s3_bucket = event['Records'][0]['s3']['bucket']['name']
    s3_key = event['Records'][0]['s3']['object']['key']
    s3_key = unquote(s3_key)
    logger.info(f"Unquote S3 key : {s3_key}")
    response = s3_client.get_object(Bucket=s3_bucket,Key=s3_key)
    csv_content = response['Body'].read().decode('utf-8')
    processor(io.StringIO(csv_content), s3_key)

# Method to read S3 file content and calulate login attempts and number of days
# also this method will right S3 file content on temp location
def read_csv(csv_data):
    user_activity_dict = {}
    data = []
    reader = csv.reader(csv_data)
    header = next(reader,None)
    data.append(header)
    for row in reader:
        if row:
            rawTime = row[2].split('.')
            row[2]= ' '+ rawTime[0] +''
        data.append(row)
        user_id = row[0].strip()
        if user_id not in user_activity_dict:
            unique_transaction_date = set()
            unique_transaction_date.add(row[2].strip().split(' ')[0])
            user_activity_dict[user_id] = {'transaction_date' : unique_transaction_date, 'no_of_days' : 0, 'login_attempts' : 0}
            transaction_type = row[5].strip()
            if transaction_type.lower().find('login') != -1:
                user_activity_dict[user_id]['no_of_days'] = user_activity_dict[user_id]['no_of_days'] + 1
                user_activity_dict[user_id]['login_attempts'] = user_activity_dict[user_id]['login_attempts'] + 1
        else:
            transaction_date = user_activity_dict[user_id]['transaction_date']
            transaction_type = row[5].strip()
            if transaction_type.lower().find('login') != -1:
                if row[2].strip().split(' ')[0] not in transaction_date:
                    transaction_date.add(row[2].strip().split(' ')[0])
                    user_activity_dict[user_id]['no_of_days'] = user_activity_dict[user_id]['no_of_days'] + 1
                    user_activity_dict[user_id]['login_attempts'] = user_activity_dict[user_id]['login_attempts'] + 1
                else:
                    user_activity_dict[user_id]['login_attempts'] = user_activity_dict[user_id]['login_attempts'] + 1        
    with open('/tmp/output.csv','w',newline='') as outputFile:
        writer = csv.writer(outputFile)
        writer.writerows(data)
    logger.info("CSV files is copied at temp location")
    return user_activity_dict


# Method is used to prepare dictionary for user details.
# key is user_name and value is complete details related to column
def update_user_activity_dict(user_details,dict):
    userlist = user_details.get('userList',[])
    userlist_map = {next(iter(item.keys())):next(iter(item.values())) for item in userlist}
    for map_values in userlist_map:
        values = dict[map_values]
        values["customerId"] = userlist_map[map_values]["customerId"]
        values["cif"] = userlist_map[map_values]["cif"]
        json_reponse = get_customer_data(userlist_map[map_values]["customerId"])
        try:
            values["fullName"] = json_reponse["dataArea"]["fullName"]
            values["target"] = json_reponse["dataArea"]["additionalCustomerInfo"]["target"]
            values["segment"] = json_reponse["dataArea"]["additionalCustomerInfo"]["segment"]
            values["accountOfficer"] = json_reponse["dataArea"]["additionalCustomerInfo"]["accountOfficer"]
            values["relationshipManager"] = json_reponse["dataArea"]["additionalCustomerInfo"]["relationshipManager"]
            values["nationality"] = json_reponse["dataArea"]["nationality"]
        except:
            logger.info(f"Error in parsing JSON response : {json_reponse}")


# Method is used to update CSV content and write data back to temp location        
def write_csv(temp_file_location, user_activity_dict):
    with open(temp_file_location,'r') as file:
        csv_data =  list(csv.DictReader(file))
        for row in csv_data:
            row_key = row.get('USER_NAME')
            values = user_activity_dict.get(row_key)
            if values:
                for json_key,csv_column in csv_column_mapping.items():
                    row[csv_column] = values.get(json_key,row.get(csv_column))          
    fieldnames = ['USER_NAME','USER_ID','TIMESTAMP','TRANSACTION_ID','IP_ADDRESS','TRANSACTION_TYPE','COUNTRY', 'CIN' , 'CIF' , 'CM Name' , 'Target Code' , 'Business Segment' , 'Branch' , 'RM' , 'Nationality' , 'Total Login Attempts' , 'Login Period (no. of Days)']
    with open(temp_file_location,'w',newline='') as outputFile:
        writer = csv.DictWriter(outputFile,fieldnames=fieldnames)
        writer.writeheader()
        logger.info(f"file open as writer {csv_data}")
        writer.writerows(csv_data)


# Method is used to send email
def send_mail(csv_data_in_bytes, s3_file_name):
    if csv_data_in_bytes is not None:
        currectDate = datetime.now().date()
        email_subject = "Sanctioned country report_" + currectDate.strftime("%Y-%m-%d")
        split_array = s3_file_name.split('/')
        s3_file_name=split_array[-1]
        s3_file_name = s3_file_name.replace(':','_')
        url = os.environ['SEND_EMAIL_SERVICE_URL']
        headers = {'XREF': str(uuid.uuid4()), 'CHANNELID': 'AWS', 'content-type': 'application/json'}

        # Split the TO_ADDRESS environment variable into a list of email addresses
        to_address_list = os.environ['TO_ADDRESS'].split(COMMA_DELIMETER)

        data = {
            "sourceSystem": "FAB",
            "requestID": str(uuid.uuid4()),
            "fromAddress": "noreply@bankfab.com",
            "entityName": "FAB",
            "toAddress": to_address_list,
            "emailSubject": email_subject,
            "emailBodyContent": "",
            "emailBodyContentType": "TEXT",
            "attachment": [{
                "attachementBytes": str(csv_data_in_bytes.decode("utf-8")),
                "mimeType": "application/csv",
                "fileName": s3_file_name
            }]
        }

        data = json.dumps(data)
        response = httpx.post(url, headers=headers, data=data, verify=sslcontext)
        if response.status_code == 200:
            logger.info("Email sent successfully")
        else:
            logger.info(f"Failed to send email. Status code: {response.status_code}")
        logger.info(f'Email API Response: {response.text}')
    else:
        logger.info("csv_data_in_bytes is null.")
    

def convert_attachment_Inbytes(file_path):
    new_csv = None
    with open(file_path,'r') as file:
        new_csv = base64.b64encode(file.read().encode('utf-8'))
    return new_csv

# Method is used to fetch CIN and CIF based on reference id
def fetch_user_Details(transactionIds):
    url= os.environ['FETCH_CIN_CIF_BY_REFID_URL']
    headers = {'XREF': str(uuid.uuid4()), 'CHANNELID': 'IB','content-type':'application/json'}
    data = json.dumps(transactionIds)
    response = httpx.post(url,headers=headers, data=data, verify = False)
    logger.info("Fetching details from DB.")
    if response.status_code == 200:
        logger.info("PB db response received.")
        return response.text
    else:
        logger.info(f"error response : {response.status_code}")
        return None


# Method to fetch customer data based on CIN
def get_customer_data(cin):
    url= os.environ['GET_CUSTOMER_DETAILS']
    xref = str(uuid.uuid4())
    headers = {'XREF': xref, 'CHANNELID': 'IB','LANGUAGE':'EN'}
    currectDate = datetime.now()
    data = {
    "applicationArea": {
        "countryOfOrigin": "AE",
        "creationDateTime": str(currectDate),
        "requiredExecutionDate": str(currectDate),
        "senderId": "IB",
        "transactionDateTime": str(currectDate),
        "transactionId": xref,
        "language": "EN"
    },
    "dataArea": {
        "customerIdentifier": cin,
        "accountingUnitIdentifier": "AE0010001"
    }
    }
    data = json.dumps(data)
    response = httpx.post(url,headers=headers, data=data, verify = sslcontext)
    json_reponse = response.json()
    if response.status_code == 200:
        logger.info(f"Customer detail response received for CIN : {cin}")
        return json_reponse
    else:
        logger.info(f"Customer detail Error response received for CIN : {cin}")
        return None

def processor(csv_data, s3_file_name):
    user_activity_dict = read_csv(csv_data)
    temp_file_location = "/tmp/output.csv"
    userIdsList = list(user_activity_dict.keys())
    json_reponse = fetch_user_Details(userIdsList)
    if json_reponse is not None:
        update_user_activity_dict(json.loads(json_reponse),user_activity_dict)
        write_csv(temp_file_location, user_activity_dict)
        file_Inbytes = convert_attachment_Inbytes(temp_file_location)
        send_mail(file_Inbytes, s3_file_name)
    else:
        logger.info(f'Json response is null.')

if __name__ == '__main__':
    input = r"C:\Users\O25420\Docs\python\test1r.csv"
    processor(input)



title accesscontrol/cred/v3/verify Flow

User ->> System: Verify Login Request (v3)
System ->> SessionContext: Get Session Details (cif, deviceID, convID)
SessionContext -->> System: Session Details
System ->> ChannelInfoRepository: Fetch Channel Info (cif, channelType)
ChannelInfoRepository -->> System: Channel Info
System ->> ChannelValidator: Validate Channel Info
ChannelValidator -->> System: Validation Success

alt Browser Login
    System ->> UserChannelRepository: Get User Channel (cif, channelType)
    UserChannelRepository -->> System: User Channel
    System ->> PwdHelper: Match Password
    PwdHelper -->> System: Password Matched
    System ->> mqNotifier: Refresh Customer Position Cache
end

alt Mobile Login
    System ->> UserChannelRepository: Get User Channel by User ID and Device ID
    UserChannelRepository -->> System: User Channel
    System ->> PwdHelper: Match Password
    PwdHelper -->> System: Password Matched

    alt Status is ACTIVE_PENDING_LOGIN
        System ->> UserChannel: Update Status to ACTIVE
        System ->> UserChannelRepository: Save Updated User Channel
    end
end

System ->> RiskSF: Evaluate Risk for Login
RiskSF -->> System: Risk Evaluation Response

alt Risk Allowed
    System ->> SessionRepository: Update Verification Status
    SessionRepository -->> System: Verification Success
end

System -->> User: Return Success Response


/////////////////////////////////////
title accesscontrol/cred/v4/verify Flow

User ->> System: Verify Login Request (v4)
System ->> SessionContext: Get Session Details (cif, deviceID, convID)
SessionContext -->> System: Session Details
System ->> ChannelInfoRepository: Fetch Channel Info (cif, channelType)
ChannelInfoRepository -->> System: Channel Info
System ->> ChannelValidator: Validate Channel Info
ChannelValidator -->> System: Validation Success

System ->> UserChannelRepository: Get User Channel by User ID and Device ID
UserChannelRepository -->> System: User Channel

System ->> CsTransactionSF: Send OTP Transaction Request
CsTransactionSF -->> System: OTP Transaction Response

alt OTP Success and Allow
    System ->> UserChannel: Check Status
    alt Status is ACTIVE_PENDING_LOGIN and Mobile
        System ->> UserChannel: Update Status to ACTIVE  // Fix added in v4
        System ->> UserChannelRepository: Save Updated User Channel  // Fix added in v4
    end
    System ->> SessionRepository: Update Verification Status
    SessionRepository -->> System: Verification Success
end

alt OTP Failure
    System ->> VerifyUserLoginSF: Update Channel and Access Info (Failure)
    System ->> AppException: Throw Error (OTP Failed)
end

System -->> User: Return VerifyUserLoginResponse (Success/Failure)

,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Key Differences Highlighted in the Sequence Diagrams:
Channel-Specific Logic:

v3: Differentiates clearly between BROWSER and MOBILE login. For browsers, it refreshes customer position and may bypass certain checks. For mobile, it has explicit logic to handle ACTIVE_PENDING_LOGIN to ACTIVE status updates.
v4: No differentiation between browser and mobile channels in terms of customer position refresh or custom channel-specific logic. The primary focus is on handling OTP verification for all channels.
Password Matching:

v3: Contains explicit logic for password matching depending on the user's channel (e.g., browser or mobile).
v4: Does not have explicit password matching logic; the method relies heavily on the OTP transaction to validate the user's login.
Risk Evaluation:

v3: Includes risk evaluation, using a separate service (RiskSF) to decide if the login should proceed or require additional verification.
v4: Simplifies risk management by relying on the OTP transaction's outcome (CsTransactionSF). If the OTP is validated, the login proceeds; otherwise, it fails.
Fix to Handle ACTIVE_PENDING_LOGIN Status:

v3: Always checks if a mobile user's status is ACTIVE_PENDING_LOGIN and updates it to ACTIVE upon successful login.
v4: Originally missed this status update logic, but the fix introduces a check for ACTIVE_PENDING_LOGIN and updates it to ACTIVE after a successful OTP validation for mobile users.
OTP-Based Transaction Handling:

v3: Does not emphasize OTP transactions as much as v4, relying more on password validation and risk evaluation.
v4: Relies heavily on the OTP transaction's result (CsTransactionSF), making OTP validation the central part of the login process.
Summary:
The diagrams highlight the different approaches between v3 and v4 in handling login verification. v3 has more custom logic for channel-specific scenarios and password handling, while v4 is more streamlined, focusing primarily on OTP validation. The fix in v4 ensures that the status update from ACTIVE_PENDING_LOGIN to ACTIVE is properly handled, similar to how it was done in v3.

-----------------------------------------------
title Verify Login Flow (accesscontrol/cred/v3/verify)

User ->> System: Verify Login Request
System ->> SessionContext: Get session details (cif, deviceID, convID)
SessionContext -->> System: Session details
System ->> ChannelInfoRepository: Fetch Channel Info (cif, channelType)
ChannelInfoRepository -->> System: Channel Info
System ->> ChannelValidator: Validate Channel Info
ChannelValidator -->> System: Validation Success

alt Browser Login
    System ->> UserChannelRepository: Get User Channel (cif, channelType)
    UserChannelRepository -->> System: User Channel
    System ->> PwdHelper: Match Password
    PwdHelper -->> System: Password Match Status
end

alt Mobile Login
    System ->> UserChannelRepository: Get User Channel by User ID and Device ID
    UserChannelRepository -->> System: User Channel
    System ->> PwdHelper: Match Password
    PwdHelper -->> System: Password Match Status
end

alt Password Matched
    System ->> UserChannel: Check if Status is ACTIVE_PENDING_LOGIN
    UserChannel -->> System: Status ACTIVE_PENDING_LOGIN
    System ->> UserChannel: Update Status to ACTIVE
    System ->> UserChannelRepository: Update User Channel
    UserChannelRepository -->> System: Update Success
end

System ->> SessionRepository: Update Verification Status
SessionRepository -->> System: Update Success
System -->> User: Return Success Response


Explanation of the Diagram:
1.	User Interaction: The user initiates the process by sending a login verification request to the system.
2.	Fetching Details: The system retrieves necessary session and channel information, then validates it.
3.	Password Matching: Depending on whether the user is logging in via a browser or mobile device, the system checks the stored password against the one provided.
4.	Handling Mobile Login: If the user is logging in via a mobile device and their status is ACTIVE_PENDING_LOGIN, the system updates their status to ACTIVE.
5.	Session Update and Response: After successful verification, the system updates the session status and sends a success response back to the user.
This should give you a clearer picture of how the verify method processes login verification requests!


title Verify Login Flow (accesscontrol/cred/v4/verify)

User ->> System: Verify Login Request
System ->> SessionContext: Get session details (cif, deviceID, convID)
SessionContext -->> System: Session details
System ->> ChannelInfoRepository: Fetch Channel Info (cif, channelType)
ChannelInfoRepository -->> System: Channel Info

alt Channel Info Missing
    System ->> AppException: Throw Error (Invalid Condition)
end

System ->> ChannelValidator: Validate Channel Info
ChannelValidator -->> System: Validation Success
System ->> ChannelValidator: Verify Device ID Match
ChannelValidator -->> System: Device Match Success

System ->> UserChannelRepository: Fetch User Channel by CIF and Device ID
UserChannelRepository -->> System: User Channel

System ->> CsTransactionSF: Send OTP Transaction Request
CsTransactionSF -->> System: OTP Transaction Response

alt Transaction Success and Allow
    System ->> VerifyUserLoginResponse: Enrich Success Response
    System ->> SessionRepository: Update Session Status
    SessionRepository -->> System: Update Success
end

alt Transaction Failure
    System ->> VerifyUserLoginSF: Update Channel and Access Info (Failure)
    System ->> AppException: Throw Error (Transaction Failed)
end

System -->> User: Return VerifyUserLoginResponse (Success/Failure)

1.	User Interaction: The user starts the process by sending a login verification request.
2.	Fetching Details: The system fetches session details (CIF, device ID, conversation ID) and validates the user’s channel and device.
3.	Handling Missing Data: If the channel info is missing, an error is thrown, and the process stops.
4.	Processing OTP Transaction: The system processes the OTP transaction and checks if it’s successful.
5.	Success Flow: If the transaction is allowed, the system enriches the response and updates the session status.
6.	Failure Flow: If the transaction fails, the system updates the channel with failure status and throws an error.
7.	Returning the Response: Finally, the system returns the result of the login process, indicating success or failure.
This step-by-step breakdown and flow diagram should give you a clearer understanding of how the verify method processes the login request in version 4.

Let's explain the fix for accesscontrol/cred/v4/verify step by step and draw the corresponding sequence diagram, highlighting the fix.
Step-by-Step Explanation of the Fix
Problem Recap:
•	In accesscontrol/cred/v3/verify, the system changes the user’s channel status from ACTIVE_PENDING_LOGIN to ACTIVE after a successful login for mobile users.
•	However, in accesscontrol/cred/v4/verify, this status change logic is missing. So, users in the ACTIVE_PENDING_LOGIN state don’t get their status updated to ACTIVE after logging in, causing issues like not being able to delink devices.
Fix Description:
To fix this, we need to introduce the missing logic from v3 to v4. This will ensure that after a successful login, the user’s channel status is updated from ACTIVE_PENDING_LOGIN to ACTIVE.
Step-by-Step Flow of the Fix:
1.	Check for Success:
o	After verifying the OTP transaction (transactionWithOtp.getResult().isSuccess()), we check if the decision from the OTP service is ALLOW. This indicates a successful login.
2.	Add the Status Update Logic:
o	If the login is successful and the user's userChannel status is ACTIVE_PENDING_LOGIN (which indicates the user had initiated a PIN reset or similar flow), we update the user’s status to ACTIVE.
3.	Persist the Change:
o	After updating the status, we save the updated userChannel back into the repository so that the status change is reflected in the database.
4.	Continue the Normal Flow:
o	The method proceeds with enriching the login response and updating the session verification status as it normally would after a successful login.
title Verify Login Flow with Fix (accesscontrol/cred/v4/verify)

User ->> System: Verify Login Request
System ->> SessionContext: Get session details (cif, deviceID, convID)
SessionContext -->> System: Session details
System ->> ChannelInfoRepository: Fetch Channel Info (cif, channelType)
ChannelInfoRepository -->> System: Channel Info

alt Channel Info Missing
    System ->> AppException: Throw Error (Invalid Condition)
end

System ->> ChannelValidator: Validate Channel Info
ChannelValidator -->> System: Validation Success
System ->> ChannelValidator: Verify Device ID Match
ChannelValidator -->> System: Device Match Success

System ->> UserChannelRepository: Fetch User Channel by CIF and Device ID
UserChannelRepository -->> System: User Channel

System ->> CsTransactionSF: Send OTP Transaction Request
CsTransactionSF -->> System: OTP Transaction Response

alt Transaction Success and Allow
    System ->> VerifyUserLoginResponse: Enrich Success Response
    
    alt UserChannel Status is ACTIVE_PENDING_LOGIN and Mobile
        System ->> UserChannel: Update Status to ACTIVE  // <-- Fix
        System ->> UserChannelRepository: Save Updated UserChannel  // <-- Fix
        UserChannelRepository -->> System: Update Success  // <-- Fix
    end

    System ->> SessionRepository: Update Session Status
    SessionRepository -->> System: Update Success
end

alt Transaction Failure
    System ->> VerifyUserLoginSF: Update Channel and Access Info (Failure)
    System ->> AppException: Throw Error (Transaction Failed)
end

System -->> User: Return VerifyUserLoginResponse (Success/Failure)

Explanation of the Diagram:
1.	Normal Flow:
o	The flow begins with the user sending a login verification request. The system fetches the session details, channel information, and user channel data, followed by validating the device and channel information.
2.	Processing OTP Transaction:
o	The system processes the OTP transaction and checks if the result is successful.
3.	Fix Applied:
o	After a successful OTP transaction, the system checks if the user’s status is ACTIVE_PENDING_LOGIN and if the user is logging in from a mobile device.
o	If both conditions are met, the system updates the user’s channel status to ACTIVE and saves this change to the database.
4.	Final Steps:
o	The system proceeds with enriching the login response, updating the session verification status, and returning a success response to the user.
Conclusion:
The fix ensures that when a mobile user logs in successfully, their channel status is updated from ACTIVE_PENDING_LOGIN to ACTIVE. This prevents issues such as the user not being able to delink their device later. The fix follows the existing flow and only adds a check and an update when required.


Solution 
public VerifyUserLoginResponse verify(VerifyUserLoginRequest request) {
    VerifyUserLoginResponse response = new VerifyUserLoginResponse();
    return execute(request, response, req ->{
        log.info("Verify callsign transaction is success or not.");
        
        SessionInfo session = SessionContext.getSession();
        String cif = session.getUserId();
        String deviceID = session.getDeviceID();
        String convID = session.getConvID();
        ChannelType channelType = session.getChannelType();
        log.info("verify call Cif:{}, Origin:{}, ChannelType:{}, convID:{}", cif, session.getUser()==null? null: session.getUser().getUserOrigin(), channelType, convID);
        
        ChannelInfo channelInfo  = channelInfoRepository.fetchChannelInfoByChannelUserId(channelType.name(), cif);
        if (Objects.isNull(channelInfo)){
            log.error("Inconsistent data.. User data exists in USER_CHANNEL but not in CHANNEL_INFO table. for CIF:{} and channel:{}", cif, channelType);
            throw new AppException(ErrorCodes.SYS_INVALID_CONDITION,false);
        }
        channelValidator.validateChannelInfo(channelInfo, channelType);
        channelValidator.verifyCifDeviceMatch(request.getDeviceID(), cif, deviceID);
        
        UserChannel userChannel = userChannelRepository.fetchUserChannelByUserIDAndDeviceIDActive(cif, deviceID);
        
        CsTransactionResponse transactionWithOtp = csTransactionSF.transactionWithOtp(request.getCsTransactionRequest());
        mapCSResponse(response, transactionWithOtp);
        
        if(transactionWithOtp.getResult().isSuccess() &&
                transactionWithOtp.getEtgTransactionResponse().getDecision() == DecisionEnum.ALLOW) {
            log.info("Transaction verification is successful with callsign.. enrich verify response...");
            String cin = session.getUser().getCin();
            enrichSuccessResponse(request, response, cif, cin, deviceID, convID, channelType, channelInfo, userChannel);
            
            // Add logic to update userChannel status from ACTIVE_PENDING_LOGIN to ACTIVE
            if (ChannelStatus.ACTIVE_PENDING_LOGIN == userChannel.getStatus() && channelType == ChannelType.MOBILE) {
                log.info("Bypassing RBA call for only Mobile device and ACTIVE_PENDING_LOGIN status");
                userChannel.setStatus(ChannelStatus.ACTIVE);
                userChannelRepository.updateUserChannel(userChannel);
            }
            
        } else {
            if(!transactionWithOtp.getResult().isSuccess()) {
                verifyUserLoginSF.updateChannelAndAccessInfo(false, userChannel, channelInfo);
                throw new AppException(ErrorCodes.valueOf(transactionWithOtp.getResult().getErrorInfo().getCode()));
            }
        }
        return response;
    });
}



To ensure that the fix works correctly and doesn't introduce new issues, you can perform a series of positive and negative test cases. Here's a breakdown of the use cases to validate both positive and negative testing after applying the fix to accesscontrol/cred/v4/verify.
Positive Test Cases:
1.	Successful Mobile Login with ACTIVE_PENDING_LOGIN Status:
o	Scenario: A user with ACTIVE_PENDING_LOGIN status logs in from a mobile device.
o	Expected Outcome: The user's channel status should be updated to ACTIVE, and the login should succeed. The user should be able to see their device in the managed device list and perform delinking if necessary.
2.	Successful Mobile Login with ACTIVE Status:
o	Scenario: A user with an ACTIVE status logs in from a mobile device.
o	Expected Outcome: The login should succeed without any changes to the status. The user should have normal access to all functionalities.
3.	Successful Browser Login with ACTIVE_PENDING_LOGIN Status:
o	Scenario: A user with ACTIVE_PENDING_LOGIN status logs in from a browser.
o	Expected Outcome: The user's channel status should not change (remain ACTIVE_PENDING_LOGIN), and the login should succeed.
4.	Successful Browser Login with ACTIVE Status:
o	Scenario: A user with an ACTIVE status logs in from a browser.
o	Expected Outcome: The login should succeed without any changes to the status. The user should have normal access to all functionalities.
5.	Successful OTP Transaction:
o	Scenario: A user initiates a login process that requires OTP validation, and the OTP is successfully validated.
o	Expected Outcome: The login process completes successfully, and any necessary status updates occur as per the fix.
Negative Test Cases:
1.	Failed Login Due to Incorrect Password:
o	Scenario: A user with ACTIVE_PENDING_LOGIN status tries to log in from a mobile device but enters an incorrect password.
o	Expected Outcome: The login should fail, and the user's channel status should remain ACTIVE_PENDING_LOGIN.
2.	Failed OTP Transaction:
o	Scenario: A user initiates a login process that requires OTP validation, but the OTP transaction fails (e.g., OTP is incorrect or expired).
o	Expected Outcome: The login process should fail, the user’s channel status should not change, and an appropriate error message should be returned.
3.	Login with Invalid Channel Information:
o	Scenario: The user’s channel information in the database is corrupted or missing.
o	Expected Outcome: The login process should throw an AppException with the appropriate error code indicating invalid channel information.
4.	Login with Device Mismatch:
o	Scenario: A user tries to log in from a device that does not match the stored device ID in their UserChannel.
o	Expected Outcome: The login should fail, and the user's channel status should remain unchanged.
5.	Login Attempt After Session Expiry:
o	Scenario: A user tries to log in after their session has expired.
o	Expected Outcome: The login should fail, and the system should prompt the user to re-authenticate.
6.	Edge Case - Multiple Login Attempts in Quick Succession:
o	Scenario: A user with ACTIVE_PENDING_LOGIN status attempts to log in from a mobile device multiple times in quick succession, possibly with some attempts failing and some succeeding.
o	Expected Outcome: Only successful login attempts should change the status to ACTIVE. Failed attempts should not alter the status. The system should handle concurrent updates correctly without leaving the user in an inconsistent state.
Validation Criteria:
•	Status Update Validation: After each successful mobile login where the user initially had ACTIVE_PENDING_LOGIN status, verify that the status is updated to ACTIVE in the database.
•	Response Validation: Ensure that the correct response is sent back to the user, indicating whether the login was successful or not.
•	Error Handling: Ensure that errors are correctly handled and that appropriate exceptions are thrown and caught where necessary.
•	Data Integrity: Check the integrity of the UserChannel data before and after the login process, ensuring that only the necessary changes are made.
Post-Fix Validation Process:
1.	Unit Testing:
o	Write unit tests for the verify method to cover all the above scenarios. Mock dependencies like UserChannelRepository, CsTransactionSF, etc., to simulate different outcomes.
2.	Integration Testing:
o	Test the full integration of the fix in the real environment with actual data to ensure that the fix works end-to-end without affecting other parts of the application.
3.	User Acceptance Testing (UAT):
o	Conduct UAT with real users or testers to simulate real-world scenarios, especially focusing on mobile login flows with the ACTIVE_PENDING_LOGIN status.
By performing these positive and negative test cases, you can be confident that the fix is correctly implemented and doesn't introduce new issues.





When the customer tries to update /forget the pin in the login page.
We can observer that the user_channel status gets change to ACTIVE_LOGIN_PENDING, 

And when the cm tries to login ,still customer user channel status will be ACTIVE_LOGIN_PENDING and 
when the customer checks in managed device list, The ACTIVE_LOGIN_PENDING device won’t be visible to delink.

Due to the SQL query : where the query pick’s only ACTIVE status devices to delink  
SELECT LAST_LOGIN_SUCCESS,CREATE_DATE,DEVICE_ID,DEVICE FROM ibmbuser.USER_CHANNEL WHERE cif='1003433232' AND channel_id='MOBILE' AND status='ACTIVE';

Previously the logic
in accesscontrol/cred/v3/verify (VerifyUserLoginSF)
We had logic of making the user channel status ACTIVE_LOGIN_PENDING  ACTIVE when the customer login’s in successfully.


But in the new implementation ,
accesscontrol/cred/v4/verify( VerifyUserLoginV2SF)
we don’t have that logic to make user channel status ACTIVE_LOGIN_PENDING  ACTIVE .

Version 3

   /**
	 * Verify Login Credentials
	 * USAGE: LOGIN,REGISTRATION (LAST STEP)
	 * @param request
	 * @return VerifyUserLoginResponse
	 */
	//@Interceptors(TracingInterceptor.class)
	public VerifyUserLoginResponse verify(VerifyUserLoginRequest request, boolean isPayit) {
		VerifyUserLoginResponse verifyUserLoginResponse = new VerifyUserLoginResponse();
		return  execute(request,verifyUserLoginResponse, req->{
			verifyUserLoginResponse.setCurrentDate(DateTimeHelper.INSTANCE.formatDate(new Date(), AppConstants.DATE_DDMMYYYY));
			SessionInfo session = SessionContext.getSession();
			String cif = session.getUserId();
			String deviceID = session.getDeviceID();
			String convID = session.getConvID();
			ChannelType channelType = session.getChannelType();
			log.info("verify call Cif:{}, Origin:{}, ChannelType:{}, convID:{}", cif, session.getUser()==null? null: session.getUser().getUserOrigin(), channelType, convID);

			ChannelInfo channelInfo  = channelInfoRepository.fetchChannelInfoByChannelUserId(channelType.name(), cif);
			channelValidator.validateChannelInfo(channelInfo, channelType);

			boolean pwdMatched = false;
			UserChannel userChannel = null;
			// String status = null;
			//boolean isCallsignEnabledForPublic = settingsRepository.isCallsignAuthPublicEnabled();
			//boolean isCallsignEnabledForCust = channelInfoRepository.isCallsignAuthEnabled(cif);
			if(ChannelType.BROWSER == channelType) {
				checkTrottle();
				userChannel = getUserChannel(cif, channelType);
				if(Objects.nonNull(userChannel)) {
					// Load Customer position
					mqNotifier.refreshCustomerPositionCache(userChannel.getCin());
				}

				/* Commented below code for PRM-2076
				 * if(ChannelStatus.ACTIVE_PENDING_LOGIN == userChannel.getStatus()) {
					if(session.getUser().getUserOrigin() == UserOrigin.NBAD){
						String username = null;
						if(StringUtils.isNotBlank(userChannel.getUserName())){
							username = userChannel.getUserName();
						}else{
							log.warn("Username is not present in migrated NBAD customer data to authenticate");
							username = request.getUserName();							
						}
						status = nbadUserAuthServiceInvoker.authenticateNbadUser(username, request.getPwd1());
						pwdMatched = AppConstants.SUCCESS.equals(status)?true:false;
						log.info("NBAD PWD status check completed :{}",pwdMatched);
						
					} else if (session.getUser().getUserOrigin() == UserOrigin.FGB){
						String diPwd = channelInfoRepository.fetchDiUserId(cif);
						pwdMatched =  Objects.isNull(userChannel.getPwd()) ? false : PwdHelper.matchDigests(request.getPwd1(), diPwd);
						if(pwdMatched){
							status = AppConstants.SUCCESS;
						}
						log.info("FGB PWD status check completed :{}",pwdMatched);
					}
					
					if(Objects.nonNull(status ) &&AppConstants.SUCCESS.equalsIgnoreCase(status)) {
						verifyUserLoginResponse.setStartPage(FORCE_PASSWORD_UPDATE_FLOW);
						pwdMatched = true;
					}
				} else {*/
					pwdMatched =  Objects.isNull(userChannel.getPwd()) ? false : PwdHelper.match(userChannel.getPwd(), request.getPwd());
				//}
				
				if(pwdMatched){
					checkUsernameConstraints(verifyUserLoginResponse, userChannel);
					preferencesRepository.updateUserAlertPreference(cif, ContentID.LOGIN_SUCCESS.name(), false, EMAIL);
				}
			// Mobile device
			} else {
				//channelValidator.isForceAppUpdateRequired(session);
				userChannel = userChannelRepository.fetchUserChannelByUserIDAndDeviceIDActive(cif, deviceID);
				
				//FMDB-47518-changes
				
				if(Objects.nonNull(userChannel) && Objects.nonNull(request.getPushSettings())) {
						log.info("Populating the Push Settings value");
						userChannel.setPushSettings(request.getPushSettings());
				}
				//FMDB-47518-changes end
				
				channelValidator.verifyCifDeviceMatch(request.getDeviceID(), cif, deviceID);
				boolean isCallsignMigrated = TextUtils.INSTANCE.getBoolean(userChannel.getCallsignMigrate());
				if (isCallsignMigrated) {
					pwdMatched = verifyLoginTransactionWithCs(req, true);
				} else {
					pwdMatched = Objects.isNull(userChannel.getPwd()) ? false : PwdHelper.match(userChannel.getPwd(), request.getPwd());
				}
				if(pwdMatched) {
					preferencesRepository.updateUserAlertPreference(cif, ContentID.LOGIN_SUCCESS.name(), false, EMAIL);
					//SMS should be disabled
					preferencesRepository.updateUserAlertPreference(cif, ContentID.LOGIN_SUCCESS.name(), false, AppConstants.SMS);
				}
			}
			
			if (Objects.isNull(channelInfo)){
				log.error("Inconsistent data.. User data exists in USER_CHANNEL but not in CHANNEL_INFO table. for CIF:{} and channel:{}", cif, channelType);
				throw new AppException(ErrorCodes.SYS_INVALID_CONDITION,false);
			}

			log.info("userChannel {} | deviceID {} | cif {} | pwdMatched {} | convID {} ",userChannel,deviceID,cif ,pwdMatched ,convID);
			boolean isLoginRequestComing4mRegistrationFlow = isLoginRequestComing4mRegistrationFlow(userChannel);
			//updateChannelAndAccessInfo(pwdMatched, userChannel, channelInfo);
			updateChannelAndAccessInfo(pwdMatched, userChannel, channelInfo);
			
			if(!pwdMatched){
				notifyPasswordFailure(userChannel);
				return populateErrorResponse(verifyUserLoginResponse,userChannel);
			} 
			String cin = session.getUser().getCin();
			boolean isLoggedinSuccess = true;
			String refId = updateReferenceId(session.getUser(), channelInfo);
			if (isLoginRequestComing4mRegistrationFlow && ChannelStatus.ACTIVE_PENDING_LOGIN != userChannel.getStatus()) {
				enrichLoginResponse(verifyUserLoginResponse, cif, convID, deviceID, userChannel, channelType, cin, 
						isPayit, request.getVersion(), false);
				verifyUserLoginResponse.setRiskEvaluationAdvice(RiskAction.ALLOW.name());
				verifyUserLoginResponse.setRiskEvaluationDeviceId(null);
				log.info("update customer as verified");
				sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
			// This will come only when Mobile user come from forgot PIN flow to exclude RBA
			} else if (ChannelStatus.ACTIVE_PENDING_LOGIN == userChannel.getStatus() && channelType == ChannelType.MOBILE) {
				log.info("bypassing RBA call for only Mobile device and ACTIVE_PENDING_LOGIN status");
				userChannel.setStatus(ChannelStatus.ACTIVE);
				userChannelRepository.updateUserChannel(userChannel);
				enrichLoginResponse(verifyUserLoginResponse, cif,convID, deviceID, userChannel, channelType, cin,
						isPayit, request.getVersion(), false);
				log.info("update customer as verified");
				sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
			} else {
				/*int deviceCount = channelValidator.noOfCsMobileRegistration(cif);
				if ((!isCallsignEnabledForPublic && !callsignAuthHelper.isPilotCustomerForCallsign(session, channelType,isCallsignEnabledForCust))
						|| (deviceCount == 0 && ChannelType.BROWSER == channelType)) {
					log.info("Checking RBA for convID:{}, channel:{} and CIF:{}", convID, channelType, cif);
					riskSF.evaluateRisk(request, cif, verifyUserLoginResponse, false, channelType);
					if (RiskAction.INCREASEAUTH.name().equals(verifyUserLoginResponse.getRiskEvaluationAdvice())) {
						isLoggedinSuccess = false;
						processRiskAdvice(verifyUserLoginResponse, convID, cif,userChannel);
					} else if (RiskAction.ALLOW.name().equals(verifyUserLoginResponse.getRiskEvaluationAdvice())) {
						enrichLoginResponse(verifyUserLoginResponse, cif,convID, deviceID, userChannel, channelType, cin, isPayit, request.getVersion());
						log.info("update customer as verified");
						sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
					}*/
//				} else {
					log.info("Callsign is enabled skipping RBA rules and initiating request to callsign.");
					isLoggedinSuccess = false;

					/*if (Objects.isNull(request.getCsTransactionRequest()) || 
							(Objects.nonNull(request.getCsTransactionRequest()) 
									&& (StringUtils.isBlank(request.getCsTransactionRequest().getCsTransactionId())
											|| request.getCsTransactionRequest().getTransactionType() == null))) {
						throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
					}*/
					
					boolean isCallsignMigrated = TextUtils.INSTANCE.getBoolean(userChannel.getCallsignMigrate());
					/**
					 * verification for callsign migration
					 */
					if(!isCallsignMigrated) { // Only when the user is not created in callsign, create user
						/**
						 * Create user in scim
						 */
						APIResponse createUserRes = csUserManagementSF.createUser(refId);

						if (!createUserRes.getResult().isSuccess()) {
							throw new AppException(ErrorCodes.CS_CREATE_USER_FAILED);
						}
					}
					
					if(channelType == ChannelType.BROWSER) {
						String val = settingsRepository.getSetting(AppConstants.IB_WHATS_NEW_SCREEN);
						verifyUserLoginResponse.setIbWhatsNewScreen(TextUtils.INSTANCE.getBoolean(val));

						// Initiate Transaction for push notification etg
						CsTransactionResponse etgResponse = csTransactionSF.initiateTransaction(request.getCsTransactionRequest());
						
						if(!etgResponse.getResult().isSuccess()) {
							String message = etgResponse.getEtgTransactionResponse().getMessage();
							log.error("VerifyUserLogin - message : {}", message);
							if (StringUtils.isNotBlank(message)
									&& (message.equals(AppConstants.REG_MOBILE_CHANNEL_LOCKED)
											|| message.equals(AppConstants.RESET_MOBILE_CHANNEL_LOCKED)
											|| message.equals(AppConstants.LOGIN_MOBILE_CHANNEL_LOCKED))) {
								csTransactionHelper.processErrorBasedOnMessage(message);
							} else {
								throw new AppException(ErrorCodes.CS_TRANSACTION_INITIATE_FAILED);
							}
						}
						
						/*CsTransactionRequest csTransactionRequest = request.getCsTransactionRequest();
						csTransactionRequest.setAuthenticator(etgResponse.getEtgTransactionResponse().getAuthenticator());
						csTransactionRequest.setRequirementsCombination(etgResponse.getEtgTransactionResponse().getRequirementsCombination());
						csTransactionRequest.setRequirementId(etgResponse.getEtgTransactionResponse().getRequirementId());
						
						csTransactionRequest.setSuccessResultMap(true);
						log.info("VerifyUserLoginSF.verify. verifying login request with context : {}",csTransactionRequest);
						CsTransactionResponse etgUpdateResponse = csTransactionSF.updateTransaction(csTransactionRequest);
						
						if(!etgUpdateResponse.getResult().isSuccess()) {
							throw new AppException(ErrorCodes.CS_TRANSACTION_INITIATE_FAILED);
						}*/
						
						if(etgResponse.getEtgTransactionResponse().getDecision() == DecisionEnum.REFER) {
							verifyUserLoginResponse.setCsTxnActiveAllowedAttempts(etgResponse.getCsTxnActiveAllowedAttempts());
							verifyUserLoginResponse.setCsTxnActiveMaxResendAttempts(etgResponse.getCsTxnActiveMaxResendAttempts());
							verifyUserLoginResponse.setCsTxnActiveTimeInSeconds(etgResponse.getCsTxnActiveTimeInSeconds());
						} else if(etgResponse.getEtgTransactionResponse().getDecision() == DecisionEnum.ALLOW) {
							verifyUserLoginResponse.setRiskEvaluationAdvice(AppConstants.ALLOW);
							sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
							enrichLoginResponse(verifyUserLoginResponse, cif, convID, deviceID, userChannel, channelType, cin, 
									isPayit, request.getVersion(), false);
							isLoggedinSuccess = true;
							//Update user channel to callsign migrated to Y.
							if(!isCallsignMigrated) { 
								userChannel.setCallsignMigrate(AppConstants.Y);
								userChannelRepository.updateUserChannel(userChannel);
							}
						}
						
						verifyUserLoginResponse.setEtgTransactionResponse(etgResponse	.getEtgTransactionResponse());
						verifyUserLoginResponse.getEtgTransactionResponse().clearPIIData();
						
						//If ALLOW, set isLoggedinSuccess to true
					} else {
						if(sessionRepository.isOtpREtgVerfied(convID)) {
							isLoggedinSuccess = true;
							enrichLoginResponse(verifyUserLoginResponse, cif, convID, deviceID, userChannel, channelType, cin,
									isPayit, request.getVersion(), false);
						} 
					}
//				}
			}

			enrichPostLoginDetails(verifyUserLoginResponse, session, cif, convID, channelType, userChannel, cin,
					isLoggedinSuccess);
			
			return verifyUserLoginResponse;
		});
	}
   
   

Version 4

   /**
	 * Verify Login Credentials
	 * USAGE: LOGIN (LAST STEP)
	 * @param request
	 * @return VerifyUserLoginResponse
	 */
	public VerifyUserLoginResponse verify(VerifyUserLoginRequest request) {
		VerifyUserLoginResponse response = new VerifyUserLoginResponse();
		return execute(request, response, req ->{
			log.info("Verify callsign transaction is success or not.");
			
			SessionInfo session = SessionContext.getSession();
			String cif = session.getUserId();
			String deviceID = session.getDeviceID();
			String convID = session.getConvID();
			ChannelType channelType = session.getChannelType();
			log.info("verify call Cif:{}, Origin:{}, ChannelType:{}, convID:{}", cif, session.getUser()==null? null: session.getUser().getUserOrigin(), channelType, convID);
			
			ChannelInfo channelInfo  = channelInfoRepository.fetchChannelInfoByChannelUserId(channelType.name(), cif);
			if (Objects.isNull(channelInfo)){
				log.error("Inconsistent data.. User data exists in USER_CHANNEL but not in CHANNEL_INFO table. for CIF:{} and channel:{}", cif, channelType);
				throw new AppException(ErrorCodes.SYS_INVALID_CONDITION,false);
			}
			channelValidator.validateChannelInfo(channelInfo, channelType);
			channelValidator.verifyCifDeviceMatch(request.getDeviceID(), cif, deviceID);
			
			UserChannel userChannel = userChannelRepository.fetchUserChannelByUserIDAndDeviceIDActive(cif, deviceID);
			
			CsTransactionResponse transactionWithOtp = csTransactionSF.transactionWithOtp(request.getCsTransactionRequest());
			mapCSResponse(response, transactionWithOtp);
			
			if(transactionWithOtp.getResult().isSuccess() &&
					transactionWithOtp.getEtgTransactionResponse().getDecision() == DecisionEnum.ALLOW) {
				log.info("Transaction verification is successful with callsign.. enrich verify response...");
				String cin = session.getUser().getCin();
				enrichSuccessResponse(request, response, cif, cin, deviceID, convID, channelType, channelInfo, userChannel);
				
			} else {
				if(!transactionWithOtp.getResult().isSuccess()) {
					verifyUserLoginSF.updateChannelAndAccessInfo(false, userChannel, channelInfo);
					throw new AppException(ErrorCodes.valueOf(transactionWithOtp.getResult().getErrorInfo().getCode()));
				}
			}
			return response;
		}) ;
		
	}

======================

/**
	 * Verify Login Credentials
	 * USAGE: LOGIN,REGISTRATION (LAST STEP)
	 * @param request
	 * @return VerifyUserLoginResponse
	 */
	//@Interceptors(TracingInterceptor.class)
	public VerifyUserLoginResponse verify(VerifyUserLoginRequest request, boolean isPayit) {
		VerifyUserLoginResponse verifyUserLoginResponse = new VerifyUserLoginResponse();
		return  execute(request,verifyUserLoginResponse, req->{
			verifyUserLoginResponse.setCurrentDate(DateTimeHelper.INSTANCE.formatDate(new Date(), AppConstants.DATE_DDMMYYYY));
			SessionInfo session = SessionContext.getSession();
			String cif = session.getUserId();
			String deviceID = session.getDeviceID();
			String convID = session.getConvID();
			ChannelType channelType = session.getChannelType();
			log.info("verify call Cif:{}, Origin:{}, ChannelType:{}, convID:{}", cif, session.getUser()==null? null: session.getUser().getUserOrigin(), channelType, convID);

			ChannelInfo channelInfo  = channelInfoRepository.fetchChannelInfoByChannelUserId(channelType.name(), cif);
			channelValidator.validateChannelInfo(channelInfo, channelType);

			boolean pwdMatched = false;
			UserChannel userChannel = null;
			// String status = null;
			//boolean isCallsignEnabledForPublic = settingsRepository.isCallsignAuthPublicEnabled();
			//boolean isCallsignEnabledForCust = channelInfoRepository.isCallsignAuthEnabled(cif);
			if(ChannelType.BROWSER == channelType) {
				checkTrottle();
				userChannel = getUserChannel(cif, channelType);
				if(Objects.nonNull(userChannel)) {
					// Load Customer position
					mqNotifier.refreshCustomerPositionCache(userChannel.getCin());
				}

				/* Commented below code for PRM-2076
				 * if(ChannelStatus.ACTIVE_PENDING_LOGIN == userChannel.getStatus()) {
					if(session.getUser().getUserOrigin() == UserOrigin.NBAD){
						String username = null;
						if(StringUtils.isNotBlank(userChannel.getUserName())){
							username = userChannel.getUserName();
						}else{
							log.warn("Username is not present in migrated NBAD customer data to authenticate");
							username = request.getUserName();							
						}
						status = nbadUserAuthServiceInvoker.authenticateNbadUser(username, request.getPwd1());
						pwdMatched = AppConstants.SUCCESS.equals(status)?true:false;
						log.info("NBAD PWD status check completed :{}",pwdMatched);
						
					} else if (session.getUser().getUserOrigin() == UserOrigin.FGB){
						String diPwd = channelInfoRepository.fetchDiUserId(cif);
						pwdMatched =  Objects.isNull(userChannel.getPwd()) ? false : PwdHelper.matchDigests(request.getPwd1(), diPwd);
						if(pwdMatched){
							status = AppConstants.SUCCESS;
						}
						log.info("FGB PWD status check completed :{}",pwdMatched);
					}
					
					if(Objects.nonNull(status ) &&AppConstants.SUCCESS.equalsIgnoreCase(status)) {
						verifyUserLoginResponse.setStartPage(FORCE_PASSWORD_UPDATE_FLOW);
						pwdMatched = true;
					}
				} else {*/
					pwdMatched =  Objects.isNull(userChannel.getPwd()) ? false : PwdHelper.match(userChannel.getPwd(), request.getPwd());
				//}
				
				if(pwdMatched){
					checkUsernameConstraints(verifyUserLoginResponse, userChannel);
					preferencesRepository.updateUserAlertPreference(cif, ContentID.LOGIN_SUCCESS.name(), false, EMAIL);
				}
			// Mobile device
			} else {
				//channelValidator.isForceAppUpdateRequired(session);
				userChannel = userChannelRepository.fetchUserChannelByUserIDAndDeviceIDActive(cif, deviceID);
				
				//FMDB-47518-changes
				
				if(Objects.nonNull(userChannel) && Objects.nonNull(request.getPushSettings())) {
						log.info("Populating the Push Settings value");
						userChannel.setPushSettings(request.getPushSettings());
				}
				//FMDB-47518-changes end
				
				channelValidator.verifyCifDeviceMatch(request.getDeviceID(), cif, deviceID);
				boolean isCallsignMigrated = TextUtils.INSTANCE.getBoolean(userChannel.getCallsignMigrate());
				if (isCallsignMigrated) {
					pwdMatched = verifyLoginTransactionWithCs(req, true);
				} else {
					pwdMatched = Objects.isNull(userChannel.getPwd()) ? false : PwdHelper.match(userChannel.getPwd(), request.getPwd());
				}
				if(pwdMatched) {
					preferencesRepository.updateUserAlertPreference(cif, ContentID.LOGIN_SUCCESS.name(), false, EMAIL);
					//SMS should be disabled
					preferencesRepository.updateUserAlertPreference(cif, ContentID.LOGIN_SUCCESS.name(), false, AppConstants.SMS);
				}
			}
			
			if (Objects.isNull(channelInfo)){
				log.error("Inconsistent data.. User data exists in USER_CHANNEL but not in CHANNEL_INFO table. for CIF:{} and channel:{}", cif, channelType);
				throw new AppException(ErrorCodes.SYS_INVALID_CONDITION,false);
			}

			log.info("userChannel {} | deviceID {} | cif {} | pwdMatched {} | convID {} ",userChannel,deviceID,cif ,pwdMatched ,convID);
			boolean isLoginRequestComing4mRegistrationFlow = isLoginRequestComing4mRegistrationFlow(userChannel);
			//updateChannelAndAccessInfo(pwdMatched, userChannel, channelInfo);
			updateChannelAndAccessInfo(pwdMatched, userChannel, channelInfo);
			
			if(!pwdMatched){
				notifyPasswordFailure(userChannel);
				return populateErrorResponse(verifyUserLoginResponse,userChannel);
			} 
			String cin = session.getUser().getCin();
			boolean isLoggedinSuccess = true;
			String refId = updateReferenceId(session.getUser(), channelInfo);
			if (isLoginRequestComing4mRegistrationFlow && ChannelStatus.ACTIVE_PENDING_LOGIN != userChannel.getStatus()) {
				enrichLoginResponse(verifyUserLoginResponse, cif, convID, deviceID, userChannel, channelType, cin, 
						isPayit, request.getVersion(), false);
				verifyUserLoginResponse.setRiskEvaluationAdvice(RiskAction.ALLOW.name());
				verifyUserLoginResponse.setRiskEvaluationDeviceId(null);
				log.info("update customer as verified");
				sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
			// This will come only when Mobile user come from forgot PIN flow to exclude RBA
			} else if (ChannelStatus.ACTIVE_PENDING_LOGIN == userChannel.getStatus() && channelType == ChannelType.MOBILE) {
				log.info("bypassing RBA call for only Mobile device and ACTIVE_PENDING_LOGIN status");
				userChannel.setStatus(ChannelStatus.ACTIVE);
				userChannelRepository.updateUserChannel(userChannel);
				enrichLoginResponse(verifyUserLoginResponse, cif,convID, deviceID, userChannel, channelType, cin,
						isPayit, request.getVersion(), false);
				log.info("update customer as verified");
				sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
			} else {
				/*int deviceCount = channelValidator.noOfCsMobileRegistration(cif);
				if ((!isCallsignEnabledForPublic && !callsignAuthHelper.isPilotCustomerForCallsign(session, channelType,isCallsignEnabledForCust))
						|| (deviceCount == 0 && ChannelType.BROWSER == channelType)) {
					log.info("Checking RBA for convID:{}, channel:{} and CIF:{}", convID, channelType, cif);
					riskSF.evaluateRisk(request, cif, verifyUserLoginResponse, false, channelType);
					if (RiskAction.INCREASEAUTH.name().equals(verifyUserLoginResponse.getRiskEvaluationAdvice())) {
						isLoggedinSuccess = false;
						processRiskAdvice(verifyUserLoginResponse, convID, cif,userChannel);
					} else if (RiskAction.ALLOW.name().equals(verifyUserLoginResponse.getRiskEvaluationAdvice())) {
						enrichLoginResponse(verifyUserLoginResponse, cif,convID, deviceID, userChannel, channelType, cin, isPayit, request.getVersion());
						log.info("update customer as verified");
						sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
					}*/
//				} else {
					log.info("Callsign is enabled skipping RBA rules and initiating request to callsign.");
					isLoggedinSuccess = false;

					/*if (Objects.isNull(request.getCsTransactionRequest()) || 
							(Objects.nonNull(request.getCsTransactionRequest()) 
									&& (StringUtils.isBlank(request.getCsTransactionRequest().getCsTransactionId())
											|| request.getCsTransactionRequest().getTransactionType() == null))) {
						throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
					}*/
					
					boolean isCallsignMigrated = TextUtils.INSTANCE.getBoolean(userChannel.getCallsignMigrate());
					/**
					 * verification for callsign migration
					 */
					if(!isCallsignMigrated) { // Only when the user is not created in callsign, create user
						/**
						 * Create user in scim
						 */
						APIResponse createUserRes = csUserManagementSF.createUser(refId);

						if (!createUserRes.getResult().isSuccess()) {
							throw new AppException(ErrorCodes.CS_CREATE_USER_FAILED);
						}
					}
					
					if(channelType == ChannelType.BROWSER) {
						String val = settingsRepository.getSetting(AppConstants.IB_WHATS_NEW_SCREEN);
						verifyUserLoginResponse.setIbWhatsNewScreen(TextUtils.INSTANCE.getBoolean(val));

						// Initiate Transaction for push notification etg
						CsTransactionResponse etgResponse = csTransactionSF.initiateTransaction(request.getCsTransactionRequest());
						
						if(!etgResponse.getResult().isSuccess()) {
							String message = etgResponse.getEtgTransactionResponse().getMessage();
							log.error("VerifyUserLogin - message : {}", message);
							if (StringUtils.isNotBlank(message)
									&& (message.equals(AppConstants.REG_MOBILE_CHANNEL_LOCKED)
											|| message.equals(AppConstants.RESET_MOBILE_CHANNEL_LOCKED)
											|| message.equals(AppConstants.LOGIN_MOBILE_CHANNEL_LOCKED))) {
								csTransactionHelper.processErrorBasedOnMessage(message);
							} else {
								throw new AppException(ErrorCodes.CS_TRANSACTION_INITIATE_FAILED);
							}
						}
						
						/*CsTransactionRequest csTransactionRequest = request.getCsTransactionRequest();
						csTransactionRequest.setAuthenticator(etgResponse.getEtgTransactionResponse().getAuthenticator());
						csTransactionRequest.setRequirementsCombination(etgResponse.getEtgTransactionResponse().getRequirementsCombination());
						csTransactionRequest.setRequirementId(etgResponse.getEtgTransactionResponse().getRequirementId());
						
						csTransactionRequest.setSuccessResultMap(true);
						log.info("VerifyUserLoginSF.verify. verifying login request with context : {}",csTransactionRequest);
						CsTransactionResponse etgUpdateResponse = csTransactionSF.updateTransaction(csTransactionRequest);
						
						if(!etgUpdateResponse.getResult().isSuccess()) {
							throw new AppException(ErrorCodes.CS_TRANSACTION_INITIATE_FAILED);
						}*/
						
						if(etgResponse.getEtgTransactionResponse().getDecision() == DecisionEnum.REFER) {
							verifyUserLoginResponse.setCsTxnActiveAllowedAttempts(etgResponse.getCsTxnActiveAllowedAttempts());
							verifyUserLoginResponse.setCsTxnActiveMaxResendAttempts(etgResponse.getCsTxnActiveMaxResendAttempts());
							verifyUserLoginResponse.setCsTxnActiveTimeInSeconds(etgResponse.getCsTxnActiveTimeInSeconds());
						} else if(etgResponse.getEtgTransactionResponse().getDecision() == DecisionEnum.ALLOW) {
							verifyUserLoginResponse.setRiskEvaluationAdvice(AppConstants.ALLOW);
							sessionRepository.updateVerificationStatus(convID, SessionState.VERIFIED);
							enrichLoginResponse(verifyUserLoginResponse, cif, convID, deviceID, userChannel, channelType, cin, 
									isPayit, request.getVersion(), false);
							isLoggedinSuccess = true;
							//Update user channel to callsign migrated to Y.
							if(!isCallsignMigrated) { 
								userChannel.setCallsignMigrate(AppConstants.Y);
								userChannelRepository.updateUserChannel(userChannel);
							}
						}
						
						verifyUserLoginResponse.setEtgTransactionResponse(etgResponse	.getEtgTransactionResponse());
						verifyUserLoginResponse.getEtgTransactionResponse().clearPIIData();
						
						//If ALLOW, set isLoggedinSuccess to true
					} else {
						if(sessionRepository.isOtpREtgVerfied(convID)) {
							isLoggedinSuccess = true;
							enrichLoginResponse(verifyUserLoginResponse, cif, convID, deviceID, userChannel, channelType, cin,
									isPayit, request.getVersion(), false);
						} 
					}
//				}
			}

			enrichPostLoginDetails(verifyUserLoginResponse, session, cif, convID, channelType, userChannel, cin,
					isLoggedinSuccess);
			
			return verifyUserLoginResponse;
		});
	}
   
   
   -----------------------------------------------------------------
   
   /**
	 * Verify Login Credentials
	 * USAGE: LOGIN (LAST STEP)
	 * @param request
	 * @return VerifyUserLoginResponse
	 */
	public VerifyUserLoginResponse verify(VerifyUserLoginRequest request) {
		VerifyUserLoginResponse response = new VerifyUserLoginResponse();
		return execute(request, response, req ->{
			log.info("Verify callsign transaction is success or not.");
			
			SessionInfo session = SessionContext.getSession();
			String cif = session.getUserId();
			String deviceID = session.getDeviceID();
			String convID = session.getConvID();
			ChannelType channelType = session.getChannelType();
			log.info("verify call Cif:{}, Origin:{}, ChannelType:{}, convID:{}", cif, session.getUser()==null? null: session.getUser().getUserOrigin(), channelType, convID);
			
			ChannelInfo channelInfo  = channelInfoRepository.fetchChannelInfoByChannelUserId(channelType.name(), cif);
			if (Objects.isNull(channelInfo)){
				log.error("Inconsistent data.. User data exists in USER_CHANNEL but not in CHANNEL_INFO table. for CIF:{} and channel:{}", cif, channelType);
				throw new AppException(ErrorCodes.SYS_INVALID_CONDITION,false);
			}
			channelValidator.validateChannelInfo(channelInfo, channelType);
			channelValidator.verifyCifDeviceMatch(request.getDeviceID(), cif, deviceID);
			
			UserChannel userChannel = userChannelRepository.fetchUserChannelByUserIDAndDeviceIDActive(cif, deviceID);
			
			CsTransactionResponse transactionWithOtp = csTransactionSF.transactionWithOtp(request.getCsTransactionRequest());
			mapCSResponse(response, transactionWithOtp);
			
			if(transactionWithOtp.getResult().isSuccess() &&
					transactionWithOtp.getEtgTransactionResponse().getDecision() == DecisionEnum.ALLOW) {
				log.info("Transaction verification is successful with callsign.. enrich verify response...");
				String cin = session.getUser().getCin();
				enrichSuccessResponse(request, response, cif, cin, deviceID, convID, channelType, channelInfo, userChannel);
				
			} else {
				if(!transactionWithOtp.getResult().isSuccess()) {
					verifyUserLoginSF.updateChannelAndAccessInfo(false, userChannel, channelInfo);
					throw new AppException(ErrorCodes.valueOf(transactionWithOtp.getResult().getErrorInfo().getCode()));
				}
			}
			return response;
		}) ;
		
	}

import boto3
import csv
import httpx
import json 
import base64
import ssl
import uuid
import logging
import os
import io
from base64 import b64decode
from datetime import datetime
from urllib.parse import unquote

PASSWORD = 'p@ssw0rd'

CLIENT_CERT =  r'C:\Users\O22665\Documents\Repo\pn-token-sync\code\ssl\uat\client.crt'

SERVER_KEY = r'C:\Users\O22665\Documents\Repo\pn-token-sync\code\ssl\uat\client.key'

CA_CERT = r'C:\Users\O22665\Documents\Repo\pn-token-sync\code\ssl\uat\certificate.pem'

INTERNAL_API_KEY = 'j60AqcESvkfSDad5NMyy80Xl6fSq0HR6Fvlowjw6'
 
'''

Creation of SSL Context for ssl certificate verification.

'''

sslcontext = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)

sslcontext.verify_mode = ssl.CERT_REQUIRED

sslcontext.check_hostname = True

sslcontext.load_verify_locations(cafile=CA_CERT)

sslcontext.load_cert_chain(CLIENT_CERT,SERVER_KEY,PASSWORD)
 

# Method to fetch customer data based on CIN
def get_customer_data(cin):
    #url= os.environ['GET_CUSTOMER_DETAILS']
    url="https://kproxy-uat.pcdigital-dev.aeapps.bankfab.com/customer-profile/v2/customer-detail"
    xref = str(uuid.uuid4())
    headers = {'XREF': xref, 'CHANNELID': 'IB','LANGUAGE':'EN'}
    currectDate = datetime.now()
    data = {
    "applicationArea": {
        "countryOfOrigin": "AE",
        "creationDateTime": str(currectDate),
        "requiredExecutionDate": str(currectDate),
        "senderId": "IB",
        "transactionDateTime": str(currectDate),
        "transactionId": xref,
        "language": "EN"
    },
    "dataArea": {
        "customerIdentifier": cin,
        "accountingUnitIdentifier": "AE0010001"
    }
    }
    data = json.dumps(data)
    print("data")
    print(data)
    response = httpx.post(url,headers=headers, data=data, verify = sslcontext)
    print("response")
    print(response)
    json_reponse = response.json()
    if response.status_code == 200:
        print(f"Customer detail response received for CIN : {cin}")
        return json_reponse
    else:
        print(f"Customer detail Error response received for CIN : {cin}")
        return None
    
if __name__ == '__main__':
    get_customer_data("123456")

{
    "applicationArea": {
        "countryOfOrigin": "AE",
        "creationDateTime": "2024-08-23 13:08:10.554199",
        "requiredExecutionDate": "2024-08-23 13:08:10.554199",
        "senderId": "IB",
        "transactionDateTime": "2024-08-23 13:08:10.554199",
        "transactionId": "2ad0cdd5-9064-4fbb-a6d7-b86f5a5a8fc7",
        "language": "EN"
    },
    "dataArea": {
        "customerIdentifier": "3396985",
        "accountingUnitIdentifier": "AE0010001"
    }
}

{
   "applicationArea":    {
      "countryOfOrigin": "AE",
      "senderId": "IB",
      "transactionId": "2ad0cdd5-9064-4fbb-a6d7-b86f5a5a8fc7",
      "transactionDateTime": "2024-08-23 13:08:10.554199",
      "language": "EN",
      "creationDateTime": "2024-08-23 13:08:10.554199",
      "requiredExecutionDate": "2024-08-23 13:08:10.554199"
   },
   "responseStatus": {"status": "SUCCESS"},
   "dataArea":    {
      "fullName": "",
      "prefix": "MR",
      "birthDate": "1970-01-01",
      "gender": "M",
      "ltGender": "M",
      "nationality": "PK",
      "emirate": "UMQ",
      "country": "Umm Al Quwain,ARE",
      "maritalStatus": "MARRIED",
      "isResident": "Y",
      "shortName": "bansswap",
      "customerIdentifier": "3396985",
      "customerType": "Individual",
      "customerOpenDate": "2010-07-21",
      "accountingUnitIdentifier": "AE0010001",
      "mothersMaidenName": "FGB SCRAMBLE OWN.CAR",
      "placeOfBirth": "PK",
      "amlSegment": "L",
      "segment": "",
      "isStaff": false,
      "employment":       {
         "employerName": "",
         "employerName2": "FGB SCRAMBLE COMPANY NAME",
         "monthlySalary": "100000.00",
         "employmentStatus": ""
      },
      "additionalCustomerInfo":       {
         "segment": "",
         "customerRateSegment": "Premium",
         "target": "30",
         "accountOfficer": "142",
         "language": "1",
         "startDate": "2010-07-21",
         "nameOnCard": "FGB SCRAMBLE CARD NAM",
         "sector": "4000",
         "profession": "Engineer",
         "subSegment": "6202",
         "relationshipManager": "",
         "vatCategory": "004",
         "constitution": "",
         "dateOfBirth": "2013-03-14",
         "otherOfficer":          [
            "",
            "",
            "",
            ""
         ],
         "country":          [
            "ARE",
            "",
            "",
            ""
         ],
         "customerResidence":          [
            "AE",
            "",
            "",
            ""
         ],
         "ownerName":          [
            "FGB SCRAMBLE OWNER NAME",
            "",
            "",
            ""
         ],
         "ownerNationality":          [
            "",
            "",
            "",
            ""
         ],
         "percentOwner":          [
            "",
            "",
            "",
            ""
         ],
         "riskCategory": "",
         "riskAgreement": "",
         "relationCustomer":          [
            "",
            "",
            "",
            ""
         ],
         "relationCode":          [
            "",
            "",
            "",
            ""
         ],
         "reverseRelationCode":          [
            "",
            "",
            "",
            ""
         ],
         "customerEducationalBackground": "",
         "customerAgeClassification": "MAJOR",
         "powerOfAttorneyFlag": "N"
      },
      "kycInfo":       {
         "kycFlag": "",
         "kycDate": "2010-07-21",
         "kycExpiryDate": "2015-07-21",
         "isKYCUsingEID": false
      },
      "identity":       [
                  {
            "identityType": "EMI",
            "identityNumber": "",
            "identityExpiryDate": "2021-04-12"
         },
                  {
            "identityType": "VIS",
            "identityNumber": "101201770341826",
            "identityExpiryDate": "2020-11-26"
         },
                  {
            "identityType": "PAS",
            "identityNumber": "G1010101",
            "identityExpiryDate": "2018-08-11"
         }
      ],
      "address": [      {
         "addressLine1": "PO Box 56865 Ggh No888",
         "addressLine2": "Hamdan street EEkoc hi",
         "city": "Umm Al Quwain,ARE",
         "country": "ARE",
         "postalCode": "56865"
      }],
      "contacts":       [
                  {
            "contactType": "PERSONAL",
            "mobileNumber": "0563339289",
            "phoneNumber": "",
            "email": "kishore.abdulla@bankfab.com"
         },
                  {
            "contactType": "OFFICE",
            "phoneNumber": ""
         }
      ],
      "accounts":       [
                  {
            "accountIdentifier": "1421003396985036",
            "accountTitle": "FGB SCRAMBLE TITLE.1",
            "postingRestriction": "",
            "customerIdentifier": "3396985",
            "currency": "AED",
            "isActive": true,
            "branchCode": "142",
            "powerOfAttorney": ""
         },
                  {
            "accountIdentifier": "2011003396985027",
            "accountTitle": "FGB SCRAMBLE TITLE.1",
            "postingRestriction": "",
            "customerIdentifier": "3396985",
            "currency": "AED",
            "isActive": false,
            "branchCode": "201",
            "powerOfAttorney": ""
         }
      ],
      "FATCA":       {
         "isPoliticalExposed": "",
         "pepPosition": "",
         "isUSPersonForTaxPurpose": false,
         "socialSecurityNumber": "",
         "isTaxResidentOtherCountry": false,
         "isResidentOfOtherJurisdiction": "",
         "declarationIndicator": false,
         "reasonForDeclarationDisagree": "",
         "status": "",
         "isReportable": false,
         "otherNationalities":          [
            "",
            "",
            "",
            ""
         ],
         "nationality":          [
            "PK",
            "",
            "",
            ""
         ],
         "placeOfBirth": "",
         "taxResidencies":          [
                        {
               "countryJurisdictionOfTaxResident": "",
               "taxIdentificationNumber": "",
               "reasonIfTINNotAvailable": "",
               "comments": ""
            },
                        {
               "countryJurisdictionOfTaxResident": "",
               "taxIdentificationNumber": "",
               "reasonIfTINNotAvailable": "",
               "comments": ""
            },
                        {
               "countryJurisdictionOfTaxResident": "",
               "taxIdentificationNumber": "",
               "reasonIfTINNotAvailable": "",
               "comments": ""
            },
                        {
               "countryJurisdictionOfTaxResident": "",
               "taxIdentificationNumber": "",
               "reasonIfTINNotAvailable": "",
               "comments": ""
            }
         ]
      }
   }
}


Root Cause Analysis (RCA)

Incident Summary:
A recent change was made to the backend API of the Internet Banking platform to disable ADPF Payment beneficiary accounts from appearing in the drop-down list. However, this change unintentionally impacted the Mobile Banking platform, resulting in the ADPF Payment beneficiary accounts also being removed from the mobile platform, which was not part of the requested change. The issue was missed during both the testing and regression testing phases and was not identified in the test case sign-off process.

Root Cause:
The root cause of the incident is attributed to insufficient impact analysis of the backend API change. The change was only intended for the Internet Banking platform but inadvertently affected shared components used by both the Internet Banking and Mobile Banking platforms. Additionally, there was a failure in communication regarding the potential impact of the change on other platforms.

Contributing Factors:

Lack of Comprehensive Impact Analysis: The change request focused on the Internet Banking platform but did not consider the shared nature of the backend services between the Internet Banking and Mobile Banking platforms.
Inadequate Testing Coverage: The testing team did not account for the Mobile Banking platform in their test cases. This critical omission led to the issue going unnoticed during both functional and regression testing.
Test Case Sign-off Missed the Issue: Test case sign-off procedures failed to ensure that all related platforms, including Mobile Banking, were tested. The sign-off process did not include validation across all impacted platforms.
Communication Gap: There was insufficient communication between the development and testing teams regarding the scope of the change and its potential impact on other services, such as the Mobile Banking platform.
Corrective Actions:

Enhanced Impact Assessment Process: Implement a more thorough impact assessment process that explicitly includes the evaluation of shared services and cross-platform dependencies before making any backend changes.
Improved Test Coverage: Expand test case development to include scenarios that cover all platforms that utilize shared services, such as both Internet Banking and Mobile Banking. Ensure test cases are updated accordingly for future changes.
Stricter Sign-off Procedures: Update the test case sign-off process to require a formal review of all platforms impacted by the change, ensuring cross-platform validation before final approval.
Cross-team Communication: Establish stronger communication protocols between development, testing, and business teams to ensure that all potential impacts of a change are clearly understood and documented across all relevant platforms.
Preventive Actions:

Platform-Specific Testing: Mandate that all API changes are tested across every platform using the shared service, with specific test cases for each platform.
Automated Regression Testing: Introduce or enhance automated regression testing to cover multiple platforms and ensure that future changes do not inadvertently affect other parts of the system.
Platform Awareness Training: Conduct regular training sessions to improve platform awareness for both developers and testers, focusing on understanding how changes in one platform can impact others.


org.bouncycastle:bcprov-jdk15on
commons-codec:commons-codec

Top 5 Vulnerable Packages
5 log4j:log4j-1.2.17
2 com.fasterxml.jackson.core:jackson-databind-2.1
3.3
2 org.springframework.security:spring-security-cor
e-5.7.3
1 commons-collections:commons-collections-3.2.2
1 net.minidev:json-smart-2.4.7


Fixed Pom.xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

	<modelVersion>4.0.0</modelVersion>

	<groupId>com.fgb</groupId>
	<version>0.0.1-SNAPSHOT</version>
	<artifactId>FABAdmin</artifactId>
	<packaging>war</packaging>
	<name>FABAdminAPI</name>
	<description>FABAdminAPI</description>

	<properties>
		<junit.version>4.11</junit.version>
		<jdk.version>1.8</jdk.version>
		<logger.version>2.17.1</logger.version>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
	</properties>

	<dependencies>
		<dependency>
			<groupId>javax</groupId>
			<artifactId>javaee-api</artifactId>
			<version>7.0</version>
			<scope>provided</scope>
		</dependency>
		<!-- <dependency> <groupId>org.apache.geronimo.specs</groupId> <artifactId>geronimo-jaxrs_2.0_spec</artifactId> 
			<version>1.0-alpha-1</version> <scope>provided</scope> </dependency> <dependency> 
			<groupId>org.apache.geronimo.specs</groupId> <artifactId>geronimo-servlet_3.0_spec</artifactId> 
			<version>1.0</version> <scope>provided</scope> </dependency> <dependency> 
			<groupId>org.apache.geronimo.specs</groupId> <artifactId>geronimo-ejb_3.1_spec</artifactId> 
			<version>1.0.2</version> <scope>provided</scope> </dependency> -->
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-lang3</artifactId>
			<version>3.7</version>
		</dependency>
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-text</artifactId>
			<version>1.2</version>
		</dependency>
		<dependency>
           <groupId>com.opencsv</groupId>
           <artifactId>opencsv</artifactId>
           <version>5.9</version>
           <exclusions>
				<exclusion>
					<groupId>commons-collections</groupId>
					<artifactId>commons-collections</artifactId>
				</exclusion>
			</exclusions>
        </dependency>
		<dependency>
			<groupId>com.fab</groupId>
			<artifactId>PBLogger</artifactId>
			<version>1.7</version>
			<exclusions>
				<exclusion>
					<groupId>com.fasterxml.jackson.core</groupId>
					<artifactId>jackson-databind</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>${junit.version}</version>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>javax.interceptor</groupId>
			<artifactId>javax.interceptor-api</artifactId>
			<version>3.1</version>
		</dependency>
		<!-- changed version from 1.9.0 to 1.9.3 -->
		<dependency>
			<groupId>org.jasypt</groupId>
			<artifactId>jasypt-spring31</artifactId>
			<version>1.9.3</version>
		</dependency>
		<dependency>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpcore</artifactId>
			<version>4.4.6</version>
		</dependency>
		
		<dependency>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpmime</artifactId>
			<version>4.5.3</version>
			<exclusions>
				<exclusion>
				    <groupId>org.apache.httpcomponents</groupId>
				    <artifactId>httpclient</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<!-- changed version from 4.5.3 to 4.5.13 -->
		<dependency>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpclient</artifactId>
			<version>4.5.14</version>
		</dependency>
		<dependency>
			<groupId>com.jayway.jsonpath</groupId>
			<artifactId>json-path</artifactId>
			<version>2.9.0</version>
		</dependency>
		<!-- changed version from 2.12.5 to 2.13.3 -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-core</artifactId>
			<version>2.13.3</version>
		</dependency>
		<!-- changed version from 2.9.4 to 2.13.3 -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>2.13.4.2</version>
		</dependency>
		<dependency>
			<groupId>com.ibm.websphere.appserver.api</groupId>
			<artifactId>com.ibm.websphere.appserver.api.distributedMap</artifactId>
			<version>2.0.17</version>
		</dependency>
		<!-- changed version from 1.54 to 1.70 -->
		<dependency>
			<groupId>org.bouncycastle</groupId>
			<artifactId>bcprov-jdk15on</artifactId>
			<version>1.70</version>
		</dependency>
		<dependency>
			<groupId>com.oracle</groupId>
			<artifactId>ojdbc6</artifactId>
			<version>11.2.0.3</version>
		</dependency>
		<dependency>
			<groupId>commons-io</groupId>
			<artifactId>commons-io</artifactId>
			<version>2.11.0</version>
		</dependency>
		<dependency>
			<groupId>com.amazonaws</groupId>
			<artifactId>aws-java-sdk-core</artifactId>
			<version>1.12.769</version>
			<exclusions>
				<exclusion>
					<groupId>com.fasterxml.jackson.core</groupId>
					<artifactId>jackson-databind</artifactId>
				</exclusion>
				<exclusion>
				    <groupId>com.fasterxml.jackson.dataformat</groupId>
				    <artifactId>jackson-dataformat-cbor</artifactId>
				</exclusion>
				<exclusion>
				    <groupId>org.apache.httpcomponents</groupId>
				    <artifactId>httpclient</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>com.amazonaws</groupId>
			<artifactId>aws-java-sdk-pinpoint</artifactId>
			<version>1.11.383</version>
			<exclusions>
				<exclusion>
					<groupId>com.fasterxml.jackson.core</groupId>
					<artifactId>jackson-databind</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<!-- changed version from 5.0.0 to 5.2.2 -->
		<dependency>
			<groupId>org.apache.poi</groupId>
			<artifactId>poi-ooxml</artifactId>
			<version>5.3.0</version>
			<exclusions>
				<exclusion>
				    <groupId>org.apache.logging.log4j</groupId>
				    <artifactId>log4j-api</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
		    <groupId>com.fasterxml.jackson.dataformat</groupId>
		    <artifactId>jackson-dataformat-cbor</artifactId>
		    <version>2.13.3</version>
		</dependency>
		<dependency>
			<groupId>com.unboundid</groupId>
    		<artifactId>unboundid-ldapsdk</artifactId>
    		<version>6.0.0</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.ldap</groupId>
			<artifactId>spring-ldap-core</artifactId>
			<version>2.4.1</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-ldap</artifactId>
			<version>6.3.1</version>
		</dependency>
		
		<dependency>
		    <groupId>com.google.re2j</groupId>
		    <artifactId>re2j</artifactId>
		    <version>1.7</version>
		</dependency>
		
		<dependency>
		    <groupId>com.google.code.gson</groupId>
		    <artifactId>gson</artifactId>
		    <version>2.10.1</version>
		</dependency>
		
		<dependency>
		    <groupId>org.apache.logging.log4j</groupId>
		    <artifactId>log4j-slf4j-impl</artifactId>
		    <version>${logger.version}</version>
		</dependency>
		

		<!-- <dependency> <groupId>javax.jms</groupId> <artifactId>javax.jms-api</artifactId> 
			<version>2.0.1</version> </dependency> -->
	</dependencies>
	<build>
		<finalName>FABAdmin</finalName>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.0</version>
				<configuration>
					<source>${jdk.version}</source>
					<target>${jdk.version}</target>
					<archive>
						<manifest>
							<addDefaultImplementationEntries>true</addDefaultImplementationEntries>
						</manifest>
						<manifestEntries>
							<Implementation-Build>$\{buildNumber}</Implementation-Build>
						</manifestEntries>
					</archive>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-war-plugin</artifactId>
				<version>3.4.0</version>
				<configuration>
					<webXml>src/main/webapp/WEB-INF/web.xml</webXml>
					<ignoreWebxml>false</ignoreWebxml>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>2.16</version>
				<configuration>
					<skipTests>true</skipTests>
				</configuration>
			</plugin>
		</plugins>
	</build>
 <repositories>
	 <repository>
		 <id>repo1</id>
		 <name> nexus-release-repo1</name>
		 <url>https://nexus.platform-tools-development.mesouth1.bankfab.com/repository/maven-releases/ </url>
     </repository>
 </repositories>
</project>
--------------------------------------------------

<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

	<modelVersion>4.0.0</modelVersion>

	<groupId>com.fgb</groupId>
	<version>0.0.1-SNAPSHOT</version>
	<artifactId>FABAdmin</artifactId>
	<packaging>war</packaging>
	<name>FABAdminAPI</name>
	<description>FABAdminAPI</description>

	<properties>
		<junit.version>4.11</junit.version>
		<jdk.version>1.8</jdk.version>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
	</properties>

	<dependencies>
		<dependency>
			<groupId>javax</groupId>
			<artifactId>javaee-api</artifactId>
			<version>7.0</version>
			<scope>provided</scope>
		</dependency>
		<!-- <dependency> <groupId>org.apache.geronimo.specs</groupId> <artifactId>geronimo-jaxrs_2.0_spec</artifactId> 
			<version>1.0-alpha-1</version> <scope>provided</scope> </dependency> <dependency> 
			<groupId>org.apache.geronimo.specs</groupId> <artifactId>geronimo-servlet_3.0_spec</artifactId> 
			<version>1.0</version> <scope>provided</scope> </dependency> <dependency> 
			<groupId>org.apache.geronimo.specs</groupId> <artifactId>geronimo-ejb_3.1_spec</artifactId> 
			<version>1.0.2</version> <scope>provided</scope> </dependency> -->
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-lang3</artifactId>
			<version>3.7</version>
		</dependency>
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-text</artifactId>
			<version>1.2</version>
		</dependency>

		<dependency>
			<groupId>com.fab</groupId>
			<artifactId>PBLogger</artifactId>
			<version>1.0</version>
			<exclusions>
				<exclusion>
					<groupId>com.fasterxml.jackson.core</groupId>
					<artifactId>jackson-databind</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>${junit.version}</version>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>javax.interceptor</groupId>
			<artifactId>javax.interceptor-api</artifactId>
			<version>3.1</version>
		</dependency>
		<!-- changed version from 1.9.0 to 1.9.3 -->
		<dependency>
			<groupId>org.jasypt</groupId>
			<artifactId>jasypt-spring31</artifactId>
			<version>1.9.3</version>
		</dependency>
		<dependency>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpcore</artifactId>
			<version>4.4.6</version>
		</dependency>
		
		<dependency>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpmime</artifactId>
			<version>4.5.3</version>
			<exclusions>
				<exclusion>
				    <groupId>org.apache.httpcomponents</groupId>
				    <artifactId>httpclient</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<!-- changed version from 4.5.3 to 4.5.13 -->
		<dependency>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpclient</artifactId>
			<version>4.5.13</version>
		</dependency>

		<dependency>
			<groupId>com.jayway.jsonpath</groupId>
			<artifactId>json-path</artifactId>
			<version>2.6.0</version>
		</dependency>
		<!-- changed version from 2.12.5 to 2.13.3 -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-core</artifactId>
			<version>2.13.3</version>
		</dependency>
		<!-- changed version from 2.9.4 to 2.13.3 -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>2.13.3</version>
		</dependency>
		<dependency>
			<groupId>com.ibm.websphere.appserver.api</groupId>
			<artifactId>com.ibm.websphere.appserver.api.distributedMap</artifactId>
			<version>2.0.17</version>
		</dependency>
		<!-- changed version from 1.54 to 1.70 -->
		<dependency>
			<groupId>org.bouncycastle</groupId>
			<artifactId>bcprov-jdk15on</artifactId>
			<version>1.70</version>
		</dependency>
		<dependency>
			<groupId>com.oracle</groupId>
			<artifactId>ojdbc6</artifactId>
			<version>11.2.0.3</version>
		</dependency>
		<dependency>
			<groupId>commons-io</groupId>
			<artifactId>commons-io</artifactId>
			<version>2.11.0</version>
		</dependency>
		<dependency>
			<groupId>com.amazonaws</groupId>
			<artifactId>aws-java-sdk-core</artifactId>
			<version>1.11.383</version>
			<exclusions>
				<exclusion>
					<groupId>com.fasterxml.jackson.core</groupId>
					<artifactId>jackson-databind</artifactId>
				</exclusion>
				<exclusion>
				    <groupId>com.fasterxml.jackson.dataformat</groupId>
				    <artifactId>jackson-dataformat-cbor</artifactId>
				</exclusion>
				<exclusion>
				    <groupId>org.apache.httpcomponents</groupId>
				    <artifactId>httpclient</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>com.amazonaws</groupId>
			<artifactId>aws-java-sdk-pinpoint</artifactId>
			<version>1.11.383</version>
			<exclusions>
				<exclusion>
					<groupId>com.fasterxml.jackson.core</groupId>
					<artifactId>jackson-databind</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<!-- changed version from 5.0.0 to 5.2.2 -->
		<dependency>
			<groupId>org.apache.poi</groupId>
			<artifactId>poi-ooxml</artifactId>
			<version>5.2.2</version>
			<exclusions>
				<exclusion>
				    <groupId>org.apache.logging.log4j</groupId>
				    <artifactId>log4j-api</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
		    <groupId>org.apache.logging.log4j</groupId>
		    <artifactId>log4j-api</artifactId>
		    <version>2.18.0</version>
		</dependency>
		<dependency>
		    <groupId>com.fasterxml.jackson.dataformat</groupId>
		    <artifactId>jackson-dataformat-cbor</artifactId>
		    <version>2.13.3</version>
		</dependency>
		<dependency>
			<groupId>com.unboundid</groupId>
    		<artifactId>unboundid-ldapsdk</artifactId>
    		<version>6.0.0</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.ldap</groupId>
			<artifactId>spring-ldap-core</artifactId>
			<version>2.4.1</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-ldap</artifactId>
			<version>5.7.3</version>
		</dependency>
		
		<dependency>
		    <groupId>com.google.re2j</groupId>
		    <artifactId>re2j</artifactId>
		    <version>1.7</version>
		</dependency>

		<!-- <dependency> <groupId>javax.jms</groupId> <artifactId>javax.jms-api</artifactId> 
			<version>2.0.1</version> </dependency> -->
	</dependencies>
	<build>
		<finalName>FABAdmin</finalName>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.0</version>
				<configuration>
					<source>${jdk.version}</source>
					<target>${jdk.version}</target>
					<archive>
						<manifest>
							<addDefaultImplementationEntries>true</addDefaultImplementationEntries>
						</manifest>
						<manifestEntries>
							<Implementation-Build>$\{buildNumber}</Implementation-Build>
						</manifestEntries>
					</archive>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-war-plugin</artifactId>
				<version>3.4.0</version>
				<configuration>
					<webXml>src/main/webapp/WEB-INF/web.xml</webXml>
					<ignoreWebxml>false</ignoreWebxml>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>2.16</version>
				<configuration>
					<skipTests>true</skipTests>
				</configuration>
			</plugin>
		</plugins>
	</build>
 <repositories>
	 <repository>
		 <id>repo1</id>
		 <name> nexus-release-repo1</name>
		 <url>https://nexus.platform-tools-development.mesouth1.bankfab.com/repository/maven-releases/ </url>
     </repository>
 </repositories>
</project>


--------------------------------------------------

public void validateDepositRequest(DepositCreateRequest depositCreateRequest) {
    // Get company code based on the source account number
    String companyCode = ciRepository.getAccountUnitIdentifier(depositCreateRequest.getSourceAccountNumber());
    
    // Validate company code
    validateCompanyCode(companyCode);
    
    // Validate interest redeem account
    validateAccountForISL(depositCreateRequest.getInterestRedeemAccount());
    
    // Validate principal redeem account
    validateAccountForISL(depositCreateRequest.getPrincipalRedeemAccount());
}

private void validateCompanyCode(String companyCode) {
    if (StringUtils.isNotBlank(companyCode) && companyCode.equals(T24CompanyCodes.ISL.getCompanyCode())) {
        throw new AppException(ErrorCodes.DEPOSIT_ISL_NOT_ALLOWED);
    }
}

private void validateAccountForISL(String accountNumber) {
    if (StringUtils.isNotBlank(accountNumber)) {
        String companyCode = ciRepository.getAccountUnitIdentifier(accountNumber);
        validateCompanyCode(companyCode);
    }
}
set define off;

CREATE OR REPLACE PACKAGE "IBMBUSER.IBMB_ARCHIVE_PKG" 
AS
PROCEDURE ARCHVICE_EVENT;
PROCEDURE ARCHVICE_NOTIFICATION;
PROCEDURE ARCHVICE_PUSH_NOTI_AUDIT;
PROCEDURE ARCHVICE_SEGMENT_UPLOAD_FILE;
PROCEDURE ARCHVICE_PAGE_VIEW_REPORT;
PROCEDURE ARCHVICE_CA_REQUEST_AUDIT;
PROCEDURE ARCHIVE_CS_TRANSACTION_AUDIT;
END; 

/
create or replace PACKAGE BODY "IBMB_ARCHIVE_PKG" 
IS
   PROCEDURE ARCHVICE_EVENT 
   IS
     CURSOR c_archiveData IS
		SELECT * FROM IBMBUSER.EVENT@ARCH_CIDB_IBMB WHERE CREATED_DATE <= add_months(sysdate, -3);
	TYPE t_data IS TABLE OF  c_archiveData%ROWTYPE;
	chunk_size CONSTANT INTEGER :=100000;
	l_data t_data;
	lc_out  VARCHAR2(512);
    reccount NUMBER;
    totalRecords NUMBER;
   BEGIN
	OPEN c_archiveData;
    totalRecords := 0;
    LOOP
      BEGIN
            FETCH c_archiveData BULK COLLECT INTO l_data LIMIT chunk_size;
            reccount := l_data.COUNT;
            totalRecords := totalRecords + reccount;
            FORALL i IN 1..reccount
                INSERT INTO IBMBARCHIVE.EVENT_ARCHIVE(EVENT_ID,EVENT_TYPE,CIN,CIF,STATUS,PARAM1,PARAM2,PARAM3,PARAM4,PARAM5,CREATED_BY,
				CREATED_DATE,MODIFIED_BY,MODIFIED_DATE,OCCURRENCE,FREQUENCY,DEVICE_ID) 
                VALUES
                (l_data(i).EVENT_ID,l_data(i).EVENT_TYPE,l_data(i).CIN,l_data(i).CIF,l_data(i).STATUS,l_data(i).PARAM1,l_data(i).PARAM2,l_data(i).PARAM3,l_data(i).PARAM4,l_data(i).PARAM5,
                l_data(i).CREATED_BY,l_data(i).CREATED_DATE,l_data(i).MODIFIED_BY,l_data(i).MODIFIED_DATE,l_data(i).OCCURRENCE,l_data(i).FREQUENCY,
                l_data(i).DEVICE_ID);
            lc_out := 'INS';
            FOR i IN 1..reccount
				LOOP
                  DELETE FROM IBMBUSER.EVENT@ARCH_CIDB_IBMB WHERE EVENT_ID = l_data(i).EVENT_ID;
				END LOOP;
            lc_out := lc_out || '-DEL-';
            IF SQL%FOUND THEN
                lc_out := lc_out || 'SUCCESS';
                INSERT INTO IBMB_ARCHIVE_AUDIT (TBL_NAME, RECOUNT, STATUS,ERR_TEXT) VALUES ('EVENT',reccount,'1',lc_out);
                COMMIT;
            END IF;
            EXIT WHEN c_archiveData%NOTFOUND;
        EXCEPTION
            WHEN OTHERS
            THEN
                ROLLBACK;
                lc_out := lc_out || 'Error:' || SQLERRM;
				totalRecords := totalRecords - reccount;
                INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('EVENT',reccount,'0',lc_out);
                COMMIT;
        END;
	END LOOP;
	CLOSE c_archiveData;
    INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('EVENT',totalRecords,'1','JOB_COMPLETED');
    COMMIT;
   END ARCHVICE_EVENT;

PROCEDURE ARCHVICE_NOTIFICATION
   IS
	CURSOR c_archiveData IS
		SELECT * FROM IBMBUSER.NOTIFICATION@ARCH_CIDB_IBMB WHERE CREATED_ON <= add_months(sysdate, -6);
	TYPE t_data IS TABLE OF  c_archiveData%ROWTYPE;
	chunk_size CONSTANT INTEGER :=100000;
	l_data t_data;
	lc_out  VARCHAR2(512);
    reccount NUMBER;
	totalRecords NUMBER;


BEGIN
	totalRecords := 0;
	OPEN c_archiveData;
		LOOP
			BEGIN
            FETCH c_archiveData BULK COLLECT INTO l_data LIMIT chunk_size;
            reccount := l_data.COUNT;
			totalRecords := totalRecords + reccount;
            FORALL i IN 1..reccount
                INSERT INTO IBMBARCHIVE.NOTIFICATION_ARCHIVE(NOTIFICATION_ID,CIF,TITTLE,MESSAGE,CATEGORY,ACTION,ACTION_LABEL,ACTION_URL,READ_STATUS,DELIVERY_METHOD,
				DELIVERY_STATUS,CREATED_BY,CREATED_ON,MODIFIED_BY,MODIFIED_ON,SOURCE_TYPE,PARENT_ID,ERROR_CODE,ERROR_DESC,EVENT_TYPE,EXPIRY_DATE,LOCALE,ANDROID_IMAGE,
				IOS_MEDIA,REFERENCE_ID,TEMPLATE_TYPE,SUPRESSION_TYPE,CONTENT_PATH) 
                VALUES
                (l_data(i).NOTIFICATION_ID,l_data(i).CIF,l_data(i).TITTLE,l_data(i).MESSAGE,l_data(i).CATEGORY,l_data(i).ACTION,l_data(i).ACTION_LABEL,l_data(i).ACTION_URL,l_data(i).READ_STATUS,
                l_data(i).DELIVERY_METHOD,l_data(i).DELIVERY_STATUS,l_data(i).CREATED_BY,l_data(i).CREATED_ON,l_data(i).MODIFIED_BY,l_data(i).MODIFIED_ON,l_data(i).SOURCE_TYPE,l_data(i).PARENT_ID,
                l_data(i).ERROR_CODE,l_data(i).ERROR_DESC,l_data(i).EVENT_TYPE,l_data(i).EXPIRY_DATE,l_data(i).LOCALE,l_data(i).ANDROID_IMAGE,l_data(i).IOS_MEDIA,l_data(i).REFERENCE_ID,l_data(i).TEMPLATE_TYPE,
                l_data(i).SUPRESSION_TYPE,l_data(i).CONTENT_PATH);
            lc_out := 'INS';
            FOR i IN 1..reccount
				LOOP
                  DELETE FROM IBMBUSER.NOTIFICATION@ARCH_CIDB_IBMB WHERE NOTIFICATION_ID = l_data(i).NOTIFICATION_ID;
				END LOOP;
            lc_out := lc_out || '-DEL-';
            IF SQL%FOUND THEN
                lc_out := lc_out || 'SUCCESS';
                INSERT INTO IBMB_ARCHIVE_AUDIT (TBL_NAME, RECOUNT, STATUS,ERR_TEXT) VALUES ('NOTIFICATION',reccount,'1',lc_out);
                COMMIT;
            END IF;
            EXIT WHEN c_archiveData%NOTFOUND;
        EXCEPTION
            WHEN OTHERS
            THEN
                ROLLBACK;
                lc_out := lc_out || 'Error:' || SQLERRM;
				totalRecords := totalRecords - reccount;
                INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('NOTIFICATION',reccount,'0',lc_out);
                COMMIT;
        END;
	END LOOP;
	CLOSE c_archiveData;
	INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('NOTIFICATION',totalRecords,'1','JOB_COMPLETED');
    COMMIT;

END ARCHVICE_NOTIFICATION;

PROCEDURE ARCHVICE_PUSH_NOTI_AUDIT 
   IS
    CURSOR c_archiveData IS
		SELECT * FROM IBMBUSER.PUSH_NOTIFICATION_AUDIT@ARCH_CIDB_IBMB WHERE CREATION_DATE <= add_months(sysdate, -3);
    TYPE t_data IS TABLE OF  c_archiveData%ROWTYPE;
	chunk_size CONSTANT INTEGER :=100000;
	l_data t_data;
	lc_out  VARCHAR2(512);
    reccount NUMBER; 
	totalRecords NUMBER;	
  BEGIN
    totalRecords := 0;
	OPEN c_archiveData;
	LOOP
        BEGIN
            FETCH c_archiveData BULK COLLECT INTO l_data LIMIT chunk_size;
            reccount := l_data.COUNT;
			totalRecords := totalRecords + reccount;
            FORALL i IN 1..reccount
                INSERT INTO IBMBARCHIVE.PUSH_NOTI_AUDIT_ARCHIVE(ID, SEGMENT_ID, CAMPAIGN_ID, DEVICE_ID,CREATION_DATE, NOTIFIED_DATE, STATUS, ERROR_CODE, ERROR_DESC, CIF, CIN,TITTLE,MESSAGE,
                ACTION,ACTION_URL,SOURCE_TYPE,PARENT_ID,TOKEN,EVENT_TYPE,LOCALE, ANDROID_IMAGE, IOS_MEDIA, DEVICE_TYPE)
                VALUES (l_data(i).ID,l_data(i).SEGMENT_ID,l_data(i).CAMPAIGN_ID,l_data(i).DEVICE_ID,l_data(i).CREATION_DATE,l_data(i).NOTIFIED_DATE,l_data(i).STATUS,l_data(i).ERROR_CODE,l_data(i).ERROR_DESC,
                l_data(i).CIF,l_data(i).CIN,l_data(i).TITTLE,l_data(i).MESSAGE,l_data(i).ACTION,l_data(i).ACTION_URL,l_data(i).SOURCE_TYPE,l_data(i).PARENT_ID,l_data(i).TOKEN,l_data(i).EVENT_TYPE,l_data(i).LOCALE,l_data(i).ANDROID_IMAGE,l_data(i).IOS_MEDIA,l_data(i).DEVICE_TYPE);
            lc_out := 'INS';
            FOR i IN 1..reccount
			 LOOP
                 DELETE FROM IBMBUSER.PUSH_NOTIFICATION_AUDIT@ARCH_CIDB_IBMB WHERE ID = l_data(i).ID;
		     END LOOP;
            lc_out := lc_out || '-DEL-';
            IF SQL%FOUND THEN
                lc_out := lc_out || 'SUCCESS';
                INSERT INTO ibmb_archive_audit (TBL_NAME, RECOUNT, STATUS,ERR_TEXT) VALUES ('PUSH_NOTIFICATION_AUDIT',reccount,'1',lc_out);
                COMMIT;
            END IF;
            EXIT WHEN c_archiveData%NOTFOUND;
        EXCEPTION
            WHEN OTHERS
            THEN
                ROLLBACK;
				totalRecords := totalRecords - reccount;
                lc_out := lc_out || 'Error:' || SQLERRM;
                INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('PUSH_NOTIFICATION_AUDIT',reccount,'0',lc_out);
                COMMIT;
        END;
	END LOOP;
	CLOSE c_archiveData;
	INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('PUSH_NOTIFICATION_AUDIT',totalRecords,'1','JOB_COMPLETED');
    COMMIT;

END ARCHVICE_PUSH_NOTI_AUDIT;

PROCEDURE ARCHVICE_SEGMENT_UPLOAD_FILE
   IS
      reccount      NUMBER;
      lc_out        VARCHAR2(512);
   BEGIN

       SELECT COUNT(1) INTO reccount FROM IBMBUSER.SEGMENT_UPLOAD_FILE@ARCH_CIDB_IBMB WHERE UPLOADED_DATE <= add_months(sysdate, -6);

       INSERT INTO IBMBARCHIVE.SEGMENT_UPLOAD_FILE_ARCHIVE SELECT * FROM IBMBUSER.SEGMENT_UPLOAD_FILE@ARCH_CIDB_IBMB WHERE UPLOADED_DATE <= add_months(sysdate, -6);
       lc_out := 'INS';
       IF reccount = SQL%ROWCOUNT THEN
         DELETE FROM IBMBUSER.SEGMENT_UPLOAD_FILE@ARCH_CIDB_IBMB WHERE UPLOADED_DATE <= add_months(sysdate, -6);
         lc_out := lc_out || '-DEL-';
         IF SQL%FOUND THEN
           lc_out := lc_out || 'SUCCESS';
           INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS,ERR_TEXT )  VALUES('SEGMENT_UPLOAD_FILE',reccount,'1',lc_out);
           COMMIT;
         END IF;
       END IF;
	   INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS,ERR_TEXT )  VALUES('SEGMENT_UPLOAD_FILE',reccount,'1','JOB_COMPLETED');
       COMMIT;

   EXCEPTION
      WHEN OTHERS
      THEN
         ROLLBACK;
         lc_out := lc_out || 'Error:' || SQLERRM;
         INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('SEGMENT_UPLOAD_FILE',reccount,'0',lc_out);
         COMMIT;
   END ARCHVICE_SEGMENT_UPLOAD_FILE;

PROCEDURE ARCHVICE_PAGE_VIEW_REPORT
   IS
    CURSOR c_archiveData IS
		SELECT * FROM IBMBUSER.PAGE_VIEW_REPORT@ARCH_CIDB_IBMB WHERE TRUNC(CREATION_TIME) <= TRUNC(sysdate -1);
    TYPE t_data IS TABLE OF  c_archiveData%ROWTYPE;
	chunk_size CONSTANT INTEGER :=200000;
	l_data t_data;
	lc_out  VARCHAR2(512);
    reccount NUMBER;
	totalRecords NUMBER;

   BEGIN
    totalRecords := 0;
	OPEN c_archiveData;
	LOOP
        BEGIN
            FETCH c_archiveData BULK COLLECT INTO l_data LIMIT chunk_size;
            reccount := l_data.COUNT;
			totalRecords := totalRecords + reccount;
            FORALL i IN 1..reccount
                INSERT INTO IBMBARCHIVE.PAGE_VIEW_REPORT_ARCHIVE(ID, CIF,CIN,CHANNEL_ID,PAGE,CREATION_TIME,RC,IP,HOSTNAME,COMPLETION_TIME,API_STATUS,API_ERRORCODE,HTTP_STATUS,HTTP_ERRORCODE,HTTP_ERRORDESC,REMOTE_IP) 
				VALUES (l_data(i).ID, l_data(i).CIF,l_data(i).CIN,l_data(i).CHANNEL_ID,l_data(i).PAGE,l_data(i).CREATION_TIME,l_data(i).RC,l_data(i).IP,l_data(i).HOSTNAME,l_data(i).COMPLETION_TIME,l_data(i).API_STATUS,l_data(i).API_ERRORCODE,l_data(i).HTTP_STATUS,l_data(i).HTTP_ERRORCODE,l_data(i).HTTP_ERRORDESC,l_data(i).REMOTE_IP); -- use columns name
            lc_out := 'INS';
            FOR i IN 1..reccount
			  LOOP
                 DELETE FROM IBMBUSER.PAGE_VIEW_REPORT@ARCH_CIDB_IBMB WHERE ID = l_data(i).ID;
			  END LOOP;
            lc_out := lc_out || '-DEL-';
            IF SQL%FOUND THEN
                lc_out := lc_out || 'SUCCESS';
                INSERT INTO ibmb_archive_audit (TBL_NAME, RECOUNT, STATUS,ERR_TEXT) VALUES ('PAGE_VIEW_REPORT',reccount,'1',lc_out);
                COMMIT;
            END IF;
            EXIT WHEN c_archiveData%NOTFOUND;
        EXCEPTION
            WHEN OTHERS
            THEN
                ROLLBACK;
                lc_out := lc_out || 'Error:' || SQLERRM;
				totalRecords := totalRecords - reccount;
                INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('PAGE_VIEW_REPORT',reccount,'0',lc_out);
                COMMIT;
        END;
	END LOOP;
	CLOSE c_archiveData;
	INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('PAGE_VIEW_REPORT',totalRecords,'1','JOB_COMPLETED');
    COMMIT;
END ARCHVICE_PAGE_VIEW_REPORT; 

PROCEDURE ARCHVICE_CA_REQUEST_AUDIT 
   IS
      reccount      NUMBER;
      lc_out        VARCHAR2(512);
   BEGIN

       SELECT COUNT(1) INTO reccount FROM IBMBUSER.CA_REQUEST_AUDIT@ARCH_CIDB_IBMB  WHERE  TRUNC(CREATE_DATE) <= TRUNC(sysdate -1);

       INSERT INTO IBMBARCHIVE.CA_REQUEST_AUDIT_ARCHIVE SELECT * FROM IBMBUSER.CA_REQUEST_AUDIT@ARCH_CIDB_IBMB WHERE TRUNC(CREATE_DATE) <= TRUNC(sysdate -1);
       lc_out := 'INS';
       IF reccount = SQL%ROWCOUNT THEN
         DELETE FROM IBMBUSER.CA_REQUEST_AUDIT@ARCH_CIDB_IBMB WHERE TRUNC(CREATE_DATE) <= TRUNC(sysdate -1);
         lc_out := lc_out || '-DEL-';
         IF SQL%FOUND THEN
           lc_out := lc_out || 'SUCCESS';
           INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS,ERR_TEXT )  VALUES('CA_REQUEST_AUDIT',reccount,'1',lc_out);
           COMMIT;
         END IF;
       END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         ROLLBACK;
         lc_out := lc_out || 'Error:' || SQLERRM;
         INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('CA_REQUEST_AUDIT',reccount,'0',lc_out);
         COMMIT;
   END ARCHVICE_CA_REQUEST_AUDIT;
   
   PROCEDURE ARCHIVE_CS_TRANSACTION_AUDIT
   IS
    CURSOR c_archiveData IS
		SELECT * FROM IBMBUSER.CS_TRANSACTION_AUDIT@ARCH_CIDB_IBMB WHERE TRUNC(CREATION_TIME) <= TRUNC(sysdate -3);
    TYPE t_data IS TABLE OF  c_archiveData%ROWTYPE;
	chunk_size CONSTANT INTEGER :=200000;
	l_data t_data;
	lc_out  VARCHAR2(512);
    reccount NUMBER;
	totalRecords NUMBER;

   BEGIN
    totalRecords := 0;
	OPEN c_archiveData;
	LOOP
        BEGIN
            FETCH c_archiveData BULK COLLECT INTO l_data LIMIT chunk_size;
            reccount := l_data.COUNT;
			totalRecords := totalRecords + reccount;
            FORALL i IN 1..reccount
                INSERT INTO IBMBARCHIVE.CS_TRANSACTION_AUDIT_ARCHIVE(CONVID,SESSIONID,RC,CIN,CIF,STATUS,CHANNEL,CREATION_TIME,PATH,TRANSACTION_ID,TRANSACTION_TYPE,RESULT,REQUIREMENT_ID,DECISION_ID,DECISION,REQUEST_AUTHENTICATOR,RESPONSE_AUTHENTICATOR,MESSAGE,SDK_ERROR_CODE,SDK_ERROR_MESSAGE,ID,MODIFY_DATE,APP_VERSION)
				VALUES (l_data(i).CONVID, l_data(i).SESSIONID,
				l_data(i).RC,l_data(i).CIN,l_data(i).CIF,l_data(i).STATUS,l_data(i).CHANNEL,l_data(i).CREATION_TIME,l_data(i).PATH,l_data(i).TRANSACTION_ID,l_data(i).TRANSACTION_TYPE,l_data(i).RESULT,l_data(i).REQUIREMENT_ID,l_data(i).DECISION_ID,l_data(i).DECISION,l_data(i).REQUEST_AUTHENTICATOR,l_data(i).RESPONSE_AUTHENTICATOR,l_data(i).MESSAGE,l_data(i).SDK_ERROR_CODE,l_data(i).SDK_ERROR_MESSAGE,l_data(i).ID,l_data(i).MODIFY_DATE,l_data(i).APP_VERSION); -- use columns name
            lc_out := 'INS';
            FOR i IN 1..reccount
			  LOOP
                 DELETE FROM IBMBUSER.CS_TRANSACTION_AUDIT@ARCH_CIDB_IBMB WHERE ID = l_data(i).ID;
			  END LOOP;
            lc_out := lc_out || '-DEL-';
            IF SQL%FOUND THEN
                lc_out := lc_out || 'SUCCESS';
                INSERT INTO ibmb_archive_audit (TBL_NAME, RECOUNT, STATUS,ERR_TEXT) VALUES ('CS_TRANSACTION_AUDIT',reccount,'1',lc_out);
                COMMIT;
            END IF;
            EXIT WHEN c_archiveData%NOTFOUND;
        EXCEPTION
            WHEN OTHERS
            THEN
                ROLLBACK;
                lc_out := lc_out || 'Error:' || SQLERRM;
				totalRecords := totalRecords - reccount;
                INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('CS_TRANSACTION_AUDIT',reccount,'0',lc_out);
                COMMIT;
        END;
	END LOOP;
	CLOSE c_archiveData;
	INSERT INTO IBMB_ARCHIVE_AUDIT(TBL_NAME, RECOUNT, STATUS, ERR_TEXT)  VALUES('CS_TRANSACTION_AUDIT',totalRecords,'1','JOB_COMPLETED');
    COMMIT;
    END ARCHIVE_CS_TRANSACTION_AUDIT;

END;

/

commit;


--------------------------------
Yes, you can set multiple email addresses in the os.environ['TO_ADDRESS'] field and modify the send_mail function to handle multiple recipients. You can store multiple email addresses in the TO_ADDRESS environment variable separated by a delimiter (e.g., comma) and then split this string into a list in the function.

Here’s how you can modify your function:

Store multiple email addresses in the TO_ADDRESS environment variable, separated by commas.
Split the TO_ADDRESS string into a list inside the function.

import os
import json
import uuid
from datetime import datetime
import httpx

# Method is used to send email
def send_mail(csv_data_in_bytes, s3_file_name):
    if csv_data_in_bytes is not None:
        currectDate = datetime.now().date()
        email_subject = "Sanctioned country report_" + currectDate.strftime("%Y-%m-%d")
        split_array = s3_file_name.split('/')
        s3_file_name=split_array[-1]
        s3_file_name = s3_file_name.replace(':','_')
        url = os.environ['SEND_EMAIL_SERVICE_URL']
        headers = {'XREF': str(uuid.uuid4()), 'CHANNELID': 'AWS', 'content-type': 'application/json'}

        # Split the TO_ADDRESS environment variable into a list of email addresses
        to_address_list = os.environ['TO_ADDRESS'].split(',')

        data = {
            "sourceSystem": "FAB",
            "requestID": str(uuid.uuid4()),
            "fromAddress": "noreply@bankfab.com",
            "entityName": "FAB",
            "toAddress": to_address_list,
            "emailSubject": email_subject,
            "emailBodyContent": "",
            "emailBodyContentType": "TEXT",
            "attachment": [{
                "attachementBytes": str(csv_data_in_bytes.decode("utf-8")),
                "mimeType": "application/csv",
                "fileName": s3_file_name
            }]
        }

        data = json.dumps(data)
        response = httpx.post(url, headers=headers, data=data, verify=sslcontext)
        if response.status_code == 200:
            logger.info("Email sent successfully")
        else:
            logger.info(f"Failed to send email. Status code: {response.status_code}")
        logger.info(f'Email API Response: {response.text}')
    else:
        logger.info("csv_data_in_bytes is null.")


-- Adding indexes
CREATE INDEX IDX_MOBILE_DEVICE_ID ON IBMBUSER.WATCH_REGISTRATION_DETAILS (MOBILE_DEVICE_ID);
CREATE INDEX IDX_WATCH_DEVICE_ID ON IBMBUSER.WATCH_REGISTRATION_DETAILS (WATCH_DEVICE_ID);
CREATE INDEX IDX_CIF ON IBMBUSER.WATCH_REGISTRATION_DETAILS (CIF);
CREATE INDEX IDX_CIN ON IBMBUSER.WATCH_REGISTRATION_DETAILS (CIN);


1. All the Npss related functionality needs to be disabled.
    IPP: Enable IPP Account to Account transfer for MB
    IPP: Enable IPP Account to Account transfer for IB
    NPSS Aani Overlay Roll out Enable(Y)/Disable(N)

2. DB Migration scripts needs to be executed by optimus team

3. Stop G42 Services all 4 services	
     npss-sca
	 npss-enrollment
	 npss-payment
	 npss-notification

try (CSVReader reader = new CSVReader(new StringReader(str))) {
            return reader.readAll().stream()
                .map(this::createSegmentUploadData)
                .collect(Collectors.toList());
        } catch (IOException | CsvValidationException e) {
            throw new AppException(ErrorCodes.SYS_INTERNAL_ERROR, e);
        }

private SegmentUploadData createSegmentUploadData(String[] record) {
        SegmentUploadData uploadData = new SegmentUploadData();

        for (int index = 0; index < record.length; index++) {
            String field = record[index];
            validateField(field);

            switch (index) {
                case 0:
                    uploadData.setData(field.replace("\"", ""));
                    if (uploadData.getData().length() > 100) {
                        log("length is greater than 100");
                        throw new AppException(ErrorCodes.INCORRECT_SEGMENT_DATA);
                    }
                    break;
                case 1:
                    uploadData.setAttr1(field);
                    break;
                case 2:
                    uploadData.setAttr2(field);
                    break;
                case 3:
                    uploadData.setAttr3(field);
                    break;
                case 4:
                    uploadData.setAttr4(field);
                    break;
                case 5:
                    uploadData.setAttr5(field);
                    break;
                case 6:
                    uploadData.setAttr6(field);
                    break;
                case 7:
                    uploadData.setAttr7(field);
                    break;
                default:
                    break;
            }
        }
        return uploadData;
    }


3605561,"1,000"
Invalid char between encapsulated token and delimiter at line: 1, position: 16
try (CSVParser parser = CSVParser.parse(new StringReader(str), format)) {
            for (CSVRecord record : parser) {
                SegmentUploadData uploadData = new SegmentUploadData();

                for (int index = 0; index < record.size(); index++) {
                    String field = record.get(index);
                    validateField(field);

                    switch (index) {
                        case 0:
                            uploadData.setData(field.replace("\"", ""));
                            if (uploadData.getData().length() > 100) {
                                log("length is greater than 100");
                                throw new AppException(ErrorCodes.INCORRECT_SEGMENT_DATA);
                            }
                            break;
                        case 1:
                            uploadData.setAttr1(field);
                            break;
                        case 2:
                            uploadData.setAttr2(field);
                            break;
                        case 3:
                            uploadData.setAttr3(field);
                            break;
                        case 4:
                            uploadData.setAttr4(field);
                            break;
                        case 5:
                            uploadData.setAttr5(field);
                            break;
                        case 6:
                            uploadData.setAttr6(field);
                            break;
                        case 7:
                            uploadData.setAttr7(field);
                            break;
                        default:
                            break;
                    }
                }
                segmentUploadData.add(uploadData);
            }
        } catch (IOException e) {
            throw new AppException(ErrorCodes.SYS_INTERNAL_ERROR, e);
        }



<dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-io</artifactId>
        <version>2.11.0</version>
    </dependency>

        at org.apache.commons.csv.CSVParser$CSVRecordIterator.getNextRecord(CSVParser.java:149)
	at org.apache.commons.csv.CSVParser$CSVRecordIterator.hasNext(CSVParser.java:158)
	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:132)
	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1845)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:682)
	at com.fab.pb.helpers.pdfprocessor.PdfHelper.main(PdfHelper.java:348)
Caused by: java.lang.ClassNotFoundException: org.apache.commons.io.function.Uncheck
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-csv</artifactId>
    <version>1.11.0</version>
</dependency>

List<SegmentUploadData> segmentUploadData = new ArrayList<>();

    CSVFormat format = CSVFormat.DEFAULT.withQuote('"');

    try (CSVParser parser = CSVParser.parse(new StringReader(str), format)) {
        segmentUploadData = StreamSupport.stream(parser.spliterator(), false)
            .map(record -> {
                SegmentUploadData uploadData = new SegmentUploadData();
    
                for (int index = 0; index < record.size(); index++) {
                    switch (index) {
                        case 0:
                            uploadData.setData(record.get(0).replace("\"", ""));
                            if (uploadData.getData().length() > 100) {
                                log.info("length is greater than 100");
                                throw new AppException(ErrorCodes.INCORRECT_SEGMENT_DATA);
                            }
                            break; // Added break

                        case 1:
                            uploadData.setAttr1(record.get(1));
                            break;
                        case 2:
                            uploadData.setAttr2(record.get(2));
                            break;
                        case 3:
                            uploadData.setAttr3(record.get(3));
                            break;
                        case 4:
                            uploadData.setAttr4(record.get(4));
                            break;
                        case 5:
                            uploadData.setAttr5(record.get(5));
                            break;
                        case 6:
                            uploadData.setAttr6(record.get(6));
                            break;
                        case 7:
                            uploadData.setAttr7(record.get(7));
                            break;
                        default:
                            break;
                    }
                }

                return uploadData;
            })
            .collect(Collectors.toList());
    }

List<SegmentUploadData> segmentUploadData = new ArrayList<SegmentUploadData>();
			String[] splitted = Arrays.stream(str.split("\n")).map(String::trim).toArray(String[]::new);
			List<String> list = Arrays.asList(splitted);

			for (String lineStr : list) {
				//String[] line = Arrays.stream(lineStr.split(",")).map(String::trim).toArray(String[]::new);
				String[] line = parseCsvLine(lineStr);
				if(ArrayUtils.isNotEmpty(line)) {
				  List<String> splittedLine = Arrays.asList(line);
				  SegmentUploadData uploadData = new SegmentUploadData();
				  for(int index=0;index<splittedLine.size();index++){
					switch(index){
					case 0:
						uploadData.setData(splittedLine.get(0).replace("\"", ""));
						// PRM-2709: FAB_Admin_Elig_file_seg_file_upload_issue with incorrect CIN
						if(uploadData.getData().length()>100) {
							log.info("length is greater than 100");
							throw new AppException(ErrorCodes.INCORRECT_SEGMENT_DATA);
						}
						break;
					case 1:
						uploadData.setAttr1(splittedLine.get(1));
						break;
					case 2:
						uploadData.setAttr2(splittedLine.get(2));
						break;
					case 3:
						uploadData.setAttr3(splittedLine.get(3));
						break;
					case 4:
						uploadData.setAttr4(splittedLine.get(4));
						break;
					case 5:
						uploadData.setAttr5(splittedLine.get(5));
						break;
					case 6:
						uploadData.setAttr6(splittedLine.get(6));
						break;
					case 7:
						uploadData.setAttr7(splittedLine.get(7));
						break;
					default:
						break;
					}
				}
				segmentUploadData.add(uploadData);
			  }
			}


1)Callsign whitelisted the mw risk endpoint: https://kproxy-uat.risk-middleware-dev.aeapps.bankfab.com/ae/core/sim-swap/v1/sim/swap/status  from Akhaya and after we have trigger the etg reqyest and mw team given us the req/res and we repoted to team  
 
 
below is the update:
We worked with CALLSIGN and KONG team to stabilize the environment.
Post that able to generate logs from middleware team. Below are the logs
Naveen Gupta please check. If any support required connect with us Thanks Sanjib Mohanty
Jun 21, 2024 @ 14:33:44.244	trn-p2kg9mwp-0sps3t5r-9ncf25tma-4psbcgd5, simSwapStatus	INFO	Service Request: {"applicationArea":{"transactionId":"trn-p2kg9mwp-0sps3t5r-9ncf25tma-4psbcgd5"}}

Jun 21, 2024 @ 14:33:44.249	trn-p2kg9mwp-0sps3t5r-9ncf25tma-4psbcgd5, simSwapStatus	INFO	Service Response: 400 BAD_REQUEST {"applicationArea":{"transactionId":"trn-p2kg9mwp-0sps3t5r-9ncf25tma-4psbcgd5"},"responseStatus":{"status":"ERROR","errorDetails":[{"errorCode":"GEN8003","errorDesc":"Missing Mandatory fields in Request payload"}]}}
 
 
 
2) After changing the request payload fromat by callsign :   "transaction": {
                    "additionalTransactionInformation": {
                        "channel": "MOB",
                        "phoneNumber": "0504972291",
                        "countryOfOrigin": "AE",
                        "transactionDateTime": "2024-06-21T09:00:45.043Z",
                        "referenceDate": "2024-06-21 03:12:02.751"
                    }
                } 
				Still callsign request is not recieved in mw and they are saying the request is invalid josn format that is why they r not able to provide request 
3)https://kproxy-uat.risk-middleware-dev.aeapps.bankfab.com/ae/core/sim-swap/v1/sim/swap/status   ---------its not working from postman as Etislat connectivity  issue As per Prasant

Update on Middleware Risk Endpoint Whitelisting and Logging:

1. Whitelisting and Initial Triggering:
Callsign has successfully whitelisted the middleware risk endpoint: https://kproxy-uat.risk-middleware-dev.aeapps.bankfab.com/ae/core/sim-swap/v1/sim/swap/status from Akhaya. Following this, we triggered the ETG request, and the middleware team provided us with the request and response details, which we have reported to the team.

Update:
We collaborated with the CALLSIGN and KONG teams to stabilize the environment. Subsequently, we were able to generate logs from the middleware team. Below are the logs:

Naveen Gupta, please review the logs. If any support is required, please connect with us.

Logs:

Timestamp: Jun 21, 2024 @ 14:33:44.244

Transaction ID: trn-p2kg9mwp-0sps3t5r-9ncf25tma-4psbcgd5

Service: simSwapStatus

Log Level: INFO

Service Request: {"applicationArea":{"transactionId":"trn-p2kg9mwp-0sps3t5r-9ncf25tma-4psbcgd5"}}

Timestamp: Jun 21, 2024 @ 14:33:44.249

Transaction ID: trn-p2kg9mwp-0sps3t5r-9ncf25tma-4psbcgd5

Service: simSwapStatus

Log Level: INFO

Service Response: 400 BAD_REQUEST {"applicationArea":{"transactionId":"trn-p2kg9mwp-0sps3t5r-9ncf25tma-4psbcgd5"},"responseStatus":{"status":"ERROR","errorDetails":[{"errorCode":"GEN8003","errorDesc":"Missing Mandatory fields in Request payload"}]}}

2. Payload Format Update:
After modifying the request payload format by Callsign, the updated structure is as follows:

json
Copy code
{
    "transaction": {
        "additionalTransactionInformation": {
            "channel": "MOB",
            "phoneNumber": "0504972291",
            "countryOfOrigin": "AE",
            "transactionDateTime": "2024-06-21T09:00:45.043Z",
            "referenceDate": "2024-06-21 03:12:02.751"
        }
    }
}
Despite this modification, Callsign's request is still not being received by the middleware, and they have indicated that the request is in an invalid JSON format, preventing them from providing the request.

3. Connectivity Issue:
The endpoint https://kproxy-uat.risk-middleware-dev.aeapps.bankfab.com/ae/core/sim-swap/v1/sim/swap/status is currently not functioning from Postman due to connectivity issues with Etisalat, as reported by Prasant.

return getWebClient(finalUrl, false).method(httpMethod).uri(finalUrl)
				.headers(header -> header.putAll(headers)).body(BodyInserters.fromValue(xmlRequest))
				.exchangeToMono(clientResponse -> processResponse(serviceName, finalUrl, headers, t1, clientResponse))
				.contextCapture()
				.retryWhen(Retry.backoff(3, Duration.ofMillis(500))
					            .filter(this::isRetryRequired));


/**
	 * Method to invoke Post and PUT API's without proxy.
	 * 
	 * @param <T>
	 * @param serviceName
	 * @param url
	 * @param httpMethod
	 * @param pathParams
	 * @param requestObj
	 * @param headersMap
	 * @param queryParams
	 * @return
	 */
	public <T> Mono<ConnectorResponse> invokePostPut(String serviceName, String url, HttpMethod httpMethod,
			Map<String, String> pathParams, T requestObj, Map<String, String> headersMap, String... queryParams) {

		String finalUrl = checkNgetServiceUrl(url, pathParams, headersMap, queryParams);
		
		String request = "{}";
		if (Objects.nonNull(requestObj)) {
			request = JsonUtils.convertToJsonUsingGson(requestObj);
		}
		
		HttpHeaders headers = getHttpHeaders(serviceName, finalUrl, httpMethod, headersMap, MediaType.APPLICATION_JSON);
		log.info("XREF: {}, Request: {}", headers.getFirst(BaseAppConstants.XREF), TextUtils.maskJsonFields(request));
		long t1 = System.currentTimeMillis();

		return getWebClient(finalUrl, false).method(httpMethod).uri(finalUrl)
				.headers(header -> header.putAll(headers)).body(BodyInserters.fromValue(request))
				.exchangeToMono(clientResponse -> processResponse(serviceName, finalUrl, headers, t1, clientResponse))
				.contextCapture();




3605561,"1,000"
3189338,"1,000"
5734543,"1,000"
4116175,"1,000"
1074462,"1,000"
4676587,1000
import org.apache.commons.lang3.StringUtils;

private String[] parseCsvLine(String line) {
    List<String> result = new ArrayList<>();
    boolean inQuotes = false;
    StringBuilder current = new StringBuilder();

    for (char c : line.toCharArray()) {
        if (c == '"') {
            inQuotes = !inQuotes;
        } else if (c == ',' && !inQuotes) {
            result.add(current.toString());
            current = new StringBuilder();
        } else {
            current.append(c);
        }
    }
    result.add(current.toString());

    String[] parsedLine = result.toArray(new String[0]);

    // Validate second column if present
    if (parsedLine.length > 1) {
        String secondColumn = StringUtils.strip(parsedLine[1], "\"").trim();
        if (!isValidSecondColumn(secondColumn)) {
            return StringUtils.EMPTY_STRING_ARRAY;
        }
    } else {
        return StringUtils.EMPTY_STRING_ARRAY;
    }

    // Validate first column
    String firstColumn = StringUtils.strip(parsedLine[0], "\"").trim();
    if (StringUtils.isEmpty(firstColumn)) {
        return StringUtils.EMPTY_STRING_ARRAY;
    }

    return parsedLine;
}

private boolean isValidSecondColumn(String column) {
    // Your validation logic for the second column goes here
    // Example: Check if it's numeric with commas and dots
    return column.matches("[0-9,.]+");
}
/**
	 * Method to create segment for file upload.
	 * 
	 * @param segementRequest
	 * @return
	 */
	public CreatePinpointResponse uploadSegment(Segment segementRequest) {
		CreatePinpointResponse response = new CreatePinpointResponse();
		return execute(segementRequest, response, req -> {
			if(StringUtils.isBlank(req.getSegmentName()) || Objects.isNull(req.getSegmentType()) 
					|| StringUtils.isBlank(req.getFileContentsAsBase64()) || StringUtils.isBlank(req.getFileName())) {
				throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
			}
			if(pinpointRepository.checkIfSegmentExists(segementRequest.getSegmentName())){
				throw new AppException(ErrorCodes.SEGMENT_NAME_ALREADY_EXIST);
			}
			byte[] inBytes = Base64.decodeBase64(req.getFileContentsAsBase64().getBytes());
						
			String str = new String(inBytes);

			if (StringUtils.isBlank(str.trim())) {
				throw new AppException(ErrorCodes.SYS_INVALID_REQUEST);
			}

			List<SegmentUploadData> segmentUploadData = new ArrayList<SegmentUploadData>();
			String[] splitted = Arrays.stream(str.split("\n")).map(String::trim).toArray(String[]::new);
			List<String> list = Arrays.asList(splitted);

			for (String lineStr : list) {
				String[] line = Arrays.stream(lineStr.split(",")).map(String::trim).toArray(String[]::new);
				List<String> splittedLine = Arrays.asList(line);
				SegmentUploadData uploadData = new SegmentUploadData();
				for(int index=0;index<splittedLine.size();index++){
					switch(index){
					case 0:
						uploadData.setData(splittedLine.get(0).replace("\"", ""));
						// PRM-2709: FAB_Admin_Elig_file_seg_file_upload_issue with incorrect CIN
						if(uploadData.getData().length()>100) {
							log.info("length is greater than 100");
							throw new AppException(ErrorCodes.INCORRECT_SEGMENT_DATA);
						}
						break;
					case 1:
						uploadData.setAttr1(splittedLine.get(1));
						break;
					case 2:
						uploadData.setAttr2(splittedLine.get(2));
						break;
					case 3:
						uploadData.setAttr3(splittedLine.get(3));
						break;
					case 4:
						uploadData.setAttr4(splittedLine.get(4));
						break;
					case 5:
						uploadData.setAttr5(splittedLine.get(5));
						break;
					case 6:
						uploadData.setAttr6(splittedLine.get(6));
						break;
					case 7:
						uploadData.setAttr7(splittedLine.get(7));
						break;
					default:
						break;
					}
				}
				segmentUploadData.add(uploadData);
			}
			
			String segmentID = UUID.randomUUID().toString();
			req.setCreateMode("UPLOAD");
			req.setRecordCount(segmentUploadData.size());
			int count = pinpointRepository.insertToSegment(req, segmentID);
			log.info("Segment created with id :{}", segmentID);
			if(count > 0) {
				//upload the file to new table.
				pinpointRepository.uploadSegmentBatch(segmentUploadData,segmentID, req );
				//Arrays.asList(parts).stream().forEach(record -> pinpointRepository.uploadSegment(record, segmentID, req));
			}
			response.setSegmentId(segmentID);
			return response;
		});
	}


import org.apache.commons.lang3.StringUtils;

private String[] parseCsvLine(String line) {
    List<String> result = new ArrayList<>();
    boolean inQuotes = false;
    StringBuilder current = new StringBuilder();

    for (char c : line.toCharArray()) {
        if (c == '"') {
            inQuotes = !inQuotes;
        } else if (c == ',' && !inQuotes) {
            result.add(current.toString());
            current = new StringBuilder();
        } else {
            current.append(c);
        }
    }
    result.add(current.toString());

    String[] parsedLine = result.toArray(new String[0]);

    // Validate second column if present
    if (parsedLine.length > 1) {
        String secondColumn = StringUtils.strip(parsedLine[1], "\"").trim();
        if (!isValidSecondColumn(secondColumn)) {
            return StringUtils.EMPTY_STRING_ARRAY;
        }
    } else {
        return StringUtils.EMPTY_STRING_ARRAY;
    }

    // Validate first column
    String firstColumn = StringUtils.strip(parsedLine[0], "\"").trim();
    if (StringUtils.isEmpty(firstColumn)) {
        return StringUtils.EMPTY_STRING_ARRAY;
    }

    return parsedLine;
}

private boolean isValidSecondColumn(String column) {
    // Your validation logic for the second column goes here
    // Example: Check if it's numeric with commas and dots
    return column.matches("[0-9,.]+");
}
private boolean isNumericWithCommaAndDot(String str) {
    return str.matches("[0-9,.]+");
}
And here are the updated unit tests:

java
Copy code
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class SegmentUploaderTest {

    SegmentUploader segmentUploader = new SegmentUploader();

    @Test
    public void testParseCsvLine_WithCommasInQuotes() {
        String line = "3605561,\"1,000\"";
        String[] result = segmentUploader.parseCsvLine(line);
        assertArrayEquals(new String[]{"3605561", "1,000"}, result);
    }

    @Test
    public void testParseCsvLine_WithDotsInQuotes() {
        String line = "3605561,\"1.000\"";
        String[] result = segmentUploader.parseCsvLine(line);
        assertArrayEquals(new String[]{"3605561", "1.000"}, result);
    }

    @Test
    public void testParseCsvLine_WithCommasAndDotsInQuotes() {
        String line = "3605561,\"1,000.00\"";
        String[] result = segmentUploader.parseCsvLine(line);
        assertArrayEquals(new String[]{"3605561", "1,000.00"}, result);
    }

    @Test
    public void testParseCsvLine_WithoutQuotes() {
        String line = "4676587,1000";
        String[] result = segmentUploader.parseCsvLine(line);
        assertArrayEquals(new String[]{"4676587", "1000"}, result);
    }

    @Test
    public void testParseCsvLine_WithMultipleColumns() {
        String line = "3605561,\"1,000\",test,\"data,with,commas\"";
        String[] result = segmentUploader.parseCsvLine(line);
        assertArrayEquals(new String[]{"3605561", "1,000", "test", "data,with,commas"}, result);
    }

    @Test
    public void testParseCsvLine_WithEmptyFields() {
        String line = "3605561,\"\",,";
        assertThrows(IllegalArgumentException.class, () -> segmentUploader.parseCsvLine(line));
    }

    @Test
    public void testParseCsvLine_WithNonNumericSecondColumn() {
        String line = "3605561,\"nonNumeric\"";
        assertThrows(IllegalArgumentException.class, () -> segmentUploader.parseCsvLine(line));
    }

    @Test
    public void testParseCsvLine_WithInvalidCharactersInSecondColumn() {
        String line = "3605561,\"1,000a\"";
        assertThrows(IllegalArgumentException.class, () -> segmentUploader.parseCsvLine(line));
    }

    @Test
    public void testParseCsvLine_WithMismatchedQuotes() {
        String line = "3605561,\"1,000";
        assertThrows(IllegalArgumentException.class, () -> segmentUploader.parseCsvLine(line));
    }

    @Test
    public void testParseCsvLine_WithExtraCommas() {
        String line = "3605561,\"1,000\",,,";
        String[] result = segmentUploader.parseCsvLine(line);
        assertArrayEquals(new String[]{"3605561", "1,000", "", "", ""}, result);
    }

    @Test
    public void testParseCsvLine_WithNoData() {
        String line = "";
        String[] result = segmentUploader.parseCsvLine(line);
        assertArrayEquals(new String[]{""}, result);
    }

    @Test
    public void testParseCsvLine_WithNonNumericDataInSecondColumn() {
        String line = "3605561,notNumeric";
        assertThrows(IllegalArgumentException.class, () -> segmentUploader.parseCsvLine(line));
    }

    @Test
    public void testParseCsvLine_WithQuotedCommasInSecondColumn() {
        String line = "3605561,\"data,with,commas\"";
        assertThrows(IllegalArgumentException.class, () -> segmentUploader.parseCsvLine(line));
    }
}

private void prepareAcctLoanDeposits(CustPositionResponse custPosition, CustomerProducts customerFavouriteProducts, CustomerProducts customerProducts, FeaturePromotion featurePromotion,
        Map<String, ProductPreference> userPreferences) {
    // sort accounts in customer position accounts by sorting order of Account types
    sortAccountsByAccountType(custPosition);
    List<AccountDetails> acctDetails = custPosition.getListOfAccounts();
    
    if (acctDetails != null && !acctDetails.isEmpty()) {
        for (AccountDetails acctDtl : acctDetails) {
            // Decide whether to show on dashboard
            if (isLoanAccountCode(acctDtl.getAccountType())) {
                if (!StringUtils.startsWithAny(acctDtl.getAccountNo(), SKIP_PD_LOANS)) {
                    Loan loan = getLoanData(acctDtl);
                    loan.setProduct(ProductTypes.LOAN.name());
                    
                    if (userPreferences.containsKey(loan.getLoanNumber())) {
                        ProductPreference prodPref = userPreferences.get(loan.getLoanNumber());
                        loan.setNickName(prodPref.getNickName());
                        loan.setDisplaySequence(prodPref.getDisplaySequence());
                        loan.setIsFavorite(prodPref.getIsFavorite());
                        loan.setIsHide(prodPref.getIsHide());
                        // Add all favorite products
                        if (prodPref.getIsFavorite()) {
                            customerFavouriteProducts.addLoan(loan);
                        }
                    } else {
                        loan.setDisplaySequence(0);
                    }
                    customerProducts.addLoan(loan);
                } else {
                    log.warn("#### Skipping PD loan from customer loan dashboard:{}", acctDtl.getAccountNo());
                }
            } else {
                // Skip deposit with HNI / ISL / NIF / ISB
                if (AccountType.TD.getCode().equals(acctDtl.getAccountType())) {
                    String accountId = acctDtl.getAccountNo();
                    if (StringUtils.startsWithAny(accountId, AppConstants.SKIP_PREFIX_DEPOSIT)) {
                        acctDtl.setAccountNo(accountId.substring(3));
                    }
                }
                Account acct = getAccountAndDepositData(acctDtl);
                
                if (userPreferences.containsKey(acct.getNumber())) {
                    ProductPreference prodPref = userPreferences.get(acct.getNumber());
                    acct.setNickName(prodPref.getNickName());
                    acct.setDisplaySequence(prodPref.getDisplaySequence());
                    acct.setIsFavorite(prodPref.getIsFavorite());
                    acct.setIsHide(prodPref.getIsHide());
                    acct.setIban(acctDtl.getIban());
                    // Add all favorite products
                    if (prodPref.getIsFavorite()) {
                        if (AccountType.TD.getCode().equals(acctDtl.getAccountType())) {
                            acct.setProduct(ProductTypes.DEPOSIT.name());
                            customerFavouriteProducts.addDeposit(acct);
                        } else {
                            acct.setProduct(ProductTypes.ACCOUNT.name());
                            customerFavouriteProducts.addAccount(acct);
                        }
                    }
                } else {
                    acct.setDisplaySequence(0);
                }
                
                // If iSave account to get the count to show on dashboard
                if (ProductCode.ISAVE.getCode().equals(acctDtl.getAccountCategoryCode())) {
                    acct.setAccountSubType("isave");
                    customerProducts.addIsave(acct);
                    customerProducts.addAccount(acct); // Adding Isave Account in account list after discussing with Pratik
                } else {
                    if (AccountType.TD.getCode().equals(acctDtl.getAccountType())) {
                        customerProducts.addDeposit(acct);
                    } else {
                        customerProducts.addAccount(acct);
                    }
                }
                
                if (Objects.nonNull(acctDtl.getDebitCards()) && !acctDtl.getDebitCards().isEmpty()) {
                    acctDtl.getDebitCards().stream().forEach(debitCard -> {
                        if (DateTimeHelper.INSTANCE.isFutureDate(debitCard.getExpirationDate(), DATE_DDMMYYYY)) {
                            if (DebitCardStatus.NEW_CARD.getCode().equals(debitCard.getCardStatus())) {
                                featurePromotion.addMaskedDcNumber(TextUtils.INSTANCE.maskCardNumber(debitCard.getDebitCardIdentifier(), AppConstants.MASK_CHARCTER));
                                if ("N".equalsIgnoreCase(debitCard.getCardDisplayIndicator())) {
                                    featurePromotion.incrementDebitCardCount();
                                }
                            }
                            if (AppConstants.DBT_CARD_ALLOWED_STATUS.contains(debitCard.getCardStatus())) {
                                Product product = new Product();
                                product.setLabel(TextUtils.INSTANCE.maskCardNumber(debitCard.getDebitCardIdentifier(), AppConstants.MASK_CHARCTER));
                                product.setProdRef(TextUtils.INSTANCE.getCardRef(debitCard.getDebitCardIdentifier()));
                                product.setStatus(DebitCardStatus.find(debitCard.getCardStatus()).getStatusDesc());
                                product.setProductType(ProductTypes.DEBIT);
                                product.setExpiryDate(DateTimeHelper.INSTANCE.formatDate(debitCard.getExpirationDate(), DATE_DDMMYYYY, DATE_MMYY));
                                if (Objects.nonNull(debitCard.getIssueDate()) && !debitCard.getIssueDate().isEmpty()) {
                                    product.setIssueDate(DateTimeHelper.INSTANCE.formatDate(debitCard.getIssueDate(), DATE_DDMMYYYY, DATE_MMYY));
                                } else {
                                    product.setIssueDate(debitCard.getIssueDate());
                                }
                                product.setDigitalCardIndicator(debitCard.getDigitalCardIndicator());
                                product.setVirtualCardIndicator(debitCard.getVirtualCardIndicator());
                                // product.setIssueDate(staticDataRepository.fetchStaticData_EN(VIRTUAL_DEBIT_CARD, ISSUE_DATE).getDescription());
                                // product.setDigitalCardIndicator(staticDataRepository.fetchStaticData_EN(VIRTUAL_DEBIT_CARD, DIGITAL_CARD_INDICATOR).getDescription());
                                // product.setVirtualCardIndicator(staticDataRepository.fetchStaticData_EN(VIRTUAL_DEBIT_CARD, VIRTUAL_CARD_INDICATOR).getDescription());
                                log.info("Virtual Debit card IssueDate, Digital", product.getIssueDate(), product.getVirtualCardIndicator(), product.getDigitalCardIndicator());
                                acct.addDebitCard(product);
                            }
                        }
                        
                        log.info("Debit Card Status " + DebitCardStatus.CARD_ACTIVE.getCode());
                        log.info("Debit Fetch Card Status " + debitCard.getCardStatus());
                        
                        if (DebitCardStatus.CARD_ACTIVE.getCode().equals(debitCard.getCardStatus())) {
                            if ("N".equalsIgnoreCase(debitCard.getCardDisplayIndicator())) {
                                featurePromotion.incrementActiveDebitCardCount();
                            }
                        }
                    });
                }
            }
        }
    } else {
        log.warn("Account:{} is not allowed on Dashboard View", acctDtl);
    }
}

kubectl cp <pod_name>:/var/kafka-ssl/abc.jks /local/path/abc.jks
kubectl exec -n <namespace> <pod_name> -- readlink -f /var/kafka-ssl/abc.jks

[root@g42uatlibmb1 npss]# kubectl exec -n npss npss-notifications-6467fb85db-4g5bq  -- readlink -f /var/ssl-store-kafka-ks/ibmb.keystore.uat.jks
/var/ssl-store-kafka-ks/..2024_06_24_07_46_23.547751902/ibmb.keystore.uat.jks
[root@g42uatlibmb1 npss]# kubectl cp npss-notifications-6467fb85db-4g5bq :..2024_06_24_07_46_23.547751902/ibmb.keystore.uat.jks /root/abc.jks
error: filespec must match the canonical format: [[namespace/]pod:]file/path
[root@g42uatlibmb1 npss]# kubectl cp npss-notifications-6467fb85db-4g5bq :/var/ssl-store-kafka-ks/..2024_06_24_07_46_23.547751902/ibmb.keystore.uat.jks  /root/abc.jks
error: filespec must match the canonical format: [[namespace/]pod:]file/path

kubectl cp npss/npss-notifications-6467fb85db-4g5bq:/var/ssl-store-kafka-ks/..2024_06_24_07_46_23.547751902/ibmb.keystore.uat.jks /root/abc.jks



String jsonString = "{"
    + "\"applicationArea\":{"
        + "\"countryOfOrigin\":\"AE\","
        + "\"senderId\":\"MOB\","
        + "\"transactionId\":\"A9f5243582a124a42bfa8fbe35e5db3e8\","
        + "\"transactionDateTime\":\"2024-XX-XXT04:01:04.004Z\","
        + "\"language\":\"EN\","
        + "\"creationDateTime\":\"22/Jun/2024 04:01:04\","
        + "\"requiredExecutionDate\":\"22/Jun/2024 04:01:04\""
    + "},"
    + "\"responseStatus\":{"
        + "\"status\":\"SUCCESS\","
        + "\"errorDetails\":[{"
            + "\"errorCode\":\"0\","
            + "\"errorDesc\":\"SUCCESS\""
        + "}]"
    + "},"
    + "\"common\":{"
        + "\"rateMode\":\"DBMODE\","
        + "\"rateReferenceNumber\":\"NA\""
    + "},"
    + "\"ratesResponse\":[{"
        + "\"buyCurrency\":\"USD\","
        + "\"sellCurrency\":\"AED\","
        + "\"buyingRate\":3.65779,"
        + "\"sellingRate\":3.68827,"
        + "\"dealtCurrency\":\"AED\","
        + "\"dealtAmount\":100.0,"
        + "\"status\":\"OK\","
        + "\"ccyPair\":\"USD.AED/S\","
        + "\"GMbuyingRate\":3.67248,"
        + "\"GMsellingRate\":3.67358,"
        + "\"GMbuyingMargin\":0,"
        + "\"GMsellingMargin\":0"
    + "}]"
+ "}";

22 Jun 2024 04:01:04,332 INFO (WebContainer : 31) (MOBILE-1000753765) [RequestInterceptor:]: Resource:/ft/mcsend/v1/fxrate/fetch, Request:{"amount":100.0,"fr
omCurrency":"AED","toCurrency":"PHP","transferCurrency":"AED","transferType":"P2P","txnRef":"f1db6b034aec4e44882ec1bbcf99d622"}

22 Jun 2024 04:01:04,332 INFO (WebContainer : 31) (MOBILE-1000753765) [RequestResolver:]: pathURL /ft/mcsend/v1/fxrate/fetch
22 Jun 2024 04:01:04,332 INFO (WebContainer : 31) (MOBILE-1000753765) [RequestResolver:]: rootPath:/ft
22 Jun 2024 04:01:04,332 INFO (WebContainer : 31) (MOBILE-1000753765) [RequestResolver:]: remainingPath:/mcsend/v1/fxrate/fetch
22 Jun 2024 04:01:04,341 INFO (WebContainer : 31) (MOBILE-1000753765) [FxRateSF:]: isNonUSDSettlement flag is :: false
22 Jun 2024 04:01:04,343 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: xref A9f5243582a124a42bfa8fbe35e5db3e8 | channelType "MOBILE"
22 Jun 2024 04:01:04,345 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: Connecting to URL:https://kproxy.risk-mw-pci-kong-prod.aeapps.bankfab
.com/ae/core/trapi/v1/exchange/rates, RequestType:POST, Headers:[{"name":"XXXX","value":"A9f5243582a124a42bfa8fbe35e5db3e8","elements":[{"name":"XXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXX","parameters":[],"parameterCount":0}]},{"name":"XXXXXXXX","value":"EN","elements":[{"name":"XX","parameters":[],"parameterCount":0}]},{
"name":"XXXXXXXXX","value":"MOB","elements":[{"name":"XXX","parameters":[],"parameterCount":0}]},{"name":"XXXXXXXXXXX","value":"87.200.21.97","elements":[{"n
ame":"XX.XXX.XX.XX","parameters":[],"parameterCount":0}]}]
22 Jun 2024 04:01:04,345 INFO (WebContainer : 31) (MOBILE-1000753765) [TextUtils:]: Masking special chars in log
22 Jun 2024 04:01:04,347 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: Http Request:{"rateObjectRequest":{"common":{"customerSegment":"IBMB.
MCSEND","valueDate":"2024-XX-XX","dealtCurrency":"AED","dealtAmount":100.0,"tenor":"SPOT","rateMode":"REALTIME","entity":"AE0XXXXX0001","daoCode":"1033X0100"
,"customerID":"1188110"},"rates":[{"buyCurrency":"USD","sellCurrency":"AED"}]},"applicationArea":{"countryOfOrigin":"AE","creationDateTime":"22/Jun/2024 04:0
1:04","requiredExecutionDate":"22/Jun/2024 04:01:04","senderId":"MOB","transactionDateTime":"2024-XX-XXT04:01:04.004Z","transactionId":"A9f5243582a124a42bfa8
fbe35e5db3e8","language":"EN"}}
22 Jun 2024 04:01:10,936 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: Status code 200
22 Jun 2024 04:01:10,936 INFO (WebContainer : 31) (MOBILE-1000753765) [TextUtils:]: Masking special chars in log
22 Jun 2024 04:01:10,938 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: Http Response:{"applicationArea":{"countryOfOrigin":"AE","senderId":"
MOB","transactionId":"A9f5243582a124a42bfa8fbe35e5db3e8","transactionDateTime":"2024-XX-XXT04:01:04.004Z","language":"EN","creationDateTime":"22/Jun/2024 04:
01:04","requiredExecutionDate":"22/Jun/2024 04:01:04"},"responseStatus":{"status":"SUCCESS","errorDetails":[{"errorCode":"0","errorDesc":"SUCCESS"}]},"common
":{"rateMode":"DBMODE","rateReferenceNumber":"NA"},"ratesResponse":[{"buyCurrency":"USD","sellCurrency":"AED","buyingRate":3.65779,"sellingRate":3.68827,"dea
ltCurrency":"AED","dealtAmount":100.0,"status":"OK","ccyPair":"USD.AED/S","GMbuyingRate":3.67248,"GMsellingRate":3.67358,"GMbuyingMargin":0,"GMsellingMargin"
:0}]}
22 Jun 2024 04:01:10,938 INFO (WebContainer : 31) (MOBILE-1000753765) [HttpConnector:]: Http request processed in :6595 msec for URL:https://kproxy.risk-mw-p
ci-kong-prod.aeapps.bankfab.com/ae/core/trapi/v1/exchange/rates
22 Jun 2024 04:01:10,939 INFO (WebContainer : 31) (MOBILE-1000753765) [FxRateServiceInvoker:]: API URL is : https://kproxy.risk-mw-pci-kong-prod.aeapps.bankf
ab.com/ae/core/trapi/v1/exchange/rates
22 Jun 2024 04:01:10,939 INFO (WebContainer : 31) (MOBILE-1000753765) [FxRateServiceInvoker:]: Handle 4XX errors in sf class..
22 Jun 2024 04:01:10,939 ERROR (WebContainer : 31) (MOBILE-1000753765) [ExceptionHandler:]: Handle null pointer exception for:java.lang.NullPointerException
22 Jun 2024 04:01:10,940 INFO (WebContainer : 31) (MOBILE-1000753765) [LocaleHelper:]: locale:en, code:SYS_DEFAULT_ERROR, text translation:We are unable to p
rocess your request right now. Please try again later.
22 Jun 2024 04:01:10,943 INFO (WebContainer : 31) (MOBILE-1000753765) [RequestInterceptor:]: Resource:/ft/mcsend/v1/fxrate/fetch response:{"result":{"status"
:"error","errorInfo":{"code":"SYS_DEFAULT_ERROR","desc":"We are unable to process your request right now. Please try again later. "}}}
22 Jun 2024 04:01:10,943 INFO (WebContainer : 31) (MOBILE-1000753765) [UserStatisticsSF:]: CIF ID in PageViewReport userID 10007X3765, convid ba461cb4f8e3448
a81baf93f48a3e2f5, url point /ft/mcsend/v1/fxrate/fetch::
22 Jun 2024 04:01:10,944 INFO (WebContainer : 31) (MOBILE-1000753765) [UserStatisticsSF:]: Page View Report {"cif":"10007X3765","cin":"1188110","channelType"
:"MOBILE","viewedPage":"/ft/mcsend/v1/fxrate/fetch","httpStatus":"SUCCESS","httpErrorCode":"0","httpErrorDesc":"SUCCESS","apiStatus":"error","apiErrorCode":"
SYS_DEFAULT_ERROR","rc":"A9f5243582a124a42bfa8fbe35e5db3e8","creationTime":1719014464062,"completionTime":1719014470943,"remoteIp":"87.200.21.97"} ::
22 Jun 2024 04:01:10,980 INFO (WebContainer : 31) (MOBILE-1000753765) [UserStatisticsSF:]: exiting publish2UserStatisticsQ method
22 Jun 2024 04:01:10,980 INFO (WebContainer : 31) (MOBILE-1000753765) [ResponseFilter:]: == URL:/ft/mcsend/v1/fxrate/fetch processed, total time:6932 msec ==
-----------------------------------------

	public McFxRateFetchResponse fetchMCFxRate(final McFxRateFetchRequest request) {
		McFxRateFetchResponse response = new McFxRateFetchResponse();
		return execute(request, response, req -> {
			boolean isNonUSDSettlement = false;
			Double marginPerc = null;
			Double fxRate = null;
			Double conversionRate = null;
			String toCurrency = request.getToCurrency();
			Integer timeToLive = null;
			
			List<McProduct> productByCurrAndType = mcSendRepository.getProductByCurrAndType(request.getToCurrency(),
					request.getTransferType());
			if (!productByCurrAndType.isEmpty()) {
				McProduct mcProduct = productByCurrAndType.get(0);
				if (Objects.nonNull(mcProduct) && StringUtils.isNotBlank(mcProduct.getCurrencyCode())
						&& mcProduct.getCurrencyCode().equalsIgnoreCase(mcProduct.getSendCurrency())) {
					isNonUSDSettlement = true;
				}
			}
			log.info("isNonUSDSettlement flag is :: {}", isNonUSDSettlement);
			if(!isNonUSDSettlement) {
				log.debug("continuing with non USD settlement flow");
				ExchangeRateRequest exchangeRateRequest = new ExchangeRateRequest();
				String dealtCurrency = CURR_AED;
				String buyCurrency = CURR_USD;
				String sellCurrency = CURR_AED;
				exchangeRateRequest.addRate(buyCurrency, sellCurrency, dealtCurrency);
				exchangeRateRequest.setCreditValueDate(new Date());
				exchangeRateRequest.setCustomerRateSegment(MCSEND_SEGMENT);
				exchangeRateRequest.setAmount(request.getAmount());
				
				// 1.Fetch AED to USD rate
				FxRateGetRateResponse exchangeRateResponse = exchangeRateServiceInvoker
						.fetchExchangeRate(exchangeRateRequest);
				if (Objects.nonNull(exchangeRateResponse)
						&& RATE_MODE_REALTIME.equalsIgnoreCase(exchangeRateResponse.getCommon().getRateMode())
						&& exchangeRateResponse.getRatesResponse().isEmpty()) {
					throw new AppException(ErrorCodes.ERROR_FETCH_FX_RATE);
				}

				if (Objects.nonNull(exchangeRateResponse)
						&& !RATE_MODE_REALTIME.equalsIgnoreCase(exchangeRateResponse.getCommon().getRateMode())
						&& exchangeRateResponse.getRateResponse().isEmpty()) {
					throw new AppException(ErrorCodes.ERROR_FETCH_FX_RATE);
				}
				
				RateResponse rateResponse = RATE_MODE_REALTIME.equalsIgnoreCase(exchangeRateResponse.getCommon().getRateMode())
						? exchangeRateResponse.getRatesResponse().get(0)
						: exchangeRateResponse.getRateResponse().get(0);
				Double aedToUsdRate = 1/rateResponse.getSellingRate();
				
				// 2.Fetch USD to FCY rate from DB
				
				McFcyRate mcFcyRate = mcSendRepository.getMcFcyRate(toCurrency, request.getTransferType());
				if (Objects.isNull(mcFcyRate)) {
					throw new AppException(ErrorCodes.ERROR_FETCH_FX_RATE);
				}
				Double usdToFcyRate = mcFcyRate.getFxRate();
				conversionRate = aedToUsdRate * usdToFcyRate;
				log.info("conversionRate received in non USD settlement flow is :: {}", conversionRate);
				
			}else {
				//getDeal invocation
				log.debug("continuing with USD settlement flow :: ");
				FxRateFetchRequest fxRatefetchReq = new FxRateFetchRequest();
				fxRatefetchReq.setFromCurrency(request.getFromCurrency());
				fxRatefetchReq.setToCurrency(toCurrency);
				fxRatefetchReq.setTransferCurrency(request.getTransferCurrency());
				fxRatefetchReq.setAmount(request.getAmount());
				fxRatefetchReq.setTxnRef(request.getTxnRef());
				GetDealResponse dealResponse = getDeal(fxRatefetchReq);
				log.debug("Deal resp received is :: {}", dealResponse);
				if (Objects.nonNull(dealResponse)&&Objects.nonNull(dealResponse.getRate())) {
					conversionRate = 1/dealResponse.getRate().getValue();
					timeToLive = dealResponse.getTimeToLive();
				}else {
					throw new AppException(ErrorCodes.SYS_TECHNICAL_ERROR);
				}
				log.info("conversionRate received in USD settlement flow is :: {} and timeToLive is :: {}", conversionRate, timeToLive);
			}
			
			// 3.fetch margin
			//Double fxRate = aedToFcyRate;
			if (!productByCurrAndType.isEmpty()) {
				McProduct mcProduct = productByCurrAndType.get(0);
				if (Objects.nonNull(mcProduct)) {
					List<String> staffSectorList = settingsRepository.getStaffSectorList();
					if (SessionContext.getSession().getUser().identifyStaff(staffSectorList)) {
						marginPerc = mcProduct.getStaffFxMargin();
					}else
						marginPerc = mcProduct.getFxMargin();
				}
			}
			if (Objects.nonNull(marginPerc)) {
				fxRate = (conversionRate * (1 - marginPerc / 100));
			}
			McFxRate mcFxRate = new McFxRate();
			mcFxRate.setRate(new Amount(fxRate, toCurrency));
			mcFxRate.setTransferAmount(new Amount(fxRate * request.getAmount(), toCurrency));
			mcFxRate.setFromCurrency(request.getFromCurrency());
			mcFxRate.setToCurrency(toCurrency);
			mcFxRate.setTimeToLive(timeToLive);
			List<McFxRate> mcFxRates = new ArrayList<>();
			mcFxRates.add(mcFxRate);
			response.setMcFxRates(mcFxRates);
			log.debug("McFxRate is :: {}", mcFxRate.getRate());
			
			// 4. UPDATE rates in txnsession
			TxnSession txnSession = sessionRepository.findTxnSessionByTxnRef(req.getTxnRef());
			String exchangeRateStr = txnSession.getExchangeRate();
			log.debug("exchangeRateStr received from DB is :: {}", exchangeRateStr);
			FxRateGetDealResponse fxRateDealResponse = null;
			if(isNonUSDSettlement) {
				if (StringUtils.isNotBlank(exchangeRateStr)) {
					fxRateDealResponse = JsonUtils.convertToObject(FxRateGetDealResponse.class, exchangeRateStr);
					log.debug("exchangeRate received from deal service is :: {}", fxRateDealResponse);
				}else {
					log.error("Didnt receive exchangerate infor from session repo");
				}
			}
			McExchangeRate mcExchangeRate = new McExchangeRate();
			//if fx rate not exist in session
			if (StringUtils.isNotBlank(exchangeRateStr)) {
				mcExchangeRate = JsonUtils.convertToObject(McExchangeRate.class, exchangeRateStr);
			}
			mcExchangeRate.setFxRate(conversionRate);//dealWrapperRate
			mcExchangeRate.setFxRateWithMargin(fxRate);
			mcExchangeRate.setFxMargin(marginPerc);
			mcExchangeRate.setTrapiFxRate(conversionRate);//dealWrapperRate
			mcExchangeRate.setExchangeRate(!Objects.isNull(fxRateDealResponse)?getExchangeRateObj(fxRateDealResponse):null);
			log.info("final mcExchangeRate formed is :: {}", mcExchangeRate);
			
			TxnSession session = new TxnSession();
			session.setExchangeRate(JsonUtils.convertToJson(mcExchangeRate));
			session.setTxnRef(req.getTxnRef());
			log.info("Update TXN Session | txnRef: {} exchangerate:{}",req.getTxnRef(),JsonUtils.convertToJson(mcExchangeRate));
			sessionRepository.updateExchangeRate(session);

			return response;
		});
	}

----------------------------------------------------
public FxRateGetRateResponse fetchExchangeRate(ExchangeRateRequest iibRequest) {
		return invoke(ServiceURLs.FX_EXCHANGE_RATE,iibRequest,requestComposer, responseComposer);
	}

----------------------------------------------------
protected <T, R> R invoke(final ServiceURLs serviceURL, T reqObj, Function<T, String> requestComposer, Function<ConnectorResponse, R> responseComposer) {
		ConnectorResponse response = null;
		R respObj = null;
		long t1 = System.currentTimeMillis();
		try {
			serviceInvokerHelper.populateServicUrlEnum(serviceURL);
			String request = requestComposer.apply(reqObj);
			response = httpConnector.post(serviceURL, request, null);
			handleResponse(response, serviceURL);
			respObj = responseComposer.apply(response);
		} catch (Exception e) {
			if (e instanceof AppException || e instanceof SysException) {
				throw e;
			}
			log.error("service invoke failed.." , e);
			throw new AppException(ErrorCodes.SYS_TECHNICAL_ERROR, e);
		} finally {
			log.debug("Service:{} invocation time:{} msec", serviceURL, System.currentTimeMillis() - t1);
			captureHttpStatus(response);
		}
		return respObj;
	}

-------------------------------------------------------
private final Function<ExchangeRateRequest,String> requestComposer = (iibRequest)->{	   
	    Map<String, Object> reqMap = new HashMap<>();
	    SessionInfo sessionInfo = SessionContext.getSession();
	    reqMap.put(APPLICATION_AREA,FABUtils.INSTANCE.getIibReqApplicationArea(sessionInfo.getChannelType(), localeHelper.resolveLanguage(), sessionInfo.getXref()));
	    reqMap.put(RATE_REQ_OBJECT, populateIIBRequest(iibRequest));
	    return JsonUtils.convertToJson(reqMap);
	};
		
	private final Function<ConnectorResponse, FxRateGetRateResponse> responseComposer = (response) -> {
		FxRateGetRateResponse serviceResponse = new FxRateGetRateResponse();
		if (AppConstants.SUCCESS.equalsIgnoreCase(JsonUtils.getJsonPrimitive(response.getJsonResponse(), "$.responseStatus.status"))) {
			serviceResponse = JsonUtils.convertToObject(FxRateGetRateResponse.class, response.getJsonResponse());
		} else {
			throw new AppException(ErrorCodes.ERROR_FETCH_FX_RATE);
		}	
		
		return serviceResponse;
	};




https://www.credly.com/users/umer-farooq.1cd67eef/badges
https://cs.lpi.org/caf/Xamman/certification/verify/LPI000281162/jjngcyhqvv
http://81cd1176253f3f59d435-ac22991740ab4ff17e21daf2ed577041.r77.cf1.rackcdn.com/Certificates/ScrumFundamentalsCertified-UmerFarooq-554089.pdf
http://certification.salesforce.com/certification-detail-print?conId=0034A00002p

*/5 * * * *
If a user enters a credit card number:

It will check if the card is from one of these banks: FIRST GULF BANK, NATIONAL BANK OF ABU DHABI, or FIRST ABU DHABI BANK.
If the card is from one of these banks:
It will make sure the account is in AED (Emirati Dirham) and belongs to the logged-in user.
If the card is not from one of these banks:
It will check if it is a valid IBAN number.

0 0 5 * * ?
 filters records to only include those that have been modified within the past 24 hours from the current time.

Detailed Breakdown for Stakeholders with Justifications
Product Content Configuration:

Integration with Sitecore API:
Task: Develop robust API clients and handle authentication, data retrieval, and error handling.
Justification: Integrating with the Sitecore API is essential to ensure real-time updates and accurate product information on the website. Robust error handling and authentication are necessary to maintain data integrity and security.
Estimation: 2 weeks
Database Design:
Task: Create a database schema to efficiently store and query product details.
Justification: A well-designed database schema ensures that product data is stored efficiently and can be retrieved quickly, which is crucial for performance and scalability.
Estimation: 1 week
API Development:
Task: Build scalable REST APIs to serve the product content to the frontend applications.
Justification: Exposing product details through a REST API allows for decoupling the backend and frontend, making the system more modular and easier to maintain. It also facilitates integration with other systems or future enhancements.
Estimation: 2 weeks
UI/UX - Capture User Data:

Content Configuration:
Task: Set up configurations for content delivery, ensuring it is responsive to user inputs and preferences.
Justification: Dynamic content delivery enhances user experience by providing personalized information based on user inputs, which can increase user engagement and satisfaction.
Estimation: 1 week
Data Capture Endpoints:
Task: Develop backend endpoints to securely capture and store user data.
Justification: Capturing user data accurately and securely is crucial for compliance with data protection regulations and for personalizing user experience. Ensuring secure data handling prevents potential data breaches.
Estimation: 2 weeks
Validation and Processing:
Task: Implement server-side validation to ensure data integrity and security.
Justification: Validating data on the server-side helps prevent invalid or malicious data from entering the system, thus protecting the application from potential attacks and ensuring data quality.
Estimation: 1 week
Quote Functionality:

Service Integration:
Task: Develop service layer to communicate with insurance microservices.
Justification: Integrating with external microservices allows for leveraging existing functionalities and data from insurance providers, which can reduce development time and improve reliability.
Estimation: 3 weeks
Quote Logic Enhancement:
Task: Update existing quote creation logic to handle new insurance options.
Justification: Enhancing the quote functionality to include additional insurance options provides users with more choices, potentially increasing conversion rates and customer satisfaction.
Estimation: 2 weeks
Testing and Validation:
Task: Perform extensive testing to ensure the new quote functionality works seamlessly with existing systems.
Justification: Thorough testing is essential to identify and fix bugs, ensuring that the new features work correctly and do not introduce any regressions. This helps maintain system stability and reliability.
Estimation: 2 weeks

Summary with Justifications
Total Duration: Approximately 13 weeks
Resources: Depending on the team size and expertise, parallel task execution might reduce the overall time.
Justifications:
Integration Tasks: Necessary for ensuring that the backend can communicate effectively with external systems and provide real-time, accurate data to the frontend.
Database Design: Critical for performance, scalability, and efficient data retrieval.
API Development: Facilitates modularity, maintainability, and potential future integrations.
Content Configuration: Enhances user experience through personalized content delivery.
Data Capture and Validation: Ensures data integrity, compliance with regulations, and security against potential threats.
Service Integration and Logic Enhancement: Provides users with enhanced functionalities and options, improving overall service offering.
Testing and Validation: Ensures the reliability and stability of the system, preventing future issues.
This detailed and justified plan helps stakeholders understand the necessity of each task, the effort involved, and the benefits these tasks bring to the overall project. This understanding is crucial for accurate resource allocation and time estimation.


----------------------------
Product Content Configuration
Tasks:
Integration with Sitecore API:
Needs to be built from scratch: Developing API clients to fetch product data from Sitecore.
Database Design:
Needs to be built from scratch: Creating a database schema to store product details.
API Development:
Needs to be built from scratch: Building REST APIs to expose product details.
UI/UX - Capture User Data
Tasks:
Content Configuration:
Needs to be built from scratch: Setting up configurations for content delivery based on user data.
Data Capture Endpoints:
Needs to be built from scratch: Developing endpoints to capture and store user data.
Validation and Processing:
Needs to be built from scratch: Implementing server-side validation and processing for captured data.
Quote Functionality
Tasks:
Service Integration:
Needs to be built from scratch: Developing service layers to communicate with insurance microservices.
Quote Logic Enhancement:
Enhancement: Updating existing quote creation logic to handle new insurance options.
Testing and Validation:
Needs to be built from scratch: Performing extensive testing of the new and enhanced functionalities.
Summary of Tasks
Needs to be built from scratch:
Product Content Configuration

Integrate with Sitecore API
Design and implement database schema for product data
Develop REST APIs to expose product details
UI/UX - Capture User Data

Configure content delivery based on user data
Develop endpoints for capturing and storing user data
Implement server-side validation and processing
Quote Functionality

Integrate with insurance microservices
Perform comprehensive testing of new and enhanced functionalities
Needs to be enhanced:
Quote Functionality
Update the existing quote creation logic to handle new insurance options
Detailed Justification
Product Content Configuration:

Integration with Sitecore API: This task involves building the integration from scratch as it requires developing new API clients and handling specific authentication and data retrieval mechanisms.
Database Design: Creating a new database schema is necessary to store the product data effectively.
API Development: New REST APIs are required to expose product details, ensuring that frontend applications can access this data seamlessly.
UI/UX - Capture User Data:

Content Configuration: This involves setting up a new configuration system to deliver content dynamically based on user inputs, which is a new build.
Data Capture Endpoints: Developing new endpoints to capture and store user data is essential for personalizing the user experience.
Validation and Processing: Implementing server-side validation and processing ensures data integrity and security, which needs to be built from scratch.
Quote Functionality:

Service Integration: This involves building new service layers to communicate with insurance microservices, which is a new task.
Quote Logic Enhancement: Modifying the existing quote creation logic to include new insurance options is an enhancement of the current functionality.
Testing and Validation: Comprehensive testing of both new and enhanced functionalities is crucial to ensure system stability and reliability.
This breakdown helps stakeholders understand the scope of new developments and enhancements, allowing for better estimation of build efforts and resource allocation.
